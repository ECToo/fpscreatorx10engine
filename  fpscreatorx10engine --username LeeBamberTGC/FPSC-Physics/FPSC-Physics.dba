rem
rem PHYSICS SYSTEM
rem

_physics_init:

rem PHYSX Initiaise
gphysicshasbeeninitialised=1
if physxedition=1
 `
 rem Init PHYSC
 gosub _phy_init
 `
else
 `
 rem Init ODE
 ode start : rem set to regular world stepping
 `
 rem X10 graivty stronger
 `switch on gravity after warm-up so entities do not drift down at sraer
 `ode set world gravity physicsgravx#,physicsgravy#,physicsgravz#
 ode set world gravity 0,0,0
 `
 rem 030707 - made ragdolls mode solid by decreasing CFM (need this for ragdolls onyl)
 ode set world cfm 0.000002 : rem this is good for ragdolls who hold their fixed joints
 ode set world erp 0.2 : rem 0.1 soft for ragdolls and crates
 `
endif

rem make physics universe
if object exist(physicsuniverseobj)=1 then delete object physicsuniverseobj
phyunimesh$=myownrootdir$+"levelbank\testlevel\universephy.dbo"
if file exist(phyunimesh$)=0
 load object myownrootdir$+"levelbank\testlevel\universe.dbo",physicsuniverseobj
 make mesh from object physicsuniverseobj,physicsuniverseobj
 convert mesh to vertexdata physicsuniverseobj
 delete object physicsuniverseobj
 make object physicsuniverseobj,physicsuniverseobj,0
 delete mesh physicsuniverseobj
 rem FPSCV104RC9-accelerate loading
 save object phyunimesh$,physicsuniverseobj
else
 load object phyunimesh$,physicsuniverseobj
endif
debugviewtext(321,"Created static geometry for physics universe")
if physxedition=1
 gosub _phy_universe
else
 ode create static triangle mesh physicsuniverseobj
endif
delete object physicsuniverseobj
if physicsproto=1
 load static objects myownrootdir$+"levelbank\testlevel\universe.dbo",0
endif
debugviewtext(322,"Submitted geometry to physics engine")

rem create entity assignments
for e=1 to entityelementmax
 `
 rem Sentinel disables physics for common non-physics items (non-multiplayer)
 entid=entityelement(e).bankindex
 if physicson>0 and gmultiplayergame=0
  rem and promotes others to specific types (1-normal,2-ignorestatic,3-becomestatic)
  rem Weapons, Ammo, Non-Objects, Immobile
  if entityprofile(entid).isweapon<>0 or entityprofile(entid).isammo<>0
   entityelement(e).eleprof.physics=0
  else
   if entityprofile(entid).ischaracter=1
    entityelement(e).eleprof.physics=2
   endif
   if entityelement(e).eleprof.isimmobile=1
    entityelement(e).eleprof.physics=3
   endif
  endif
  if entityelement(e).obj=0
   entityelement(e).eleprof.physics=0
  endif
 else
  rem usually no physics (most made static after loadentities see gamemain)
  entityelement(e).eleprof.physics=0
  rem multiplayer needs 'windows' as physics objects
  if gmultiplayergame=1
   if entityprofile(entid).isweapon=0 and entityprofile(entid).isammo=0 and entityprofile(entid).ischaracter=0
    if entityelement(e).eleprof.isimmobile=1
     entityelement(e).eleprof.physics=3
    endif
   endif
  endif
 endif
 `
 rem Safety trap, can cancel if entity not complete
 if entityelement(e).eleprof.physics<>0
  if entityelement(e).profileobj>0
   if object exist(entityelement(e).profileobj)=0
    entityelement(e).eleprof.physics=0
   endif
  else
   entityelement(e).eleprof.physics=0
  endif
 endif
 `
 rem X10 - 220807 - if multiplayer, characters have no physics
 if gmultiplayergame=1 
  if entityprofile(entid).ischaracter=1
   rem offset to correct position
   offset limb tobj,0,0,0,0
  endif
 endif
 `
 rem apply physics creation of object
 if entityelement(e).eleprof.physics<>0
  rem for physics bodies that have a center of mass, entity positions need altering to reflect correct position
  tobj=entityelement(e).obj
  rem X10 - 070307 - it seens chars need this, so that 
  rem all the other stuff works (bullet ray check, ODE box pos)
  rem X10 removed this in favour of controlling ODE object offset instead
  `if entityelement(e).eleprof.physics<>3
  if entityelement(e).eleprof.physics=1
   if tobj>0
    if object exist(tobj)=1
     tprofileobj=entityelement(e).profileobj
     tadj#=object collision center y(tprofileobj)
     tadj#=tadj#+5 : rem slight adjustment for thin objects that are spit out by physics geom collision
     entityelement(e).y=entityelement(e).y+tadj#
     position object tobj,object position x(tobj),object position y(tobj)+tadj#,object position z(tobj)
    endif
   endif
  endif
  rem create the physics body (if not child spawn entities)
  tspawnhide=0
  if entityelement(e).spawn.leaderid>0
   if entityelement(e).spawn.leader=0
    tspawnhide=1
   endif
  endif
  if tspawnhide=0
   if entityelement(e).spawn.leader=1
    rem spawn master does not need physics object
    gosub _physics_ensurephysicsobjvalid
   else
    rem everything else has physics to create
    gosub _physics_setupewithphysics
   endif
  else
   rem still need to reserve all obj ids with E
   gosub _physics_ensurephysicsobjvalid
  endif
 endif
 `
next e

rem Report progress
debugviewtext(323,"Applied physics settings to dynamic elements")

rem eat any old physics messages
if physxedition=1
 gosub _phy_collisionmessages_eat
else
 while ODE COLLISION MESSAGE EXISTS()
  ODE COLLISION GET MESSAGE
 endwhile
endif

rem shadow light position for global shadow effect
set point light 0,20*100,25*100,-20*100
set ambient light 75

rem no need for dbpro standard collision 'automated' system
SET GLOBAL COLLISION OFF

return

_physics_ensurephysicsobjvalid:
 `
 rem redim new size (takes tobj and e)
 tmax=array count(phyobjele())
 if tobj>tmax
  tmax=tobj
  dim phyobjvelocity#(tmax)
  dim phylasttravelled#(tmax)
  dim phylastfloorstop#(tmax)
  dim phyobjsounding(tmax)
  dim phyobjremove(tmax)
  dim phyobjele(tmax)
  dim phyobjelenudged(tmax)
  dim shadowobj(tmax)
 endif
 rem setup inits
 phyobjvelocity#(tobj)=0
 phylasttravelled#(tobj)=0
 phylastfloorstop#(tobj)=0
 phyobjsounding(tobj)=0
 phyobjremove(tobj)=0
 phyobjele(tobj)=e
 phyobjelenudged(tobj)=0
 shadowobj(tobj)=0
 `
return

_physics_loadmateriallist:
`
rem load material list
tfile$="audiobank\materials\materialdefault.txt"
addfiletocollection(tfile$)
if file exist(rootdir$+tfile$)=1
 `
 rem Load Data from file
 dim data$(999)
 load array rootdir$+tfile$,data$()
 for l=0 to 999
  line$=data$(l)
  if len(line$)>0
   if lower$(left$(line$,4))=";end" then exit
   if left$(line$,1)<>";"
    `
    rem take fieldname and values
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem load max materials
    tryfield$="materialmax" : if field$=tryfield$ then gmaterialmax=value1 : dim material(gmaterialmax) as materialsettingstype
    `
    rem load material data
    for m=0 to gmaterialmax
     tryfield$="matdesc"+str$(m) : if field$=tryfield$ then material(m).name$=value$
     tryfield$="matwave"+str$(m) : if field$=tryfield$ then material(m).tred0$=value$
     tryfield$="matwaves"+str$(m) : if field$=tryfield$ then material(m).scrape$=value$
     tryfield$="matwavei"+str$(m) : if field$=tryfield$ then material(m).impact$=value$
     tryfield$="matwaved"+str$(m) : if field$=tryfield$ then material(m).destroy$=value$
     tryfield$="matfreq"+str$(m) : if field$=tryfield$ then material(m).freq=value1
     tryfield$="matdecal"+str$(m) : if field$=tryfield$ then material(m).decal$=value$
    next m
    `
   endif
  endif
 next l
 undim data$()
endif
`
rem Fill in material defaults if info lacking
for m=0 to gmaterialmax
 if file exist(rootdir$+material(m).scrape$)=0 then material(m).scrape$=material(m).tred0$
 if file exist(rootdir$+material(m).impact$)=0 then material(m).impact$=material(m).tred0$
 if file exist(rootdir$+material(m).destroy$)=0 then material(m).destroy$=material(m).tred0$
 material(m).tred1$=left$(material(m).tred0$,len(material(m).tred0$)-4)+"A1.wav"
 material(m).tred2$=left$(material(m).tred0$,len(material(m).tred0$)-4)+"A2.wav"
 material(m).tred3$=left$(material(m).tred0$,len(material(m).tred0$)-4)+"A3.wav"
 material(m).tred0$=left$(material(m).tred0$,len(material(m).tred0$)-4)+"A4.wav"
 if material(m).freq=0 then material(m).freq=22000
next m
`
rem Load material sounds into memory
tbase=materialsoundoffset
for m=0 to gmaterialmax
 if material(m).name$<>""
  rem load tred sound (all five)
  snd$=material(m).tred0$
  if file exist(rootdir$+snd$)=1
   load 3dsound rootdir$+snd$,tbase
   addfiletocollection(snd$)
   set sound speed tbase,material(m).freq
   material(m).noise=tbase
   inc tbase
  else
   material(m).noise=0
  endif
  rem load scrape
  snd$=material(m).scrape$
  if file exist(rootdir$+snd$)=1
   load 3dsound rootdir$+snd$,tbase
   addfiletocollection(snd$)
   set sound speed tbase,material(m).freq
   material(m).scrapeid=tbase
   for tclones=1 to 4
    tbaseclone=tbase+tclones
    clone sound tbaseclone,tbase
   next tclones
   inc tbase,5
  else
   material(m).scrapeid=0
  endif
  rem load impact
  snd$=material(m).impact$
  if file exist(rootdir$+snd$)=1
   load 3dsound rootdir$+snd$,tbase
   addfiletocollection(snd$)
   set sound speed tbase,material(m).freq
   material(m).impactid=tbase
   for tclones=1 to 4
    tbaseclone=tbase+tclones
    clone sound tbaseclone,tbase
   next tclones
   inc tbase,5
  else
   material(m).impactid=0
  endif
  rem load destroy
  snd$=material(m).destroy$
  if file exist(rootdir$+snd$)=1
   load 3dsound rootdir$+snd$,tbase
   addfiletocollection(snd$)
   set sound speed tbase,material(m).freq
   material(m).destroyid=tbase
   for tclones=1 to 4
    tbaseclone=tbase+tclones
    clone sound tbaseclone,tbase
   next tclones
   inc tbase,5
  else
   material(m).destroyid=0
  endif
 endif
next m
materialsoundmax=(tbase-1)-materialsoundoffset
`
rem Load decals for materials
for m=0 to gmaterialmax
 material(m).decalid=0
 if material(m).name$<>""
  decal$=material(m).decal$
  gosub _decal_find
  if decalid<0 then decalid=0
  if decalid>0
   material(m).decalid=decalid
   decal(decalid).active=1
  endif
 endif
next m
`
return

_physics_triggermaterialsound:
 `
 rem when trigger, play a material sound
 if tsoundtrigger>0
  sbase=tsoundtrigger
  for tchannels=0 to 4
   ts=sbase+tchannels
   if sound exist(ts)=1
    if sound playing(ts)=0
     playinternalBC3dsound(ts,tsx#,tsy#,tsz#,25.0)
     tsndvolume#=80.0+(tvol#*0.2)
     tsndvolume#=(tsndvolume#/100.0)*soundvolumes(1)
     set sound volume ts,tsndvolume#
     if tspd#>2000 and tspd#<55000 then set sound speed ts,tspd#
     exit
    endif
   endif
  next tchannels
 endif
 `
return

_physics_setupewithphysics:
 tobj=entityelement(e).obj
 if tobj>0
  if object exist(tobj)=1
   tprofileobj=entityelement(e).profileobj
   if tprofileobj>0
    if object exist(tprofileobj)=1
     `
     rem prepare visual alighment for regular physics objects (not floaters or statics)
     if entityelement(e).eleprof.physics=1
      offset limb tprofileobj,0,object collision center x(tprofileobj)*-1,object collision center y(tprofileobj)*-1,object collision center z(tprofileobj)*-1
      offset limb tobj,0,object collision center x(tprofileobj)*-1,object collision center y(tprofileobj)*-1,object collision center z(tprofileobj)*-1
     endif
     set object collision off tobj
     `
     rem ensure entitydriven and pseudo-static start with null rotation
     if entityelement(e).eleprof.physics=2 or entityelement(e).eleprof.physics=3
      rem record object angle before apply physics to object
      entityelement(e).rx=object angle x(tobj)
      entityelement(e).ry=object angle y(tobj)
      entityelement(e).rz=object angle z(tobj)
      rem must ensure default matrix in ODE is unrotated to begin with (RY controls angle)
      yrotate object tobj,0
     endif
     `
     rem physics object is static or dynamic
     if entityelement(e).eleprof.physics=3
      rem static (dynamic response identical to static behaviour)
      if physxedition=1
       gosub _phy_pseudostaticentity
      else
       ode create dynamic box tobj : ode set response tobj,2 : ode set gravity tobj,0
      endif
     else
      `
      rem dynamic character or entity
      if entityprofile(entid).ischaracter=1
       rem X10 -081007 - character as box (slightly smaller than physical object size - top stop jiggle)
       tcharobjsizex#=object size x(tobj,1)*0.8
       tcharobjsizey#=object size y(tobj,1)*0.8
       tcharobjsizez#=object size z(tobj,1)*0.8
       if physxedition=1
         gosub _phy_characterentity
       else
        ode create dynamic box tobj,tcharobjsizex#,tcharobjsizey#,tcharobjsizez#
       endif
      else
       rem entity
       if physxedition=1
        gosub _phy_dynamicentity
       else
        if entityprofile(entid).collisionmode=3
         ode create dynamic cylinder tobj
        else
         if entityprofile(entid).collisionmode=4
          ode create dynamic sphere tobj
         else
          ode create dynamic box tobj
         endif
        endif
       endif
      endif
      if physxedition=1
       rem PHYSX tweaks - none
      else
       rem ODE specific tweaks
       rem X10 - 280907 - for VERY SMALL OBJECTS, new ray cast code to stop them falling through world
       if object size x(tobj)<5 or object size y(tobj)<5 or object size z(tobj)<5
        ode set ray cast tfobj,1
       endif
       rem pre-test code to assign internally (now done in mapeditor)
       entityelement(e).floorposy=object position y(tobj)
       ode set contact fdir1 tobj, entityelement(e).eleprof.phyfriction
       ode set body mass tobj,entityelement(e).eleprof.phyweight
       rem some objects ignore static geom and gravity
       if entityelement(e).eleprof.physics=2 then ode set response tobj,1 : ode set gravity tobj,0
       rem stabalize the object
       ode set linear velocity tobj,0,0,0
       ode set angular velocity tobj,0,0,0
       rem recalc adjustment for objects that must find the floor perfectly
       centx#=ODE GET BODY ADJUSTMENT X(tobj)
       centy#=ODE GET BODY ADJUSTMENT Y(tobj)
       centz#=ODE GET BODY ADJUSTMENT Z(tobj)
       rem FPSCV101 - compensate for character model issues with a hack
       if entityprofile(entid).ischaracter=1
        rem X10 adjustment now done when entity is created/cloned
       else
        rem regular object full XYZ center needed
        offset limb tobj,0,(object collision center x(tprofileobj)*-1)+centx#,(object collision center y(tprofileobj)*-1)+centy#,(object collision center z(tprofileobj)*-1)+centz#
       endif
      endif
     endif
     `
     rem ensure entitydriven and pseudo-static than uses RY for rotation
     if entityelement(e).eleprof.physics=2 or entityelement(e).eleprof.physics=3
      if physxedition=1
       gosub _phy_rotateentity
      else
       ode set body rotation tobj,0,entityelement(e).ry,0
      endif
     endif
     `
    else
     hide object tobj
    endif
   else
    hide object tobj
   endif
  endif
 endif
 rem redim new size and init vars
 gosub _physics_ensurephysicsobjvalid
return

_physics_pushusingtvelandangle:
 `
 tobj=entityelement(e).obj
 if tobj>0
  if object exist(tobj)=1
   rem only for regular physics objects, not entitydriven characters, or statics (doors)
   if entityelement(e).eleprof.physics=1
    if physxedition=1
     gosub _phy_dynamicvelocity
    else
     tvel#=tvel*2.0
     if tvel<>0
      tvelx#=newxvalue(0,entityelement(e).ry,tvel#)
      tvelz#=newzvalue(0,entityelement(e).ry,tvel#)
      tangle#=sin(tangle)*tvel#
      tvelx#=tvelx#*cos(tangle)
      tvelz#=tvelz#*cos(tangle)
      ode set linear velocity tobj,tvelx#,tangle#,tvelz#
     endif
     if entityelement(e).eleprof.rotatethrow<>0
      trotate#=entityelement(e).eleprof.rotatethrow/10.0
      ode set angular velocity tobj,trotate#,0,trotate#
     endif
    endif
   endif
  endif
 endif
 `
return

_physics_switchoffe:
 `
 ttobj=entityelement(e).obj
 if ttobj>0
  if object exist(ttobj)=1
   if entityelement(e).eleprof.physics<>0
    if shadowobj(ttobj)=1
     set shadow shading off ttobj
     shadowobj(ttobj)=0
    endif
    if physxedition=1
     gosub _phy_removeentity
    else
     ode destroy object ttobj
    endif
    rem restore rotation of object (ode influence deleted)
    tentid=entityelement(e).bankindex
    if entityprofile(tentid).noragdoll=1
     rem V110 - 120210 - in restoring throw anims, final resting angle needed fixing
     rotate object ttobj,entityelement(e).rx,entityelement(e).ry+180,entityelement(e).rz
    else
     rotate object ttobj,entityelement(e).rx,entityelement(e).ry,entityelement(e).rz
    endif
    rem X10 also reset player gravity flag in case important ODE change means player change
    if physxedition=1
     rem PHYSX requires no reset
    else
     if object exist(physicsplayerborble)=1
      ode set active physicsplayerborble,1
      ode set gravity physicsplayerborble,1     
      phytotalmotioncount=0
      physuspendgravity=0
     endif
    endif
   endif
  endif
 endif
 `
return

_physics_ensureeisnotpenetrated:
 rem performed when physics object activates its presence (COLON)
 if physxedition=1
  rem PHYSX not needed
 else
  rem ODE stability tweak
  todee=e : todeobj=entityelement(e).obj
  for tte=1 to entityelementmax
   ttobj=entityelement(tte).obj
   if entityelement(tte).eleprof.physics<>0 and ttobj>0
    ttdy#=object position y(ttobj)-object position y(todeobj)
    if abs(ttdy#)<250
     rem if Ys close enough, do complete distance test
     ttdx#=object position x(ttobj)-object position x(todeobj)
     ttdz#=object position z(ttobj)-object position z(todeobj)
     ttdd#=sqrt(abs(ttdx#*ttdx#)+abs(ttdz#*ttdz#)+abs(ttdy#*ttdy#))
     if ttdd#<object size(todeobj)+object size(ttobj)
      rem give a nudge so it uses its own physics body to work out how to get out (brutal but efective)
      ode set linear velocity ttobj,0,0.01,0
     endif
    endif
   endif
  next tte
 endif
return

_physics_playerborble:
 `
 rem can call this to force player to camerapositionx,y,z
 rem borble that rattles around inside player ellipse
 phycrouched#=10.0 : phystood#=40.0
 phycrouchedellipsevolumesize#=0.25
 phystoodellipsevolumesize#=1.0
 if crouchmode<>0
  rem V110 - 190110 - handle starting player physics in crouch mode
  ellipsevolumesize#=phycrouchedellipsevolumesize#
  phyeyeheight#=phycrouched#
 else
  ellipsevolumesize#=phystoodellipsevolumesize#
  phyeyeheight#=phystood#
 endif
 ctx#=camerapositionx
 cty#=camerapositiony
 ctz#=camerapositionz
 `
 rem PHYSX or ODE
 if physxedition=1
  `
  rem PHYSX prepare object and physics for player
  if object exist(physicsplayerborble)=1
   gosub _phy_plr_delete
   delete object physicsplayerborble
  endif
  make object box physicsplayerborble,20,75,20
  color object physicsplayerborble,rgb(255,255,0)
  set object collision off physicsplayerborble
  position object physicsplayerborble,camerapositionx,(camerapositiony-phyeyeheight#)+1,camerapositionz
  if physicsdebug=1
   set object wireframe physicsplayerborble,1
   set object cull physicsplayerborble,0
  else
   hide object physicsplayerborble
  endif
  gosub _phy_plr_make
  `
  rem X10 added to keep ode_sounds from crashing
  e=0 : tobj=physicsplayerborble : gosub _physics_ensurephysicsobjvalid
  `
  rem ensure player has default gravity
  physuspendgravity=0
  phytotalmotioncount=0
  phytotalmotion#=0
  `
 else
  `
  rem ODE prepare object and physics for player
  if object exist(physicsplayerborble)=1
   ode destroy object physicsplayerborble
   delete object physicsplayerborble
  endif
  make object sphere physicsplayerborble,38
  color object physicsplayerborble,rgb(255,255,0)
  set object collision off physicsplayerborble
  position object physicsplayerborble,camerapositionx,(camerapositiony-phyeyeheight#)+1,camerapositionz
  if physicsdebug=1
   set object wireframe physicsplayerborble,1
   set object cull physicsplayerborble,0
  else
   hide object physicsplayerborble
  endif
  ode create dynamic sphere physicsplayerborble
  ode set contact fdir1 physicsplayerborble,500
  ode set body mass physicsplayerborble,physicsplayerweight#
  ode set linear velocity physicsplayerborble,0,0,0
  ode set angular velocity physicsplayerborble,0,0,0
  `
  rem X10 added to keep ode_sounds from crashing
  e=0 : tobj=physicsplayerborble : gosub _physics_ensurephysicsobjvalid
  `
  rem ensure player has default gravity
  ode set gravity physicsplayerborble,1
  physuspendgravity=0
  phytotalmotioncount=0
  phytotalmotion#=0
  `
  rem X10 I think the player kept falling through the floor
  rem becuse it was usin gravity when it did not need to
  ode set gravity physicsplayerborble,0
  `
 endif
 `
return

_physics_cleanup:

rem free universe
if physxedition=1
 delete static objects
endif

rem delete physics universe and free ode static collision
if physxedition=1
 gosub _phy_close
else
 ode destroy object physicsuniverseobj
endif
if object exist(physicsuniverseobj)=1
 delete object physicsuniverseobj
endif

rem delete physics player borble
if physxedition=1
 gosub _phy_plr_delete
else
 ode destroy object physicsplayerborble
endif
if object exist(physicsplayerborble)=1
 delete object physicsplayerborble
endif

rem free assignments
for e=1 to entityelementmax
 tobj=entityelement(e).obj
 if tobj>0
  if entityelement(e).eleprof.physics<>0
   if object exist(tobj)=1
    if physxedition=1
     ttobj=tobj : gosub _phy_removeentity
    else
     ode destroy object tobj
    endif
   endif
  endif
 endif
next e

rem end physics
gphysicshasbeeninitialised=0
if physxedition=1
 gosub _phy_close
else
 ode end
endif

rem free material sounds
gosub _physics_deletematerialsounds

return

_physics_startgravityafterwarmup:
 `
 rem entities can be pushed under floor during warmup
 if physxedition=1
  rem not needed for PHYSX
 else
  ode set world gravity physicsgravx#,physicsgravy#,physicsgravz#
 endif
 `
return

_physics_deletematerialsounds:
 `
 rem delete all material sounds
 for s=materialsoundoffset to materialsoundoffset+materialsoundmax
  if sound exist(s)=1 then delete sound s
 next s
 `
return

`
` Player Controls
`

_physics_unmark:
 `
 rem remove player from viscol prior to movement (use vis from write state)
 tx=viscx#/25 : ty=viscy#/100 : tz=viscz#/-25 : tty=ty
 if gmultiplayergame=1
  if ty>=0 and ty<=viscoly
   if tx>=0 and tz>=0
    if tx<=viscolx and tz<=viscolz
     if viscolmap(tx,ty,tz)=-1 then viscolmap(tx,ty,tz)=0
    endif
   endif
  endif
 else
  if tty>=0 and tty<=viscoly
   for ttx=tx-1 to tx+1
    for ttz=tz-1 to tz+1
     if ttx>=0 and ttz>=0
      if ttx<=viscolx and ttz<=viscolz
       if viscolmap(ttx,tty,ttz)=-1 then viscolmap(ttx,tty,ttz)=0
      endif
     endif
    next ttz
   next ttx
  endif
 endif
 `
return

_physics_mark:
 `
 rem place viscol data back after player movement
 tx=camerapositionx/25 : ty=camerapositiony/100 : tz=camerapositionz/-25 : tty=ty
 if gmultiplayergame=1
  if ty>=0 and ty<=viscoly
   if tx>=0 and tz>=0
    if tx<=viscolx and tz<=viscolz
     if viscolmap(tx,ty,tz)=0 then viscolmap(tx,ty,tz)=-1
    endif
   endif
  endif
 else
  if tty>=0 and tty<=viscoly
   for ttx=tx-1 to tx+1
    for ttz=tz-1 to tz+1
     if ttx>=0 and ttz>=0
      if ttx<=viscolx and ttz<=viscolz
       if viscolmap(ttx,tty,ttz)=0 then viscolmap(ttx,tty,ttz)=-1
      endif
     endif
    next ttz
   next ttx
  endif
 endif
 viscx#=camerapositionx : viscy#=camerapositiony : viscz#=camerapositionz
 `
return

_physics_playerrelocations:
 `
 rem handle lift mechanism for player
 if meridinglift<>0
  tobj=entityelement(meridinglift-1).obj
  rem X10 - 081007 - if underwater, and lift not moved, do not other holding player put
  tokay=1
  if waterisbelowplayer=2
   if meridingliftlastypos<>0
    if int(object position y(tobj))=int(meridingliftlastypos)
     tokay=0
    endif
   endif
   meridingliftlastypos=object position y(tobj)
  endif
  if tokay=1
   meridinglifty#=object position y(tobj)+60
   tmex#=camerapositionx : tmey#=camerapositiony : tmez#=camerapositionz
   tdstx#=object position x(tobj)-tmex#
   tdstz#=object position z(tobj)-tmez#
   tdstt#=sqrt(abs(tdstx#*tdstx#)+abs(tdstz#*tdstz#))
   position camera playercam,camerapositionx,meridinglifty#,camerapositionz
   camerapositionx=camera position x(playercam)
   camerapositiony=camera position y(playercam)
   camerapositionz=camera position z(playercam)
   gosub _physics_playerborble
   if tdstt#>90
    meridinglift=0
   endif
   grav#=0 : gravlasty#=tmey#
  endif
 else
  rem reset ypos if no association with lift
  meridingliftlastypos=0
 endif
 `
 rem handle transporter mechanism for player
 if meridingtransporter=1
  rem player coord moved to new location, must deactivate camera collision for movement
  position camera playercam,tranmex#,tranmey#,tranmez#
  rotate camera playercam,0,tranmeangley#,0
  lastcamangx#=camera angle x(playercam)
  lastcamangy#=camera angle y(playercam)
  cx#=camera position x(playercam) : cy#=camera position y(playercam) : cz#=camera position z(playercam)
  cox#=cx# : coy#=cy# : coz#=cz#
  camerapositionx=camera position x(playercam)
  camerapositiony=camera position y(playercam)
  camerapositionz=camera position z(playercam)
  gosub _physics_playerborble
  meridingtransporter=0
 endif
 if memovingx#<>0.0
  memovingx#=0.0
 endif
 if memovingy#<>0.0
  memovingy#=0.0
 endif
 if memovingz#<>0.0
  memovingz#=0.0
 endif
 `
return

_physics_ensurephysicsisreset:
 `
 rem ensure physics has been reset when game loop begins
 if gphysicshasbeeninitialised=1
  if physxedition=1
   gosub _phy_update
  else
   ode update 0.001
  endif
 endif
 `
return

_physics_playercamera:

rem Camera in control of player one
plrid=1

rem Key configuration
if gtestgamemodefromeditor=1
 rem Preset TEST GAME Keys
 plrkeyW=17
 plrkeyA=30
 plrkeyS=31
 plrkeyD=32
 plrkeyQ=16
 plrkeyE=18
 plrkeyC=46
 plrkeyZ=44
 plrkeyR=19
 plrkeySPACE=57
 plrkeyRETURN=28
 plrkeySHIFT=42
 plrkeyF12=88
else
 rem from BUILD GAME config keys
 plrkeyW=listkey(1)
 plrkeyS=listkey(2)
 plrkeyA=listkey(3)
 plrkeyD=listkey(4)
 plrkeySPACE=listkey(5)
 plrkeyC=listkey(6)
 plrkeyRETURN=listkey(7)
 plrkeyR=listkey(8)
 plrkeyQ=listkey(9)
 plrkeyE=listkey(10)
 plrkeySHIFT=listkey(11)
 plrkeyZ=44
 plrkeyF12=88
endif

rem Read keys from config, and use in player control actions
if keystate(plrkeyW)=1 then plrkeyW=1 else plrkeyW=0
if keystate(plrkeyA)=1 then plrkeyA=1 else plrkeyA=0
if keystate(plrkeyS)=1 then plrkeyS=1 else plrkeyS=0
if keystate(plrkeyD)=1 then plrkeyD=1 else plrkeyD=0
if keystate(plrkeyQ)=1 then plrkeyQ=1 else plrkeyQ=0
if keystate(plrkeyE)=1 then plrkeyE=1 else plrkeyE=0
if keystate(plrkeyC)=1 then plrkeyC=1 else plrkeyC=0
if keystate(plrkeyZ)=1 then plrkeyZ=1 else plrkeyZ=0
if keystate(plrkeyR)=1 then plrkeyR=1 else plrkeyR=0
if keystate(plrkeySPACE)=1 then plrkeySPACE=1 else plrkeySPACE=0
if keystate(plrkeyRETURN)=1 then plrkeyRETURN=1 else plrkeyRETURN=0
if keystate(plrkeySHIFT)=1 then plrkeySHIFT=1 else plrkeySHIFT=0

rem hard coded arrow keys
if upkey()=1 then plrkeyW=1
if leftkey()=1 then plrkeyA=1
if downkey()=1 then plrkeyS=1
if rightkey()=1 then plrkeyD=1

rem Camera old information
ctox#=ctx# : ctoy#=cty# : ctoz#=ctz#

rem camera eye height (eye drops to base of elipse when no health)
if player(plrid).health<=0
 if ellipsevolumesize#=1.0 and (plrkeyC)=0
  phyeyeheight#=phyeyeheight#-1.0
  if phyeyeheight#<10.0 then phyeyeheight#=10.0
 else
  phyeyeheight#=phycrouched#
 endif
endif

rem get latest camera position
camerapositionx=object position x(physicsplayerborble)
camerapositiony=object position y(physicsplayerborble)+phyeyeheight#
camerapositionz=object position z(physicsplayerborble)
realcx#=camerapositionx : realcy#=camerapositiony : realcz#=camerapositionz

rem Umark player pos in viscolmap
gosub _physics_unmark

rem Handle any sudden playe relocations (transportation)
gosub _physics_playerrelocations

rem V109 - 100209 - extra code to handle swimming along surface of water
tnearsurfaceofwater=abs(camera position y(playercam)-waterlevel#)

rem X10 player can swim underwater
`if waterisbelowplayer=2 `V109
if waterisbelowplayer=2 or (waterisbelowplayer=1 and tnearsurfaceofwater<15)
 rem underwater
 if physxedition=1
  gosub _phy_plr_gravityoff
 else
  ode set gravity physicsplayerborble,0
 endif
else
 if physxedition=1
  gosub _phy_plr_gravityon
 else
  ode set gravity physicsplayerborble,1
 endif
endif

rem flyforce bleeds into camforce X and Y and Z
if camflyforcex#<0 then tsig=-1 else tsig=1
tamount#=camflyforcex# : if abs(tamount#)>60 then tamount#=60*tsig
camflyforcex#=(camflyforcex#-tamount#)*0.8
camforcex#=camforcex#+tamount#
if camflyforcez#<0 then tsig=-1 else tsig=1
tamount#=camflyforcez# : if abs(tamount#)>60 then tamount#=60*tsig
camflyforcez#=(camflyforcez#-tamount#)*0.8
camforcez#=camforcez#+tamount#

rem All controls when player has health
movement=0
if player(plrid).health>0
 `
 rem Peek controls (and adjustment)
 if ((plrkeyQ)=1 or (plrkeyE)=1) and onladder=0
  if peekfreeze=0
   if (plrkeyQ)=1 and peeklean#>-10.0 then peeklean#=peeklean#-4.0 : movement=1
   if (plrkeyE)=1 and peeklean#<10.0 then peeklean#=peeklean#+4.0 : movement=1
  endif
 else
  peeklean#=curvevalue(0,peeklean#,4.0)
  if abs(peeklean#)<1.0 then peeklean#=0.0 : peekfreeze=0
 endif
 `
 rem Gun Zoom Control
 if gunzoommode>0
  if gunzoommode>=1 and gunzoommode<=8 then inc gunzoommode
  if gunzoommode>=11 and gunzoommode<=19 then inc gunzoommode
  if gunzoommode<10
   plrzoomin#=gunzoommode : plrzoominchange=1
  endif
  if gunzoommode=10
   rem in full zoom
  endif
  if gunzoommode>10
   plrzoomin#=10-(gunzoommode-10) : plrzoominchange=1
  endif
 endif
 `
 rem Handle optical effect of zoom
 if plrzoominchange=1
  if plrzoomin#>1.0
   tresultfov#=75.0-(plrzoomin#*7)-gunzoommag#
   set camera fov playercam,tresultfov#
   if camera exist(2)=1 then set camera fov 2,tresultfov#
   if camera exist(4)=1 then set camera fov 4,tresultfov#
   if camera exist(5)=1 then set camera fov 5,tresultfov#
   if internalzoomhud>0 then hudid=internalzoomhud : hud(hudid).hide=0 : set sprite alpha hudid,(255.0/10.0)*plrzoomin#
  else
   tresultfov#=75.0
   set camera fov playercam,tresultfov#
   if camera exist(2)=1 then set camera fov 2,tresultfov#
   if camera exist(4)=1 then set camera fov 4,tresultfov#
   if camera exist(5)=1 then set camera fov 5,tresultfov#
   if internalzoomhud>0 then hudid=internalzoomhud : hud(hudid).hide=1
  endif
 endif
 plrzoominchange=0
 `
 rem crouch control
 if (plrkeyC)=1
  if crouchmode=0 and onladder=0 and jumpaction=0 then crouchmode=1
 else
  if crouchmode=1 then crouchmode=0
  if crouchmode=2 then crouchmode=3
 endif
 `
 rem Control camera movement
 if crouchmode<>0
  basespeed#=20
 else
  if (plrkeySHIFT)=1
   basespeed#=55
  else
   basespeed#=35
  endif
 endif
 if jumpaction=0
  rem regular speed from manouver
  speed#=basespeed#
 else
  rem fixed speed whilst jumping
  speed#=jumpspeed#
 endif
 `
 rem Movement (forward,backward,strafe)
 camerareachatrun#=0.0
 plrbasespeed#=basespeed#
 if jumpaction=0 then moveroty#=camera angle y(playercam) else moveroty#=jumpangle#
 if onladder=0
  if (plrkeyW)=0 and (plrkeyA)=0 and (plrkeyD)=0 and (plrkeyS)=0
   cameraspeed=0
  endif
  if peeklean#=0.0
   if (plrkeyW)=1
    if (plrkeyA)=1 then dec moveroty#,35
    if (plrkeyD)=1 then inc moveroty#,35
   else
    if (plrkeyS)=1
     if (plrkeyA)=0 and (plrkeyD)=0 then inc moveroty#,180
     if (plrkeyA)=1 then dec moveroty#,145
     if (plrkeyD)=1 then inc moveroty#,145
    else
     if (plrkeyA)=1 then dec moveroty#,90
     if (plrkeyD)=1 then inc moveroty#,90
    endif
   endif
   phyangle#=moveroty#
   if (plrkeyW)=1 or (plrkeyS)=1 or (plrkeyA)=1 or (plrkeyD)=1
    movement=1 : if crouchmode<>0 then movement=2
    tcameraspeed#=speed#*playerspeedratio#*(0.5+(cameradampen#/2.0))
    if cameraspeed<tcameraspeed# then inc cameraspeed,5
    if cameraspeed>tcameraspeed# then cameraspeed=tcameraspeed#
   endif
  endif
  if camerareachatrun#<cameraspeed/3.0 then camerareachatrun#=cameraspeed/3.0
  if camerareachatrun#<0 then camerareachatrun#=0
 else
`ladder?
`  phyangle#=moveroty#
`  if (plrkeyW)=1
`   movement=1
`   tcameraspeed#=speed#
`   if cameraspeed<tcameraspeed#
`    inc cameraspeed,5
`    if cameraspeed>tcameraspeed# then cameraspeed=tcameraspeed#
`   endif
`  endif
`  if (plrkeyS)=1
`   movement=1 : onladder=0
`   tcameraspeed#=speed#*-1
`   if cameraspeed<tcameraspeed#
`    inc cameraspeed,5
`    if cameraspeed>tcameraspeed# then cameraspeed=tcameraspeed#
`   endif
`  endif
 endif
 `
 rem Obtain motion from player borble
 if physxedition=1
  gosub _phy_plr_getmotion
 else
  tmotionx#=ode get body linear velocity x(physicsplayerborble)
  tmotiony#=ode get body linear velocity y(physicsplayerborble)
  tmotionz#=ode get body linear velocity z(physicsplayerborble)
 endif
 `
 rem Only suspend gravity if total movement small
 `if waterisbelowplayer=2 `V109
 if waterisbelowplayer=2 or (waterisbelowplayer=1 and tnearsurfaceofwater<15)
  rem no gravity to suspend if underwater
 else
  tmotion#=abs(tmotionx#)+abs(tmotiony#)+abs(tmotionz#)
  phytotalmotion#=phytotalmotion#+tmotion#
  inc phytotalmotioncount
  if phytotalmotioncount>20
   phytotalmotion#=phytotalmotion#/phytotalmotioncount
   if physxedition=1
    if phytotalmotion#<0.15
     physuspendgravity=1
    else
     physuspendgravity=0
    endif
   else
    if phytotalmotion#<10.0
     physuspendgravity=1
    else
     physuspendgravity=0
    endif
   endif
   phytotalmotioncount=0 
   phytotalmotion#=0
  endif
  rem update gravity with current motion
  grav#=tmotiony#
  rem suspend so can stand on slopes/stairs
  if movement<>0 or jumpaction=1 then physuspendgravity=0
  if physuspendgravity=1 or onladder=1
   if physxedition=1
    gosub _phy_plr_gravityoff
   else
    ode set gravity physicsplayerborble,0
   endif
   if physuspendgravity=1 then grav#=0
  else
   if physxedition=1
    gosub _phy_plr_gravityon
   else
    ode set gravity physicsplayerborble,1
   endif
  endif
 endif
 if physicsdebug=1 then print "GRAVITY VALUE=";grav#
 `
 rem movement velocity
 `if waterisbelowplayer=2 `V109
 if waterisbelowplayer=2 or (waterisbelowplayer=1 and tnearsurfaceofwater<15)
  rem reduce influence of movement when underwater
  tunderwaterspeed#=timeelapsed#*0.1
  camvelx#=tmotionx#+((newxvalue(0,phyangle#,cameraspeed))*tunderwaterspeed#)
  if (plrkeyS)=1
   camvely#=tmotiony#+((sin(camera angle x(playercam))*cameraspeed*1)*tunderwaterspeed#*2)
  else
   camvely#=tmotiony#+((sin(camera angle x(playercam))*cameraspeed*-1)*tunderwaterspeed#*2)
  endif
  camvelz#=tmotionz#+((newzvalue(0,phyangle#,cameraspeed))*tunderwaterspeed#)
  camvelx#=camvelx#*cos(camera angle x(playercam))
  camvelz#=camvelz#*cos(camera angle x(playercam))
 else
  camvelx#=newxvalue(0,phyangle#,cameraspeed)
  camvely#=grav#
  camvelz#=newzvalue(0,phyangle#,cameraspeed)
 endif
 `
 rem X10 - V109 - 290409 - if you are underwater or swimming on surface
 tallowjumpingnotinwater=1
 if waterisbelowplayer=2 or (waterisbelowplayer=1 and tnearsurfaceofwater<15)
  rem no jump action allowed
  tallowjumpingnotinwater=0
  jumpaction=0
 endif
 `
 rem Jump Control
 if onladder=0 and tallowjumpingnotinwater=1
  if player(plrid).health>0  
   if (plrkeySPACE)=1 and jumpaction=0 and meridinglift=0 and crouchmode=0 and jumpactionnorepeat=0 and grav#>-1
    if player(1).jumpheight>0
     jumpspeed#=speed# : jumpangle#=camera angle y(playercam) : leapedlanded=1
     camvely#=0 : camforcey#=player(1).jumpheight*(0.5+(cameradampen#/2.0))
     if physxedition=1
      jumpmotionx#=camvelx#
      jumpmotionz#=camvelz#
      gosub _phy_plr_jump
     else
      jumpmotionx#=tmotionx#
      jumpmotionz#=tmotionz#
     endif
     if playersound(plrid,10)>0
      broadcast3dplrsound(camerapositionx,camerapositiony,camerapositionz,15.0)
      set sound volume playersound(plrid,10),soundvolumes(0)
      play sound playersound(plrid,10)
     endif
     jumpaction=1
     if physxedition=1
      jumpactionnorepeat=50
     else
      jumpactionnorepeat=5
     endif
    endif
   endif
  endif
 endif
 rem X10 - 070409 - track jump action from leap to land 
 if physxedition=1
  if jumpactionnorepeat>0
   if jumpactionnorepeat>45 then dec jumpactionnorepeat
   if jumpactionnorepeat>25 and jumpactionnorepeat<=45 and grav#<0.0 then jumpactionnorepeat=25
   if jumpactionnorepeat>25 and jumpactionnorepeat<=45 then dec jumpactionnorepeat
   if jumpactionnorepeat>0 and jumpactionnorepeat<=25 and grav#>=0.0 then jumpactionnorepeat=0
   if jumpactionnorepeat>0 and jumpactionnorepeat<=25 then dec jumpactionnorepeat
   if jumpactionnorepeat=0 then jumpaction=0
  endif
 else
  if jumpactionnorepeat>0
   if jumpactionnorepeat>1 then dec jumpactionnorepeat
   if jumpactionnorepeat=1 and grav#<0 then jumpactionnorepeat=0
  endif
 endif
 if jumpaction<>0
  camvelx#=jumpmotionx# : camvelz#=jumpmotionz#
 endif
 `
 rem and apply any force here
 if waterisbelowplayer=2 or (waterisbelowplayer=1 and tnearsurfaceofwater<15)
  camvelx#=(camvelx#+camforcex#)/1.1 : camforcex#=0
  camvely#=(camvely#+camforcey#)/1.1 : camforcey#=0
  camvelz#=(camvelz#+camforcez#)/1.1 : camforcez#=0
 else
  camvelx#=camvelx#+camforcex# : camforcex#=0
  camvely#=camvely#+camforcey# : camforcey#=0
  camvelz#=camvelz#+camforcez# : camforcez#=0
 endif
 `
else
 `
 rem player has no health
 cameraspeed=0
 camvelx#=0 : camforcex#=0
 camvely#=0 : camforcey#=0
 camvelz#=0 : camforcez#=0
 movement=0
 grav#=0
 `
endif

rem Is player moving or not
player(plrid).state.moving=movement

rem Mark player position is viscolmap
gosub _physics_mark

return

`leetimestamp as DWORD
`leetimeshow as DWORD
`leetime as DWORD
`leetime1 as DWORD
`leetime2 as DWORD
`leetimec as DWORD

_physics_playeraftermove:

rem Camera in control of player one (unmark as slide may change pos)
plrid=1
gosub _physics_unmark
movement=player(plrid).state.moving

rem Collisions
colmaterialtype=-1
tgravitydefeated=0

rem Check for physicsobjects collisions (and perform physics collision sounds)
`x9 optimize ODE so not as many triggers are added to stack so
`we can speed up this bit considerably
rem x10 try again now fixed while drain
gosub _physics_sounds

rem control player interaction
if gmultiplayergame=1 then gosub _multi_plrradial

rem Special Get Out of Jail Free collision key
if inkey$()<>"K" then tkickout=0
if inkey$()="K" and tkickout=0
 if playertrailmax>0
  trailx#=playertrial(playertrailmax).x
  traily#=playertrial(playertrailmax).y
  trailz#=playertrial(playertrailmax).z
  dec playertrailmax : if playertrailmax<1 then playertrailmax=100
  if playertrial(playertrailmax).time=0
   inc playertrailmax : if playertrailmax>100 then playertrailmax=1
  else
   camerapositionx=trailx#
   camerapositiony=traily#+phyeyeheight#
   camerapositionz=trailz#
   position camera playercam,camerapositionx,camerapositiony,camerapositionz
   cx#=camera position x(playercam) : cy#=camera position y(playercam) : cz#=camera position z(playercam)
   cox#=cx# : coy#=cy# : coz#=cz#
   gosub _physics_playerborble
   meridingtransporter=0
   meridinglift=0
  endif
 endif
 tkickout=1
endif

rem Ellipse Collision with static scene
if deactivatecollision=0 and skipcol=0
 `
 rem check ellipse against movement
 ctx#=camerapositionx+(camvelx#/4.0)
 `if waterisbelowplayer=2 `V109
 if waterisbelowplayer=2 or (waterisbelowplayer=1 and tnearsurfaceofwater<15)
  cty#=camerapositiony+(camvely#/4.0)
 else
  cty#=camerapositiony
 endif
 ctz#=camerapositionz+(camvelz#/4.0)
 rem check if can rouch down from stood
 if crouchmode=1
  if static volume(ctox#,ctoy#-28,ctoz#,ctx#,(cty#-28)-15,ctz#,0.25)=1
   if physicsdebug=1 then print "willgetstyckifcrouch"
  else
   ellipsevolumesize#=phycrouchedellipsevolumesize#
   phyeyeheight#=phycrouched#
   cty#=camerapositiony-12
   ctoy#=ctoy#-12
   crouchmode=2
  endif
 endif
 rem check if can stand up from crouch
 if crouchmode=3
  if static volume(ctox#,(ctoy#-9)+5,ctoz#,ctx#,(cty#-9)+40+5,ctz#,0.25)=1
   if physicsdebug=1 then print "willhitheadifgetup"
  else
   ellipsevolumesize#=phystoodellipsevolumesize#
   phyeyeheight#=phystood#
   cty#=camerapositiony+30+5
   ctoy#=ctoy#+30+5
   crouchmode=0
  endif
 endif
 rem determine center of ellipse (crouch and stood) (need contact with floor=walksound)
 if phyeyeheight#=phystood# then ellipsecentery#=35 else ellipsecentery#=23
 `
 rem ellipse test for final player mode (stood or crouch) - only to augment ODE
 rem X10 disable static voluem check (for now)
 if physxedition=0
  if static volume(ctox#,ctoy#-ellipsecentery#,ctoz#,ctx#,cty#-ellipsecentery#,ctz#,ellipsevolumesize#)=1
   if physicsdebug=1 then print "volumecollision"
   adjx#=get static collision x()
   adjy#=get static collision y()
   adjz#=get static collision z()
   colmaterialtype=get static collision value()-1
   sctx#=ctx#
   scty#=cty#
   sctz#=ctz#
   ctx#=ctox#+adjx#
   cty#=ctoy#+adjy#
   ctz#=ctoz#+adjz#
   tstaticfloor=get static collision floor()
   if tstaticfloor=1 and grav#<0 then tgravitydefeated=1
   if jumpaction<>0 and camvely#>5.0 and cty#-scty#<0.0 then camvely#=camvely#*-1 : jumpaction=0
   if abs(ctx#-sctx#)+abs(ctz#-sctz#)>8
    rem event when collision hits something solid (not floor)
    camvelx#=ctx#-camerapositionx
    camvely#=cty#-camerapositiony
    camvelz#=ctz#-camerapositionz
    jumpmotionx#=0 : jumpmotionz#=0 : jumpaction=0
    if cameraspeed>5 then cameraspeed=5
    if camvely#>0 then camvely#=0
    rem wipe out flyforce too as hit something to stop hero
    camflyforcex#=0 : camflyforcey#=0 : camflyforcez#=0
   endif
  endif
 endif
 `
 rem If gravity defeated by player (ODE)
 thurttheplayerwhenlandhard=0
 if physxedition=1
  `
  rem PHYSX - detect when player lands and if hurts themselves
  if waterisbelowplayer=2 or (waterisbelowplayer=1 and tnearsurfaceofwater<15)
   rem no gravity when underwater
  else
   rem gravity effects
   if newlevelobjectivevoid=0
    rem player lands after a jump
    `if (grav#<-60.0 and jumpaction=0) or (grav#<-40.0 and jumpaction<>0)
    if 0
     rem deck plate sound too
     leapedlanded=1
    endif
    rem determine if fall hurt player
    `if cty#<gravlasty#-playerhurtfall
    if 0
     rem avoid hurt when using stairs
     if (abs(camvelx#)+abs(camvelz#)/2.0)<15.0
      tokayhurt=1
     else
      tokayhurt=0
     endif
     if gmultiplayergame=0
      rem cannot hurt by falling in arena game
      if tokayhurt=1
       rem level substantial different from last stood on ground
       thurttheplayerwhenlandhard=1
      endif
     endif
    endif
   endif
  endif
  `
  rem ODE variables not used
  camerastoodonphyobj=0
  tgravitydefeated=0
  `  
 else
  `
  rem ODE - detect when player lands and if hurts themselves
  if waterisbelowplayer=2 or (waterisbelowplayer=1 and tnearsurfaceofwater<15)
   rem no gravity tech when underwater
   tgravitydefeated=0
  else
   if tgravitydefeatedbyphy<>0
    rem if object entity driven, player can be moved by it
    if entityelement(tgravitydefeatedbyphye).eleprof.physics=2
     if camerastoodonphyobj=0
      lcamerastoodonphyobjmovingx#=object position x(tgravitydefeatedbyphy)
      lcamerastoodonphyobjmovingz#=object position z(tgravitydefeatedbyphy)
     endif
     camerastoodonphyobj=tgravitydefeatedbyphy
    else
     camerastoodonphyobj=0
    endif
    rem record stood on phy obj
    if jumpactionnorepeat>1
     rem when in jump mode, and touching phyobj, do not interfere with a defeat flag
    else
     tgravitydefeated=1
    endif
   else
    rem when not detect phy obj, keep record until
    if tgravitydefeated=1
     rem stood on static floor (must have walked off phy obj)
     camerastoodonphyobj=0
    endif
   endif
   if camerastoodonphyobj<>0
    if object exist(camerastoodonphyobj)=0 then camerastoodonphyobj=0
   endif
   if camerastoodonphyobj<>0
    rem V110 - 140110 - when riding on antigrav platform, need correct speed!
    `camerastoodonphyobjmovingx#=object position x(camerastoodonphyobj)-lcamerastoodonphyobjmovingx#
    `camerastoodonphyobjmovingz#=object position z(camerastoodonphyobj)-lcamerastoodonphyobjmovingz#
    rem only influence of object beneath player borble
    if object position y(camerastoodonphyobj)<object position y(physicsplayerborble)
     rem V110 - 140110 - when riding on antigrav platform, need correct speed!
     `camvelx#=camvelx#+(camerastoodonphyobjmovingx#*10)
     `camvelz#=camvelz#+(camerastoodonphyobjmovingz#*10)
     if camerastoodrelativecoordinatex#=-1 or jumpaction<>0 or movement<>0
      camerastoodrelativecoordinatex#=mex#-object position x(camerastoodonphyobj)
      camerastoodrelativecoordinatez#=mez#-object position z(camerastoodonphyobj)
     else
      rem work out drift from original stood coordinate to where me is now
      tshouldbex#=object position x(camerastoodonphyobj)+camerastoodrelativecoordinatex#
      tshouldbez#=object position z(camerastoodonphyobj)+camerastoodrelativecoordinatez#
      camvelx#=camvelx#+((tshouldbex#-mex#)*10)
      camvelz#=camvelz#+((tshouldbez#-mez#)*10)
     endif        
    endif
    rem V110 - 140110 - when riding on antigrav platform, need correct speed!
    `lcamerastoodonphyobjmovingx#=object position x(camerastoodonphyobj)
    `lcamerastoodonphyobjmovingz#=object position z(camerastoodonphyobj)
   else
    camerastoodrelativecoordinatex#=-1
   endif
  endif
  if tgravitydefeated=1
   if physicsdebug=1 then print "andgravitydefeated"
   rem a few cycles grace at start of level (avoid urg sound when retstart)
   if newlevelobjectivevoid=0
    rem player lands after a jump
    if (grav#<-60.0 and jumpaction=0) or (grav#<-40.0 and jumpaction<>0)
     rem deck plate sound too
     leapedlanded=1
    endif
    rem determine if fall hurt player
    if cty#<gravlasty#-playerhurtfall
     rem avoid hurt when using stairs
     tokayhurt=0
     if (abs(camvelx#)+abs(camvelz#)/2.0)<15.0
      tokayhurt=1
     else
      rem raycast behind plr (stairs would be there)
      tpmb#=-100.0
      tppx#=newxvalue(camerapositionx,camera angle y(playercam),tpmb#)
      tppz#=newzvalue(camerapositionz,camera angle y(playercam),tpmb#)
      tdst#=static raycast(camerapositionx,camerapositiony-phyeyeheight#,camerapositionz,tppx#,camerapositiony-phyeyeheight#,tppz#)
      if tdst#=0 then tokayhurt=1
     endif
     if gmultiplayergame=0
      rem cannot hurt by falling in arena game
      if tokayhurt=1
       rem level substantial different from last stood on ground
       tdamage=1+((abs(cty#-gravlasty#)-playerhurtfall)/5.0)
       thurttheplayerwhenlandhard=tdamage
      endif
     endif
    endif
   endif
   rem record last ground player stood on
   gravlasty#=cty#
   rem landing sound
   jumpaction=0
  else
   if movement<>0 then onladder=0
  endif
 endif
 `
 rem Trigger player hurt damage
 if thurttheplayerwhenlandhard>0
  rem player urg sound
  if playersound(plrid,11)>0
   broadcast3dplrsound(camera position x(playercam),camera position y(playercam),camera position z(playercam),10.0)
   set sound volume playersound(plrid,11),soundvolumes(0)
   play sound playersound(plrid,11)
  endif
  rem player takes damage
  tdamage=thurttheplayerwhenlandhard
  gosub _player_takedamage
  thurttheplayerwhenlandhard=0
 endif
 `
 rem Jump ends when camera starts decending
 rem X10 and build enough speed to defeat auto-deactivate of physics
 if physxedition=1
  if camvely#<0.0 then jumpaction=0
 else
  if camvely#<-25.0 then jumpaction=0
 endif
 `
 rem debug object
 if physicsdebug=1
  if object exist(98789)=0
   make object sphere 98789,20
   set object cull 98789,0
   set object wireframe 98789,1
   set object collision off 98789
  else
   position object 98789,ctx#,cty#-ellipsecentery#,ctz#
   scale object 98789,100,300*ellipsevolumesize#,100
  endif
 endif
 `
endif

rem ladder control
if onladder=1
` rem climb ladder mode
` cx#=onladderx# : cz#=onladderz#
` if movement<>0
`  grav#=camera angle x()/10.0
`  if grav#<-3.0 then grav#=-3.0
`  if grav#>3.0 then grav#=3.0
` else
`  grav#=0.0
` endif
` rem ladder grasp will kill jump action
` jumpaction=0
endif

rem new barrier code using physics force
if ctx#<25.0 then camvelx#=10.0
if ctz#>-25.0 then camvelz#=-10.0
if ctx#>(maxx*100.0)-25 then camvelx#=-10.0
if ctz#<(maxy*-100.0)+25 then camvelz#=10.0

rem Only if not ghost or fly
if gghostrunmode=0 and gcameraflymode=0
 `
 rem Camera rotation speeds
 if showgamemenu=0
  if debugviewmode=0 or (debugviewmode=1 and x10effectmenudata.tmouselook=1)
   rem X10 also uses mouse when in TAB debug X10 effecte menu 'debugviewmode'
   cammovex#=mousemovex() : cammovey#=mousemovey()
  else
   cammovex#=0 : cammovey#=0
  endif
 else
  cammovex#=0 : cammovey#=0
 endif
 if gdisablecamerasmoothing=1
  rem V109 - 100209 - new mode to skip the camera smoothing system (for min.spec PCs)
  rem and see below as well
  camrotspeed#=0.25
 else
  energyofmovement#=abs(cammovex#)+abs(cammovey#)
  t=energyofmovement#
  if t=1 then camrotspeed#=0.05
  if t=2 then camrotspeed#=0.1
  if t=3 then camrotspeed#=0.15
  if t=4 then camrotspeed#=0.2
  if t>=5 then camrotspeed#=0.25
 endif
 if plrzoomin#>0 then camrotspeed#=camrotspeed#/plrzoomin#
 `
 rem Control camera view (even when no health)
 `camangx#=camera angle x(playercam)+((cammovey#*camrotspeed#)) `smoothing code below
 `camangy#=camera angle y(playercam)+((cammovex#*camrotspeed#))
 camangx#=lastcamangx#+((cammovey#*camrotspeed#))
 camangy#=lastcamangy#+((cammovex#*camrotspeed#))
 rem FPSXCV104RC5 - zoom mode wobble based on accuracy
 if plrzoomin#<>0.0
  plrzoomaccuracyangle#=wrapvalue(plrzoomaccuracyangle#+((2+rnd(4)+(11-plrzoomin#))/10.0))
  camangx#=camangx#+cos(plrzoomaccuracyangle#*2.0)*plrzoomaccuracy#*plrzoomin#*0.008*(sin(plrzoomaccuracyangle#)*1.2)
  camangy#=camangy#+sin(plrzoomaccuracyangle#*4.0)*plrzoomaccuracy#*plrzoomin#*0.005
 endif
 camangxweight#=85*cameradampen#
 if wrapvalue(camangx#)>85 and wrapvalue(camangx#)<180 then camangx#=85.0
 if wrapvalue(camangx#)>180 and wrapvalue(camangx#)<360-camangxweight# then camangx#=camangxweight#*-1
 `
 rem used to swoosh to an angle (picking up object off-center)
 if camturntofacemode>0
  camangy#=curveangle(camturntoface#,camangy#,10.0)
  dec camturntofacemode
 endif
 `
 rem X10 - 011107 - Record last camera angles minus smoothing
 lastcamangx#=camangx# : lastcamangy#=camangy#
 `
 rem X10 - 011107 - camera smoothing lowers response time, but looks nice
 rem so only use this on a value so we can alter it based on users requirements
 if gdisablecamerasmoothing=1
  rem V109 - 100209 - new mode to skip the camera smoothing system (for min.spec PCs)
  smoothcamera#=1.0
 else
  smoothcamera#=4.0-(energyofmovement#/15.0)
  if smoothcamera#<1.0 then smoothcamera#=1.0
 endif
 camangx#=curveangle(camangx#,camera angle x(playercam),smoothcamera#)
 camangy#=curveangle(camangy#,camera angle y(playercam),smoothcamera#)
 `
 rem final camera rotation update
 rotate camera playercam,camangx#,camangy#,camera angle z(playercam)
 `
endif

rem Mark player position in viscolmap
gosub _physics_mark

rem leave a trial for any enemies to follow
trailaction=0 : trailx#=camerapositionx : traily#=camerapositiony-phyeyeheight# : trailz#=camerapositionz
gosub _player_leavetrail

rem apply a visual adjustment to camera
if player(plrid).health>0 and peeklean#<>0.0
 peekadjx#=newxvalue(0,camera angle y(playercam)+90,peeklean#)
 peekadjz#=newzvalue(0,camera angle y(playercam)+90,peeklean#)
 if static raycast(camerapositionx,camerapositiony,camerapositionz,camerapositionx+peekadjx#,camerapositiony,camerapositionz+peekadjz#)=0
  camerapositionx=camerapositionx+peekadjx#
  camerapositionz=camerapositionz+peekadjz#
 else
  peekfreeze=1
 endif
endif

rem if sharp upward velocity (20+), and not jump
if jumpaction=0
 if camvely#>10
  rem ensure it is dampened so small floor features not send player high (window/door sills,etc)
  camvely#=10.0
 endif
endif

rem if borble ever leaves camera vicinity (ODE bug) restore
if physicsplayerborble>0
 if physicsdebug=1
  print "camera"
  print "x=";camerapositionx
  print "y=";camerapositiony
  print "z=";camerapositionz
  print
 endif
 if object exist(physicsplayerborble)=1
  if physicsdebug=1
   print "borble"
   print "x=";object position x(physicsplayerborble)
   print "y=";object position y(physicsplayerborble)
   print "z=";object position z(physicsplayerborble)
   print
   print "volume"
   print "x=";ctx#
   print "y=";cty#
   print "z=";ctz#
   print
  endif
  tborbdistx#=abs(object position x(physicsplayerborble)-camerapositionx)
  tborbdisty#=abs(object position y(physicsplayerborble)-camerapositiony)
  tborbdistz#=abs(object position z(physicsplayerborble)-camerapositionz)
  tborbdist1#=sqrt((tborbdistx#*tborbdistx#)+(tborbdisty#*tborbdisty#)+(tborbdistz#*tborbdistz#))
  if physicsdebug=1
   print "borble distance=";tborbdist1#
  endif
  tborbdistx#=abs(ctx#-camerapositionx)
  tborbdisty#=abs(cty#-camerapositiony)
  tborbdistz#=abs(ctz#-camerapositionz)
  tborbdist2#=sqrt((tborbdistx#*tborbdistx#)+(tborbdisty#*tborbdisty#)+(tborbdistz#*tborbdistz#))
  if physicsdebug=1
   print "volume distance=";tborbdist2#
  endif
  if tborbdist1#>100 or tborbdist2#>100
   if physicsdebug=1
    print "Camera seperated from collision system"
   endif
  endif
 endif
endif

rem apply new velocities for future movement
if player(plrid).health>0
 rem cap these velocities to prevent borble fling away
 if camvelx#<-60 then camvelx#=-60
 if camvelx#>60 then camvelx#=60
` this prevents realistic gravity acceleration for player fall
` if camvely#<-60 then camvely#=-60
` if camvely#>60 then camvely#=60
 if camvelz#<-60 then camvelz#=-60
 if camvelz#>60 then camvelz#=60
 if physxedition=1
  gosub _phy_plr_move
 else
  ode set linear velocity physicsplayerborble,camvelx#,camvely#,camvelz#
  ode set angular velocity physicsplayerborble,0,0,0
 endif
else
 rem ensures player does not slide away after died
 if physxedition=1
  gosub _phy_plr_stop
 else
  ode set linear velocity physicsplayerborble,0,0,0
  ode set angular velocity physicsplayerborble,0,0,0
 endif
endif

rem calculate some simply shake movement
camshakey#=0.0
if abs(camshake#)<>0
 camshakedir=1-camshakedir
 if camshakedir=0
  camshakey#=camshakey#+camshake#
 else
  camshakey#=camshakey#-camshake#
 endif
 if abs(camshake#)<1.0
  camshake#=0.0
 else
  camshake#=camshake#*0.9
 endif
endif

rem arena-eyes adjustment
if gmultiplayergame=1
 if crouchmode=0
  arenaadjustd#=-5.0
 else
  arenaadjustd#=2.0
 endif
else
 arenaadjustd#=0
endif
if movement<>0
 rem X10 - V109 - 180309 - tame head bobble with frame rate indie
 camerawobblespeed=24.0*timeelapsed#
 camerawobble#=wrapvalue(camerawobble#+camerawobblespeed)
 if (plrkeySHIFT)=1
  arenaadjust#=arenaadjustd#+(cos(camerawobble#)*0.50)
 else
  arenaadjust#=arenaadjustd#+(cos(camerawobble#)*0.25)
 endif
else
 arenaadjust#=curvevalue(arenaadjustd#,arenaadjust#,5.0)
 camerawobble#=0.0
endif

remstart
rem finally update camera with smoothing (cty# is absolute staticvolume camypos)
finalcamy#=curvevalue(camerapositiony,camera position y(playercam),2.0)
if finalcamy#>cty#-8 then finalcamy#=cty#-8
if playersystemdisabled=0
 `
 rem X10 - 280907 - basic ghost run camera
 if gghostrunmode=1 or gcameraflymode=1
  `
  rem camera fly mode or ghost mode
  if gcameraflymode=1
   `
   rem entire camera fly mode logic here   
   if ghostrunstage=0
    rem start off at player start marker position
    ghostrunx#=camerapositionx
    ghostruny#=camerapositiony
    ghostrunz#=camerapositionz
    ghostrunrx#=camangx#
    ghostrunry#=camangy#
    ghostrunrz#=camera angle z(playercam)
    ghostrunstage=1
    playercam=4 : rem change playercam to the reflection camera (so it does not move)
   endif
   `
   rem manual control of ghost using camera fly controls
   cammovex#=0 : cammovey#=0
   if showgamemenu=0
    if debugviewmode=0 or (debugviewmode=1 and x10effectmenudata.tmouselook=1)
     cammovex#=mousemovex() : cammovey#=mousemovey()
    endif
   endif
   camrotspeed#=1.0
   ghostrunrx#=camera angle x(5)+((cammovey#*camrotspeed#))
   ghostrunry#=camera angle y(5)+((cammovex#*camrotspeed#))
   moveroty#=ghostrunry#
   cameraspeed=0
   if (plrkeyW)=1
    cameraspeed=2
    if (plrkeyA)=1 then dec moveroty#,35
    if (plrkeyD)=1 then inc moveroty#,35
   else
    if (plrkeyS)=1
     cameraspeed=2
     if (plrkeyA)=0 and (plrkeyD)=0 then inc moveroty#,180
     if (plrkeyA)=1 then dec moveroty#,145
     if (plrkeyD)=1 then inc moveroty#,145
    else
     if (plrkeyA)=1 then dec moveroty#,90 : cameraspeed=2
     if (plrkeyD)=1 then inc moveroty#,90 : cameraspeed=2
    endif
   endif
   camvelx#=newxvalue(0,moveroty#,cameraspeed)
   if (plrkeyW)=1
    camvely#=0-(sin(ghostrunrx#)*cameraspeed)
   else
    if (plrkeyS)=1
     camvely#=sin(ghostrunrx#)*cameraspeed
    else
     camvely#=0
    endif
   endif
   camvelz#=newzvalue(0,moveroty#,cameraspeed)
   ghostrunx#=ghostrunx#+camvelx# : camvelx#=0
   ghostruny#=ghostruny#+camvely# : camvely#=0
   ghostrunz#=ghostrunz#+camvelz# : camvelz#=0
   `
   rem update each cycle
   rotate camera 5,ghostrunrx#,ghostrunry#,ghostrunrz#
   position camera 5,ghostrunx#,ghostruny#,ghostrunz#
   `
  else
   `
   rem entire ghost run logic here (for simplicity)
   if ghostrunstage=0
    rem ghost run starts
    ghostrunx#=camerapositionx
    ghostruny#=camerapositiony
    ghostrunz#=camerapositionz
    ghostrunrx#=camangx#
    ghostrunry#=camangy#
    ghostrunrz#=camera angle z(playercam)
    ghostrunstage=1
   else
    if ghostrunstage=1
     rem ghost run control - get next nearest ghost run marker
     ghostrunmarkerindex=0
     tclosestmarker#=999999
     for e=1 to entityelementlist
      if entityelement(e).active=1
       entid=entityelement(e).bankindex
       if entityprofile(entid).ismarker<>0
        if lower$(entityelement(e).eleprof.name$)="ghost run marker"
         tgrx#=entityelement(e).x-ghostrunx#
         tgry#=(entityelement(e).y+65)-ghostruny#
         tgrz#=entityelement(e).z-ghostrunz#
         tgrdist#=sqrt(abs(tgrx#*tgrx#)+abs(tgry#*tgry#)+abs(tgrz#*tgrz#))
         if tgrdist#<tclosestmarker#
          tclosestmarker#=tgrdist#
          ghostrunmarkerindex=e
         endif
        endif
       endif
      endif
     next e
     if ghostrunmarkerindex>0
      rem work out camera rotation speed based on now and then
      tgrx#=entityelement(ghostrunmarkerindex).x-ghostrunx#
      tgry#=(entityelement(ghostrunmarkerindex).y+65)-ghostruny#
      tgrz#=entityelement(ghostrunmarkerindex).z-ghostrunz#
      tgrdist#=sqrt(abs(tgrx#*tgrx#)+abs(tgry#*tgry#)+abs(tgrz#*tgrz#))
      trotnow#=wrapvalue(camera angle y(playercam))
      trotdest#=wrapvalue(entityelement(ghostrunmarkerindex).ry)
      trotdifference#=trotdest#-trotnow#
      if trotdifference#>180 then trotdifference#=trotdifference#-360
      if trotdifference#<-180 then trotdifference#=trotdifference#+360
      trotspeedincremental#=trotdifference#/tgrdist#
      rem set for movement to new marker
      entityelement(ghostrunmarkerindex).active=0
      ghostrunstage=2
     else
      rem no more markers - exit this level as a winner
      if triggergameexitfade=0
       triggergameexitfade=1 : levelwon=1
      endif
      camerapositionx=ghostrunx#
      camerapositiony=ghostruny#
      camerapositionz=ghostrunz#
      ghostrunstage=0
     endif
    endif
    if ghostrunstage=2
     rem ghost run control - move to that marker
     tgrx#=entityelement(ghostrunmarkerindex).x-ghostrunx#
     tgry#=(entityelement(ghostrunmarkerindex).y+65)-ghostruny#
     tgrz#=entityelement(ghostrunmarkerindex).z-ghostrunz#
     tgrdist#=sqrt(abs(tgrx#*tgrx#)+abs(tgry#*tgry#)+abs(tgrz#*tgrz#))
     tgrx#=tgrx#/tgrdist#
     tgry#=tgry#/tgrdist#
     tgrz#=tgrz#/tgrdist#
     ghostrunx#=curvevalue(ghostrunx#+(tgrx#*timebasepercycle#*15),ghostrunx#,5.0)
     ghostruny#=curvevalue(ghostruny#+(tgry#*timebasepercycle#*15),ghostruny#,5.0)
     ghostrunz#=curvevalue(ghostrunz#+(tgrz#*timebasepercycle#*15),ghostrunz#,5.0)
     ghostrunry#=curveangle(entityelement(ghostrunmarkerindex).ry-(trotspeedincremental#*tgrdist#),ghostrunry#,3.0)
     if tgrdist#<25
      ghostrunstage=1
     endif
    endif
   endif
   rem finally update player cam with new ghost run position and angle
   if gghostrunmode=1
    rem if still ghost run mode (not cancelled)
    rotate camera playercam,ghostrunrx#,ghostrunry#,ghostrunrz#
    position camera playercam,ghostrunx#,ghostruny#,ghostrunz#
   endif
   `
  endif
  `
 else
  `
  rem regular player camera
  position camera playercam,curvevalue(camerapositionx,camera position x(playercam),2.0),finalcamy#+arenaadjust#+(camshakey#/10.0),curvevalue(camerapositionz,camera position z(playercam),2.0)
  `
 endif
  
endif

rem update listener
gosub _physics_listener

return
remend

rem finally update camera with smoothing (cty# is absolute staticvolume camypos)
finalcamy#=curvevalue(camerapositiony,camera position y(playercam),2.0)
if finalcamy#>cty#-8 then finalcamy#=cty#-8
if playersystemdisabled=0
 `
 rem X10 - 280907 - basic ghost run camera
 if gghostrunmode=1 or gcameraflymode=1
  `
  rem camera fly mode or ghost mode
  if gcameraflymode=1
   `
   rem entire camera fly mode logic here   
   if ghostrunstage=0
    rem start off at player start marker position
    ghostrunx#=camerapositionx
    ghostruny#=camerapositiony
    ghostrunz#=camerapositionz
    ghostrunrx#=camangx#
    ghostrunry#=camangy#
    ghostrunrz#=camera angle z(playercam)
    ghostrunstage=1
    playercam=4 : rem change playercam to the reflection camera (so it does not move)
   endif
   `
   rem manual control of ghost using camera fly controls
   cammovex#=0 : cammovey#=0
   if showgamemenu=0
    if debugviewmode=0 or (debugviewmode=1 and x10effectmenudata.tmouselook=1)
     cammovex#=mousemovex() : cammovey#=mousemovey()
    endif
   endif
   camrotspeed#=1.0
   ghostrunrx#=camera angle x(5)+((cammovey#*camrotspeed#))
   ghostrunry#=camera angle y(5)+((cammovex#*camrotspeed#))
   moveroty#=ghostrunry#
   cameraspeed=0
   if (plrkeyW)=1
    cameraspeed=2
    if (plrkeyA)=1 then dec moveroty#,35
    if (plrkeyD)=1 then inc moveroty#,35
   else
    if (plrkeyS)=1
     cameraspeed=2
     if (plrkeyA)=0 and (plrkeyD)=0 then inc moveroty#,180
     if (plrkeyA)=1 then dec moveroty#,145
     if (plrkeyD)=1 then inc moveroty#,145
    else
     if (plrkeyA)=1 then dec moveroty#,90 : cameraspeed=2
     if (plrkeyD)=1 then inc moveroty#,90 : cameraspeed=2
    endif
   endif
   camvelx#=newxvalue(0,moveroty#,cameraspeed)
   if (plrkeyW)=1
    camvely#=0-(sin(ghostrunrx#)*cameraspeed)
   else
    if (plrkeyS)=1
     camvely#=sin(ghostrunrx#)*cameraspeed
    else
     camvely#=0
    endif
   endif
   camvelz#=newzvalue(0,moveroty#,cameraspeed)
   ghostrunx#=ghostrunx#+camvelx# : camvelx#=0
   ghostruny#=ghostruny#+camvely# : camvely#=0
   ghostrunz#=ghostrunz#+camvelz# : camvelz#=0
   `
   rem update each cycle
   rotate camera 5,ghostrunrx#,ghostrunry#,ghostrunrz#
   position camera 5,ghostrunx#,ghostruny#,ghostrunz#
   `
  else
   `
   rem entire ghost run logic here (for simplicity)
   if ghostrunstage=0
    rem ghost run starts
    ghostrunx#=camerapositionx
    ghostruny#=camerapositiony
    ghostrunz#=camerapositionz
    ghostrunrx#=camangx#
    ghostrunry#=camangy#
    ghostrunrz#=camera angle z(playercam)
    ghostrunstage=1
   else
    if ghostrunstage=1
     rem ghost run control - get next nearest ghost run marker
     ghostrunmarkerindex=0
     tclosestmarker#=999999
     for e=1 to entityelementlist
      if entityelement(e).active=1
       entid=entityelement(e).bankindex
       if entityprofile(entid).ismarker<>0
        if lower$(entityelement(e).eleprof.name$)="ghost run marker"
         tgrx#=entityelement(e).x-ghostrunx#
         tgry#=(entityelement(e).y+65)-ghostruny#
         tgrz#=entityelement(e).z-ghostrunz#
         tgrdist#=sqrt(abs(tgrx#*tgrx#)+abs(tgry#*tgry#)+abs(tgrz#*tgrz#))
         if tgrdist#<tclosestmarker#
          tclosestmarker#=tgrdist#
          ghostrunmarkerindex=e
         endif
        endif
       endif
      endif
     next e
     if ghostrunmarkerindex>0
      rem work out camera rotation speed based on now and then
      tgrx#=entityelement(ghostrunmarkerindex).x-ghostrunx#
      tgry#=(entityelement(ghostrunmarkerindex).y+65)-ghostruny#
      tgrz#=entityelement(ghostrunmarkerindex).z-ghostrunz#
      tgrdist#=sqrt(abs(tgrx#*tgrx#)+abs(tgry#*tgry#)+abs(tgrz#*tgrz#))
      trotnow#=wrapvalue(camera angle y(playercam))
      trotdest#=wrapvalue(entityelement(ghostrunmarkerindex).ry)
      trotdifference#=trotdest#-trotnow#
      if trotdifference#>180 then trotdifference#=trotdifference#-360
      if trotdifference#<-180 then trotdifference#=trotdifference#+360
      trotspeedincremental#=trotdifference#/tgrdist#
      rem set for movement to new marker
      entityelement(ghostrunmarkerindex).active=0
      ghostrunstage=2
     else
      rem no more markers - exit this level as a winner
      if triggergameexitfade=0
       triggergameexitfade=1 : levelwon=1
      endif
      camerapositionx=ghostrunx#
      camerapositiony=ghostruny#
      camerapositionz=ghostrunz#
      ghostrunstage=0
     endif
    endif
    if ghostrunstage=2
     rem ghost run control - move to that marker
     tgrx#=entityelement(ghostrunmarkerindex).x-ghostrunx#
     tgry#=(entityelement(ghostrunmarkerindex).y+65)-ghostruny#
     tgrz#=entityelement(ghostrunmarkerindex).z-ghostrunz#
     tgrdist#=sqrt(abs(tgrx#*tgrx#)+abs(tgry#*tgry#)+abs(tgrz#*tgrz#))
     tgrx#=tgrx#/tgrdist#
     tgry#=tgry#/tgrdist#
     tgrz#=tgrz#/tgrdist#
     ghostrunx#=curvevalue(ghostrunx#+(tgrx#*timebasepercycle#*15),ghostrunx#,5.0)
     ghostruny#=curvevalue(ghostruny#+(tgry#*timebasepercycle#*15),ghostruny#,5.0)
     ghostrunz#=curvevalue(ghostrunz#+(tgrz#*timebasepercycle#*15),ghostrunz#,5.0)
     ghostrunry#=curveangle(entityelement(ghostrunmarkerindex).ry-(trotspeedincremental#*tgrdist#),ghostrunry#,3.0)
     if tgrdist#<25
      ghostrunstage=1
     endif
    endif
   endif
   rem finally update player cam with new ghost run position and angle
   if gghostrunmode=1
    rem if still ghost run mode (not cancelled)
    rotate camera playercam,ghostrunrx#,ghostrunry#,ghostrunrz#
    position camera playercam,ghostrunx#,ghostruny#,ghostrunz#
   endif
   `
  endif
  `
 else
  `
  rem regular player camera
  position camera playercam,curvevalue(camerapositionx,camera position x(playercam),2.0),finalcamy#+arenaadjust#+(camshakey#/10.0),curvevalue(camerapositionz,camera position z(playercam),2.0)
  `
 endif
 `
endif

rem update listener
gosub _physics_listener

return

_physics_listener:
 `
 rem handle player with affecting listener properties (full CPU intense)
 if 0
  position listener camera position x(playercam)/10.0,camera position y(playercam)/10.0,camera position z(playercam)/10.0
  rotate listener 0,camera angle y(playercam),0
 else
  rem quick approx. of listener position (CPU friendly)
  roughx=camera position x(playercam)/10.0 : roughx=(roughx/5)*5
  roughy=camera position y(playercam)/10.0 : roughy=(roughy/5)*5
  roughz=camera position z(playercam)/10.0 : roughz=(roughz/5)*5
  if roughx<>lastroughx or roughy<>lastroughy or roughz<>lastroughz
   lastroughx=roughx : lastroughy=roughy : lastroughz=roughz
   position listener roughx,roughy,roughz
  endif
  `rotate listener 0,camera angle y(0),0  `want my rotspeed back!
  roughaa=camera angle y(playercam)/45.0
  if roughaa<>lastroughaa
   rotate listener 0,roughaa*45,0
   lastroughaa=roughaa
  endif
 endif
 `
return

_physics_playerpickup:

rem Track which object closest
tclosestpickable=0
if tclosestpickable=0
 bestdst#=99999.9 : bestay#=360 : beste=0
 for e=1 to entityelementmax
  if entityelement(e).eleprof.physics=1 and entityelement(e).active=1
   tobj=entityelement(e).obj
   if tobj>0
    if object exist(tobj)=1
     tdx#=object position x(tobj)-camerapositionx
     `V110 - 080110 - shaded entities have HUGE sizey, so remove this factor!
     `tdy#=(object position y(tobj)+(object size(tobj)/2))-camerapositiony
     profileobj=entityelement(e).profileobj
     tdy#=(object position y(tobj)+(object size(profileobj)/2))-camerapositiony
     tdz#=object position z(tobj)-camerapositionz
     td#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
     tda#=wrapvalue(atanfull(tdx#,tdz#)-camera angle y(playercam))
     tday#=wrapvalue(atanfull(tdy#,td#)+camera angle x(playercam))
     if tda#>180 then tda#=360-tda#
     if tday#>180 then tday#=360-tday#
     if tda#<15 and tday#<70
      if td#<camerareachmax#
       if entityelement(e).eleprof.phyweight<cameracarryweight#
        if tday#<bestay#
         bestdst#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))
         `V110 - 080110 - shaded entities have HUGE sizey, so remove this factor!
         `minsize#=25.0+(object size(tobj)/2)
         profileobj=entityelement(e).profileobj
         minsize#=25.0+(object size(profileobj)/2)
         if bestdst#<minsize# then bestdst#=minsize#
         bestay#=tday# : beste=e : bestang#=atanfull(tdx#,tdz#)
        endif
       endif
      endif
     endif
    endif
   endif
  endif
  print
 next e
 if beste>0
  tclosestpickable=beste
 endif
endif

rem PLR pickup/drop/throw
if camerapickup=1
 if keystate(20)=1 or mouseclick()=2
  if camerapickupkeyrelease=0
   camerapickupkeyrelease=1
   if camerapicked=0
    if tclosestpickable>0
     `
     rem if object being stood on
     bendarm#=0 : armretract#=0
     if camerastoodonphyobj=entityelement(beste).obj
      if physxedition=1
       rem PHYSX - cannot move or pickup object stood on
      else
       rem try to push object away - can eventually pick it up
       thx#=newxvalue(0,camera angle y(playercam),10.0)
       thy#=ode get body linear velocity y(entityelement(beste).obj)
       thz#=newzvalue(0,camera angle y(playercam),10.0)
       ode set linear velocity entityelement(beste).obj,thx#,thy#,thz#
       rem this kicks the object forward to grab it again
       camerapickupkeyrelease=0
       rem realise player might fall - use gravity again
       physuspendgravity=0 : camforcey#=5.0
      endif
     else
      rem if not, pick up the object
      camerareach#=bestdst#
      camturntofacemode=5 : camturntoface#=bestang#
      camerapickedangle#=camturntoface#
      camerapickede=beste : camerapicked=entityelement(camerapickede).obj
      profileobj=entityelement(camerapickede).profileobj
      camerapickedsize=object size(profileobj)
      if cameradampenactive=1
       rem if player must slow down when carrying, dampen is the factor
       cameradampen#=cameracarryweight#/entityelement(camerapickede).eleprof.phyweight
       if cameradampen#<0.1 then cameradampen#=0.1
       if cameradampen#>1.0 then cameradampen#=1.0
      endif
      rem put weapon away
      if gunid<>0 then gunmode=31 : gunselectionafterhide=0
      if physxedition=1
       gosub _phy_plr_pickup
      else
       rem ODE - prepare object for pickup
       ode set body rotation camerapicked,-1,-1,-1 : rem special hack to reset GRAB rotation matrix feature
       ode set body rotation camerapicked,0,0,0
       rem object reduces mess so not pushing other objects around (inc player)
       ode set body mass camerapicked,entityelement(camerapickede).eleprof.phyweight/10.0
       rem player takes on mass of object
       ode set body mass physicsplayerborble,physicsplayerweight#+entityelement(camerapickede).eleprof.phyweight
      endif
      rem ensure new shadow depth created for object that needs to cast 75.depth area
      shadowobj(camerapicked)=2
     endif
     `
    endif
   else
    camerapickeddrop=1
   endif
  endif
 else
  camerapickupkeyrelease=0
 endif
endif
rem if anything hides it, drop it
if camerapicked>0
 if object visible(camerapicked)=0
  camerapickedthrown=0
  cameradampen#=1.0
  cameraholding=0
  camerapicked=0
 endif
endif
if camerapicked>0
 rem work out difference between actual and ideal position
 tdx#=holdx#-object position x(camerapicked)
 tdy#=(holdy#-object position y(camerapicked))-0.75
 tdz#=holdz#-object position z(camerapicked)
 tdd1#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
 rem and work out movement of item by mouse
 tdx#=abs(holdx#-lastholdx#)
 tdy#=abs(holdy#-lastholdy#)
 tdz#=abs(holdz#-lastholdz#)
 tdd2#=sqrt((tdx#*tdx#)+(tdy#*tdy#)+(tdz#*tdz#))
 tmv#=curvevalue(tdd2#,tmv#,10.0)
 if cameraholding=1
  rem if confirmed as carrying
  tdx1#=holdx#-camera position x(playercam)
  tdy1#=holdy#-camera position y(playercam)
  tdz1#=holdz#-camera position z(playercam)
  tdx2#=object position x(camerapicked)-camera position x(playercam)
  tdy2#=object position y(camerapicked)-camera position y(playercam)
  tdz2#=object position z(camerapicked)-camera position z(playercam)
  rem work out difference in angles
  tbendarm1#=atanfull(tdx1#,tdz1#)
  tbendarm#=(atanfull(tdx2#,tdz2#)-tbendarm1#)
  if tdd1#>=2.0
   rem bend arm if resistance between actual and ideal
   if tmv#<1.0 then bendarm#=bendarm#+tbendarm#
   rem retract arm if stress greater than retraction value
   if tdd1#>armretract# then armretract#=tdd1#
  endif
  rem only once held, see if head inside item
  `V110 - 080110 - shaded entities have HUGE sizey, so remove this factor!
  `tamountinside#=object size(camerapicked)-sqrt(abs(tdx2#*tdx2#)+abs(tdy2#*tdy2#)+abs(tdz2#*tdz2#))
  tamountinside#=camerapickedsize-sqrt(abs(tdx2#*tdx2#)+abs(tdy2#*tdy2#)+abs(tdz2#*tdz2#))
  if tamountinside#>0
   if tamountinside#>5 then tamountinside#=5
   if bendarm#<0.0
    bendarm#=bendarm#-(tamountinside#*2)
   else
    bendarm#=bendarm#+(tamountinside#*2)
   endif
  endif
 else
  rem confirm carrying?
  if tdd1#<8.0 then cameraholding=1
 endif
 rem retract arm if carry item into wall/obstacle
 bendreduce#=50.0
 if bendarm#<0 and cammovex#<0 then bendreduce#=50.0+(cammovex#*3)
 if bendarm#>0 and cammovex#>0 then bendreduce#=50.0-(cammovex#*3)
 if bendreduce#<1.0 then bendreduce#=1.0
 bendarm#=curvevalue(0,bendarm#,bendreduce#)
 armretract#=curvevalue(0,armretract#,50.0)
 rem carry
 if physxedition=1
  gosub _phy_plr_carry
 else
  holdangley#=camera angle y(playercam)+bendarm#
  lastholdx#=holdx# : lastholdy#=holdy# : lastholdz#=holdz#
  holdx#=newxvalue(camerapositionx,holdangley#,(camerareach#+camerareachatrun#)-armretract#)
  `holdy#=newxvalue(camerapositiony-(object size(camerapicked)/3.0),0-camera angle x(playercam),(camerareach#+camerareachatrun#)-armretract#)-((entityelement(camerapickede).eleprof.phyweight/100.0)*(1.0-cameradampen#))
  holdy#=newxvalue(camerapositiony-(camerapickedsize/3.0),0-camera angle x(playercam),(camerareach#+camerareachatrun#)-armretract#)-((entityelement(camerapickede).eleprof.phyweight/100.0)*(1.0-cameradampen#))
  holdz#=newzvalue(camerapositionz,holdangley#,(camerareach#+camerareachatrun#)-armretract#)
  tangle#=wrapvalue(camera angle y(playercam)-camerapickedangle#)
  ode set body rotation camerapicked,0,tangle#,0
  bendspeed#=4.0
  tholdforcex#=(holdx#-object position x(camerapicked))*bendspeed#
  tholdforcey#=(holdy#-object position y(camerapicked))*bendspeed#
  tholdforcez#=(holdz#-object position z(camerapicked))*bendspeed#
  rem if arm is bend to far, drop item with zero velocity
  if abs(bendarm#)>50 then camerapickeddrop=1 : tholdforcex#=0 : tholdforcey#=0 : tholdforcez#=0
  ode set linear velocity camerapicked,tholdforcex#,tholdforcey#,tholdforcez#
 endif
 rem set shadow on carried object
 `V110 - 080110 - shaded entities have HUGE sizey, so remove this factor!
 `entityelement(camerapickede).floorposy=camerapositiony-(object size(camerapicked)*3)
 `entityelement(camerapickede).floorposy=camerapositiony-(object size(camerapicked)*3)
 entityelement(camerapickede).floorposy=camerapositiony-(camerapickedsize*3)
 entityelement(camerapickede).floorposy=camerapositiony-(camerapickedsize*3)
 rem throw
 if mouseclick()=1 then camerapickeddrop=1 : camerapickedthrown=1
 rem drop
 if camerapickeddrop=1
  rem restore object and pickup states
  camerapickeddrop=0
  if camerapickedthrown=1
   rem calc throw distance, elevation and final velocity
   throwdistance#=(entityelement(camerapickede).eleprof.phyweight/1000.0)
   rem a limit so small objects do not leave scene
   if throwdistance#<2.0 then throwdistance#=2.0
   tthrowheight#=((camerathrowelev#+sin(camera angle x(playercam))*-100)/throwdistance#)
   throwdistance#=camerathrow#/throwdistance#
   taddx#=camvelx# : taddy#=camvely# : taddz#=camvelz#
   rem X10 control force with restrictor
   tdx#=taddx#+sin(camera angle y(playercam))*throwdistance#
   tdy#=taddy#+tthrowheight#
   tdz#=taddz#+cos(camera angle y(playercam))*throwdistance#
   gosub _physics_limitforce
   if physxedition=1
    gosub _phy_plr_dropvelocity
   else
    ode set linear velocity camerapicked,tdx#,tdy#,tdz#
    if entityelement(camerapickede).eleprof.rotatethrow<>0
     trotate#=entityelement(camerapickede).eleprof.rotatethrow
     ode set angular velocity camerapicked, ((rnd(1)*2.0)-1.0)*trotate#, 0, ((rnd(1)*2.0)-1.0)*trotate#
    endif
   endif
   rem reset throw
   camerapickedthrown=0
  endif
  if physxedition=1
   gosub _phy_plr_dropmass
  else
   rem restore object max
   ode set body mass camerapicked,entityelement(camerapickede).eleprof.phyweight
   rem player restores mass
   ode set body mass physicsplayerborble,physicsplayerweight#
  endif
  rem reset final values for camera pickup
  cameradampen#=1.0
  cameraholding=0
  camerapicked=0
 endif
endif

return

_physics_sounds:
 `
 rem Collision with objects causes borble to change player position
 tgravitydefeatedbyphy=0
 physicscollisionmessage=1
 while physicscollisionmessage=1
  `
  rem get any colliison message
  if physxedition=1
   gosub _phy_getcollisionmessage
  else
   physicscollisionmessage=ODE COLLISION MESSAGE EXISTS()
   if physicscollisionmessage=1
    ODE COLLISION GET MESSAGE
    phya=ODE GET OBJECT A() : phyb=ODE GET OBJECT B()
   endif
  endif
  if physicscollisionmessage<>0
  `
  rem ensure exists (could have been deleted since collisions)
  if phya>0
   if object exist(phya)=0 then phya=0
  endif
  if phyb>0
   if object exist(phyb)=0 then phyb=0
  endif
  `
  if phya>0
   rem X10 keep physics objects alive if they are involved in any contact
   if phyobjelenudged(phya)>0
    phyobjelenudged(phya)=phyobjelenudged(phya)-1
    if physxedition=1
     gosub _phy_nudgeentity
    else
     ode set active phya,1
    endif
   endif
  endif
  if phyb>0
   rem X10 keep physics objects alive if they are involved in any contact
   if phyobjelenudged(phyb)>0
    phyobjelenudged(phyb)=phyobjelenudged(phyb)-1
    if physxedition=1
     gosub _phy_nudgeentity
    else
     ode set active phyb,1
    endif
   endif
  endif
  `
  rem player phyobject stood on another phy object
  if physxedition=1
   rem PHYSX - handles collision with stood-on entities automatically
  else
   tdownward#=0.0 : ttouchedobj=0 : toverallveldiff#=0
   if (phya=physicsplayerborble and phyb<>0) then tdownward#=ODE GET OBJECT A VELOCITY Y() : ttouchedobj=phyb : toverallveldiff#=abs(ODE GET OBJECT B VELOCITY X())+abs(ODE GET OBJECT B VELOCITY Y())+abs(ODE GET OBJECT B VELOCITY Z())
   if (phyb=physicsplayerborble and phya<>0) then tdownward#=ODE GET OBJECT B VELOCITY Y() : ttouchedobj=phya : toverallveldiff#=abs(ODE GET OBJECT A VELOCITY X())+abs(ODE GET OBJECT A VELOCITY Y())+abs(ODE GET OBJECT A VELOCITY Z())
   if ttouchedobj<>0 and ttouchedobj=camerapicked then lastttouchede=ttouchede
   if ttouchedobj<>0 and ttouchedobj<>camerapicked
    ttouchede=phyobjele(ttouchedobj)
    if ttouchede>0
     entid=entityelement(ttouchede).bankindex
     colmaterialtype=entityprofile(entid).materialindex-1
     if tdownward#<2.0
      rem player landed on physics object, so register this and use gravity again
      tgravitydefeatedbyphy=ttouchedobj
      tgravitydefeatedbyphye=ttouchede
      physuspendgravity=0
     endif
     ttspeedatwhichurt#=120.0
     if toverallveldiff#>ttspeedatwhichurt#
      if ttouchede<>lastttouchede
       rem player damage if entity moving at force (uses phyforcedamage)
       tdamage=((toverallveldiff#-ttspeedatwhichurt#)/10.0) : if tdamage<1 then tdamage=1
       magnifydamage#=entityelement(ttouchede).eleprof.phyforcedamage/100.0
       tdamage=tdamage*magnifydamage# : gosub _player_takedamage
       lastttouchede=ttouchede
      endif
     else
      rem object not hitting player any more
      if lastttouchede=ttouchede
       lastttouchede=0
      endif
     endif
    endif
   endif
  endif
  `
  rem sounds processd here too
  bangobj=0
  bangcontact=0
  phyvelocity#=0
  phytotalvelocity#=0
  phyhorizontalscrape=0
  if phya<>0
   bangobj=phya : bangotherobj=phyb
   if physxedition=1
    gosub _phy_getvelocitya
   else
    phyvelocity#=abs(ODE GET OBJECT A VELOCITY X())+abs(ODE GET OBJECT A VELOCITY Y()/4)+abs(ODE GET OBJECT A VELOCITY Z())
    phyvelocity#=phyvelocity#+abs(ODE GET OBJECT A ANGULAR VELOCITY X())+abs(ODE GET OBJECT A ANGULAR VELOCITY Y())+abs(ODE GET OBJECT A ANGULAR VELOCITY Z())
    if bangobj<>physicsplayerborble
     bangcontact=ODE GET OBJECT A CONTACT()
     if bangcontact<>0
      phyfloorstop#=ODE GET OBJECT A VELOCITY Y()
      if phylastfloorstop#(bangobj)<1 and phyfloorstop#>-1
       phyhorizontalscrape=1
      endif
      phylastfloorstop#(bangobj)=phyfloorstop#
     endif
    endif
   endif
   phyvelocitya#=phyvelocity#
   phytotalvelocity#=phytotalvelocity#+phyvelocity#
  else
   phyvelocitya#=0
  endif
  if phyb<>0
   bangobj=phyb : bangotherobj=phya
   if physxedition=1
    gosub _phy_getvelocityb
   else
    phyvelocity#=abs(ODE GET OBJECT B VELOCITY X())+abs(ODE GET OBJECT B VELOCITY Y()/4)+abs(ODE GET OBJECT B VELOCITY Z())
    phyvelocity#=phyvelocity#+abs(ODE GET OBJECT B ANGULAR VELOCITY X())+abs(ODE GET OBJECT B ANGULAR VELOCITY Y())+abs(ODE GET OBJECT B ANGULAR VELOCITY Z())
    if bangobj<>physicsplayerborble
     bangcontact=ODE GET OBJECT B CONTACT()
     if bangcontact<>0
      phyfloorstop#=ODE GET OBJECT B VELOCITY Y()
      if phylastfloorstop#(bangobj)<1 and phyfloorstop#>-1
       phyhorizontalscrape=1
      endif
      phylastfloorstop#(bangobj)=phyfloorstop#
     endif
    endif
   endif
   phyvelocityb#=phyvelocity#
   phytotalvelocity#=phytotalvelocity#+phyvelocity#
  else
   phyvelocityb#=0
  endif
  if bangobj<>0 and bangobj<>physicsplayerborble and bangobj<>camerapicked
   rem impact calcs
   phyimpact#=abs(phyvelocity#-phyobjvelocity#(bangobj))
   phyimpactstop#=phyobjvelocity#(bangobj)-phyvelocity#
   phyobjvelocity#(bangobj)=phyvelocity#
   rem deal with damage of colliding objects
   phymagnitude#=0
   rem ensure player is not a damaging physics object (as stealth may require sliding along windows)
   e1=0 : e1m#=0
   if bangobj>0 and bangobj<>physicsplayerborble
    e1=phyobjele(bangobj)
    if e1<0 then e1=0
    if e>0 then e1m#=entityelement(e1).health*5
   endif
   e2=0 : e2m#=0
   if bangotherobj>0 and bangotherobj<>physicsplayerborble
    e2=phyobjele(bangotherobj)
    if e2<0 then e2=0
    if e>0 then e2m#=entityelement(e2).health*5
   endif
   rem or very weak objects that will break under duress (duress caused by size and speed of fragile object)
   if e1m#>20 then e1m#=20
   if e2m#>20 then e2m#=20
   if bangcontact=1
    if phyvelocitya#>e1m# and e1>0 and entityelement(e1).health<5 then phymagnitude#=11.0+(phyimpactstop#/4.0)
    if phyvelocityb#>e2m# and e2>0 and entityelement(e2).health<5 then phymagnitude#=11.0+(phyimpactstop#/4.0)
   endif
   rem collision with raised velocity
   if phytotalvelocity#>20.0
    if phya<>0 and phyb<>0
     if bangobj=physicsplayerborble or bangotherobj=physicsplayerborble
      rem if window strength 1-4, player CAN smash it through by running into it
      if e1>0 and entityelement(e1).health>=5 then e1=0
      if e2>0 and entityelement(e2).health>=5 then e2=0
     endif
     rem only deal damage to immobile objects (as movable ones can get out the way before damage)
     rem FPSCV104RC7 - moving entities CAN cause damage if damage force high enough
     if e1>0
      magnifydamage#=entityelement(e1).eleprof.phyforcedamage/12.0
      phymagnitude#=magnifydamage#
     endif
     if e2>0
      magnifydamage#=entityelement(e2).eleprof.phyforcedamage/12.0
      if magnifydamage#>phymagnitude#
       phymagnitude#=magnifydamage#
      endif
     endif
    endif
   endif
   `
   rem if bangobj is flak, calc bounce
   tflakindex=0
   if bangobj>0
    if object visible(bangobj)=1
     if bangobj>=flakelementoffset and bangobj<=flakelementoffset+flakelementmax
      tflakindex=phya-flakelementoffset
     endif
     tf=tflakindex
     if tf>array count(flakelement()) then tflakindex=0
    endif
    if tflakindex>0
     rem can now impact and detonate
     tf=tflakindex
     if flakelement(tf).profile.bounceonhit>1
      flakelement(tf).profile.bounceonhit=flakelement(tf).profile.bounceonhit-1
      if flakelement(tf).profile.bounceonhit>1
       tflakid=flakelement(tf).flakid
       rem X10 - 301007 - added object to draw position from
       tttobj=bangobj
       if tttobj>0
        if object exist(tttobj)=1
         playinternal3dsound(flak(tflakid).sound.sndbounceid,object position x(tttobj),object position y(tttobj),object position z(tttobj))
        endif
       endif
      endif
     endif
     if flakelement(tf).profile.bounceonhit<=1
      rem handle explode on hit, when bounce done or no bounce used
      if flakelement(tf).profile.explodeonhit=1 then flakelement(tf).profile.explodeonhit=2
     endif
    endif
   endif
   `
   rem bangobj e
   e=phyobjele(bangobj)
   if e>0
    rem entity profile id
    entid=entityelement(e).bankindex
    rem only deal damage if neither object part of player-carry-collisio n
    if camerapicked>0 and (bangobj=camerapicked or bangotherobj=camerapicked)
     phymagnitude#=0.0
    endif
    rem only allow damage if other object is NOT a debris fragment
    if bangotherobj>0 and bangotherobj<=array count(phyobjele())
     if phyobjele(bangotherobj)=0 then phymagnitude#=0.0
    endif
    rem if magnitude high enough, cause damage
    if phymagnitude#>10.0
     rem damage both objects involved in impact
     tdamage=(phymagnitude#-10.0) : tdamagesource=0 : timpacttype=1
     if tdamage>2 and tdamagebybangcount=0
      rem entity damage here
      tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
      if e1>0 then e=e1 : entid=entityelement(e).bankindex : gosub _entity_deducthealth : tdamagebybangcount=20
      if e2>0 then e=e2 : entid=entityelement(e).bankindex : gosub _entity_deducthealth : tdamagebybangcount=20
     endif
     rem bangobj e refresh
     e=phyobjele(bangobj)
     if e>0
      entid=entityelement(e).bankindex
     endif
    endif
    rem deal with sound
    matindex=entityprofile(entid).materialindex-1
    if matindex>=0 and matindex<=gmaterialmax
     rem monitor travelling value
     ttravelled#=0.0
     if phyhorizontalscrape=1
      rem as long as no sudden stopping, continue travel value for scrape
      if bangobj=phya then ttravelled#=phyvelocitya#
      if bangobj=phyb then ttravelled#=phyvelocityb#
     endif
     rem impact controls volume
     tvol#=100 : rem (phyimpact#-1.0)*10.0 : if tvol#>100.0 then tvol#=100.0
     tspd#=material(matindex).freq+rnd(material(matindex).freq/10.0)
     sbase=0
     rem only play impact if slowed/stopped and was
     if phyimpactstop#>0 and phyimpact#>4.0
      sbase=material(matindex).impactid
     endif
     if ttravelled#>10.0
      if phylasttravelled#(bangobj)>10.0
       rem continuation of travel, switch to scrape
       sbase=material(matindex).scrapeid
       tvol#=ttravelled#*2.0 : if tvol#>100.0 then tvol#=100.0
      endif
     endif
     phylasttravelled#(bangobj)=ttravelled#
     rem play sound of material impact
     if sbase>0
      for tchannels=0 to 4
       s=sbase+tchannels
       if sound exist(s)=1
        if sound playing(s)=0 and phyobjsounding(bangobj)=0
         playinternalBC3dsound(s,object position x(bangobj),object position y(bangobj),object position z(bangobj),25.0)
         phyobjsounding(bangobj)=5
         tsndvolume#=80.0+(tvol#*0.2)
         tsndvolume#=(tsndvolume#/100.0)*soundvolumes(1)
         set sound volume s,tsndvolume#         
         if tspd#>2000 then set sound speed s,tspd#
         exit
        endif
       endif
      next tchannels
     endif
    endif
    if phyimpact#>2.0
     rem adjust entity floor position (for shadow calc)
     entityelement(e).floorposy=object position y(bangobj)-(object size y(bangobj)/2)
     rem recalc adjustment for objects that must find the floor perfectly
     if entityelement(e).eleprof.physics=1
      if physxedition=1
       rem PHYSX can handle small objects, tweak not needed
      else
       rem ODE tweaks
       centx#=ODE GET BODY ADJUSTMENT X(bangobj)
       centy#=ODE GET BODY ADJUSTMENT Y(bangobj)
       centz#=ODE GET BODY ADJUSTMENT Z(bangobj)
       tprofileobj=entityelement(e).profileobj
       offset limb bangobj,0,(object collision center x(tprofileobj)*-1)+centx#,(object collision center y(tprofileobj)*-1)+centy#,(object collision center z(tprofileobj)*-1)+centz#
      endif
     endif
    endif
    if phyobjsounding(bangobj)>0 then phyobjsounding(bangobj)=phyobjsounding(bangobj)-1
   else
    rem (E=0) physics object has no entity (can only be debris particle)
    rem and only if not flak debris
    if tflakindex=0
     `
     rem X10 - 011107 - this is an bug because only BANGOBJ was checked for E=0 (not PHYA/B so it could remove an actual object from the scene unjustly, floating gun issue)
     if bangobj>0 and bangobj<physicsuniverseobj
      if object in screen(bangobj)=0
       rem remove from simulation if not in screen
       `if phyobjele(bangobj)>=0 `should not auto remove an actual physics based obj, just the E=0 ones!
       if phyobjele(bangobj)=0
        rem and only if not guns (which use E=-1)
        if physxedition=1
         ttobj=bangobj : gosub _phy_removeentity
        else
         ode destroy object bangobj
        endif
        hide object bangobj
       endif
      endif
     endif
     `
    endif
   endif
   `
  endif
  endif
  `
 endwhile
 `
 rem Reduce bang damage counter (so bang damage does not machine gun and drain all entity health)
 if tdamagebybangcount>0
  dec tdamagebybangcount
 endif
 `
 rem also handle shadows
 gosub _physics_shadowcontrol
 `
 rem now go through all objects to see how they react in water out of water
 gosub _physics_waterandgravity
 `
return

_physics_shadowcontrol:
 `
 rem also handles physics object destruction within entity element loop
 rem for out of universe error if no debug cursor reset
 if physicsdebug=0 then set cursor 0,0
 `
 rem Number of shadows allowed in scene (performance hit here)
 if gautoshadowreducer=0
  rem Do not use shadow slider, sacrifice performance for all shadows we asked for
  numberofshadowstoshow=hudshadowquantity
 else
  if timer()>shadowquantitysliderpacer+1000
   shadowquantitysliderpacer=timer()
   if screen fps()<60
    if shadowquantityslider>0 then dec shadowquantityslider
   else
    if screen fps()>75
     if shadowquantityslider<hudshadowquantity then inc shadowquantityslider
    endif
   endif
  endif
  numberofshadowstoshow=shadowquantityslider
 endif
 `
 rem work out closest X number of characters for final shadow control
 shadowfadeindistance#=400.0 : rem default point at which shadow fades out
 for e=1 to entityelementmax : entityelement(e).eleprof.castshadow=0 : next e
 countentitiesfightingforshadows=0
 for nsts=1 to numberofshadowstoshow
  theclosestcharactertome#=99999.99
  theclosestcharactertomee=0
  for e=1 to entityelementmax
   tentid=entityelement(e).bankindex
   if entityprofile(tentid).ischaracter=1
    if entityelement(e).eleprof.castshadow=0
     if entityelement(e).plrdist<theclosestcharactertome#
      theclosestcharactertome#=entityelement(e).plrdist
      theclosestcharactertomee=e
     endif
     if nsts=numberofshadowstoshow
      if entityelement(e).plrdist<400.0
       inc countentitiesfightingforshadows
      endif
     endif
    endif
   endif
  next e
  if theclosestcharactertomee>0
   e=theclosestcharactertomee
   entityelement(e).eleprof.castshadow=1
   if nsts=numberofshadowstoshow and countentitiesfightingforshadows>numberofshadowstoshow
    rem there are more characters than shadow resources within range, so
    rem reduce shadow fade in distance so hide the popping
    shadowfadeindistance#=theclosestcharactertome#
    if shadowfadeindistance#>400.0 then shadowfadeindistance#=400.0
    if shadowfadeindistance#<100.0 then shadowfadeindistance#=100.0
   endif
  endif
 next nsts
 `
 rem slowly curve the shadow fade in distance for graceful shadow LOD
 if int(shadowfadeindistance#)<>int(shadowfadeindistancea#)
  shadowfadeindistancea#=curvevalue(shadowfadeindistance#,shadowfadeindistancea#,10.0)
 endif
 `
 rem adjust shadows of all physics objects
 yesyes=0
 for e=1 to entityelementmax
  `
  rem get entity element
  tobj=entityelement(e).obj
  tflag=0 : tentid=entityelement(e).bankindex
  if tobj>0 then tflag=1
  if tflag=1
   `
   rem X10 shadow control (shows non-char & character shadows close to player, blob the rest
   tobjshadowreach#=0.0
   if entityprofile(tentid).ischaracter=0
    rem non character shadow
    standardfadeinforcrates#=500.0
    `rem ensure only cast shadows on those entities with the flag
    `if entityelement(e).eleprof.castshadow=1 and entityelement(e).plrdist<standardfadeinforcrates# and entityelement(e).active<>0
    if entityelement(e).plrdist<standardfadeinforcrates# and entityelement(e).active<>0
     rem all dynamic entities within range of player
     if entityprofile(tentid).ismarker=0
      if entityprofile(tentid).isimmobile=0
       rem only shadow none markers and dynamic
       if camera position y(playercam)>entityelement(e).y
        tallowshadowtobecreated=1
       else
        tallowshadowtobecreated=0
       endif
       if tallowshadowtobecreated=1
        set shadow shading on tobj,-1,standardfadeinforcrates#,1
        tshadowcastdistance#=500 : set object radius tobj,tshadowcastdistance#
        shadowobj(tobj)=1
       else
        rem 10 - 031007 - switch off shadows which have casters higher than players eye
        set shadow shading off tobj
        shadowobj(tobj)=0
       endif
      endif
     endif
    else
     rem dynamic entities just switch off their shadows after range or inactive
     set shadow shading off tobj
     shadowobj(tobj)=0
    endif
   else
    rem character shadow
    if entityelement(e).eleprof.castshadow=1
     rem only use shadows if entity raycast from player is unobstructed
     rem and that the player is above the base position of the entity (downward casting only)
     rem which resolves shadow artifacts when shadow volume cuts through walls/floors
     if camera position y(playercam)>entityelement(e).y
      tallowshadowtobecreated=1
     else
      tallowshadowtobecreated=0
     endif
     if tallowshadowtobecreated=1
      rem shadows from elements closer than X
      set shadow shading on tobj,-1,shadowfadeindistancea#,1
      rem only hide blob shadow if not experiencing shadow resource fighting
      if countentitiesfightingforshadows<=numberofshadowstoshow
       rem the reason is that even though real shadow used, it can be faint!
       shadowobj(tobj)=1
      endif
     else
      rem no shadow if cannot see entity that casts it (see above reason)
      set shadow shading off tobj
      shadowobj(tobj)=0      
     endif
    else
     rem shadows further use blob shadow instead
     set shadow shading off tobj
     shadowobj(tobj)=0
    endif
    `
    rem Control length of shadow cast on valid shadows
    rem (by raycasting from caster in direction away from light to solid surface)
    if shadowobj(tobj)=1
     `
     remstart
     rem 150807 - too many problems casting 'LONG' horiz-based shadows given the
     rem time remaining before Christmas. I have a few new ideas based on baking
     rem world normals into the scene, and only shading those polygons that are
     rem facing the source of the volume. This means clipping is only required
     rem for larger blockers such as walls/floors (another challenge)
     rem perhaps do this gradually so shadow expand and shrink as raycast hits
     rem various static blockers both incidental and substantial when moving
     tlightdirx#=entityelement(e).x-avlightposx#
     tlightdiry#=(entityelement(e).y+30)-avlightposy#
     tlightdirz#=entityelement(e).z-avlightposz#
     tlightdirdst#=sqrt(abs(tlightdirx#*tlightdirx#)+abs(tlightdiry#*tlightdiry#)+abs(tlightdirz#*tlightdirz#))
     tlightdirx#=tlightdirx#/tlightdirdst#
     tlightdiry#=tlightdiry#/tlightdirdst#
     tlightdirz#=tlightdirz#/tlightdirdst#
     tlightdirx#=entityelement(e).x+(tlightdirx#*1000.0)
     tlightdiry#=(entityelement(e).y+65)+(tlightdiry#*1000.0)
     tlightdirz#=entityelement(e).z+(tlightdirz#*1000.0)
     rem X10 new ray cast quicker
     if 1
      tcastersrcx=entityelement(e).x
      tcastersrcy=entityelement(e).y+65
      tcastersrcz=entityelement(e).z
      tshadowcastdistance#=static raycast(tcastersrcx,tcastersrcy,tcastersrcz,tlightdirx#,tlightdiry#,tlightdirz#)
     else
      `tried it and the distance was incorrect - not far enough caused shadow corruption
      `and i need the normal back from the test to do elongated volume calculation
      `tshadowcastdistance#=AI ray cast(entityelement(e).x,entityelement(e).y+65,entityelement(e).z,tlightdirx#,tlightdiry#,tlightdirz#)
      `if tshadowcastdistance#<>-1
      ` dstx#=tlightdirx#-entityelement(e).x
      ` dsty#=tlightdiry#-(entityelement(e).y+65)
      ` dstz#=tlightdirz#-entityelement(e).z
      ` tshadowcastdistance#=tshadowcastdistance#*sqrt(abs(dstx#*dstx#)+abs(dsty#*dsty#)+abs(dstz#*dstz#))
      `else
      ` tshadowcastdistance#=0.0
      `endif
     endif
     tavoidclipartefactbuffer#=5.0
     if tshadowcastdistance#>0.0
      rem get normal from raycast hit
      tnx#=checklist fvalue a(7)
      tny#=checklist fvalue b(7)
      tnz#=checklist fvalue c(7)
      rem get look vector of camera position to impact of ray coordinate
      timpx#=checklist fvalue a(6)
      timpy#=checklist fvalue b(6)
      timpz#=checklist fvalue c(6)
      tcamx#=timpx#-camera position x(playercam)
      tcamy#=timpy#-camera position y(playercam)
      tcamz#=timpz#-camera position z(playercam)
      tcamdst#=sqrt(abs(tcamx#*tcamx#)+abs(tcamy#*tcamy#)+abs(tcamz#*tcamz#))
      tcamx#=tcamx#/tcamdst#
      tcamy#=tcamy#/tcamdst#
      tcamz#=tcamz#/tcamdst#
      rem 2D dot product (between camera and wall/floor)
      tdot2#=(tnx#*tcamx#)+(tny#*tcamy#)+(tnz#*tcamz#)
      rem 2D dot product (between caster and wall/floor)
      tcamx#=timpx#-entityelement(e).x
      tcamy#=timpy#-(entityelement(e).y+65)
      tcamz#=timpz#-entityelement(e).z
      tcamdst#=sqrt(abs(tcamx#*tcamx#)+abs(tcamy#*tcamy#)+abs(tcamz#*tcamz#))
      tcamx#=tcamx#/tcamdst#
      tcamy#=tcamy#/tcamdst#
      tcamz#=tcamz#/tcamdst#      
      tdot1#=(tnx#*tcamx#)+(tny#*tcamy#)+(tnz#*tcamz#)      
      if tdot2#>=0.0
       rem when camera look vector faces the 'BACK' of the shadow hitting surface, clip
       rem 150807 - when shadow heading toward player, reduce length by how much it faces plr
       tavoidclipartefactbuffer#=(tshadowcastdistance#*-1)*tdot2#
      else
       rem when camera look vector is facing surface on which shadow cast, be generous
       tavoidclipartefactbuffer#=abs((tshadowcastdistance#/2.0)*tdot2#)
       rem tdot1# adds extra to buffer when shadow angle to wall not dead on (need longer shadow to cast 'along' wall)
       inc tavoidclipartefactbuffer#,(1.0-abs(tdot1#))*500.0
      endif
     endif
     lastentityshadowlength#(e)=curvevalue(tshadowcastdistance#+tavoidclipartefactbuffer#,lastentityshadowlength#(e),5.0)
     remend
     lastentityshadowlength#(e)=150
     `
    endif
    if entityprofile(tentid).scale<30
     rem X10 - V109 - 160309 - avoids cull bug when large scaled objects offset out of view
     set object radius tobj,0
    else
     set object radius tobj,lastentityshadowlength#(e)
    endif
    `
   endif
   `
   rem if object needs destroying, do it here
   if phyobjremove(tobj)<>0
    rem used when want to disturb another phy obj (ie move up slightly, then remove on next pass)
    if phyobjremove(tobj)=1
     rem this will nudge anything sitting on obj
     if physxedition=1
      ttobj=phyobjremove(tobj) : gosub _phy_nudgeentityup
     else
      ode set linear velocity phyobjremove(tobj),0,10,0
     endif
     phyobjremove(tobj)=2
    else
     if phyobjremove(tobj)=2
      rem this will nudge anything sitting on obj further
      if physxedition=1
       ttobj=phyobjremove(tobj) : gosub _phy_nudgeentityup
      else
       ode set linear velocity phyobjremove(tobj),0,5,0
      endif
      phyobjremove(tobj)=3
     else
      rem this finally removes the phy obj from the simulation
      gosub _physics_switchoffe
      phyobjremove(tobj)=0
      rem X10, if character, use ragdoll destruction
      tentid=entityelement(e).bankindex
      `if entityprofile(tentid).ischaracter=1 `X10 V109 - 100309 - NORAGDOLL flag
      if entityprofile(tentid).ischaracter=1 and entityprofile(tentid).noragdoll=0
       if entityelementusingode(e)=0
        storeobj=obj
        obj=tobj : gosub _slot_ode_collapse
        obj=storeobj
       endif
      else
       rem and then hide the object if not already hidden
       hide object tobj
      endif
     endif
    endif
   endif
   `
   rem if corpse of character fades out, do it here
   if entityprofile(tentid).ischaracter=1
    if entityelementusingode(e)>0
     if entityelementusingode(e)>1
      entityelementusingode(e)=entityelementusingode(e)-1
      rem X20 - 251007 - During ragdoll sequence, fade out alpha of the object
      if gfadeoutragdolls=1
       tperc#=entityelementusingode(e)-80 : rem 081107 - shorter and faster
       if tperc#<0 then tperc#=0
       if tperc#>100 then tperc#=100
       set alpha mapping on tobj,tperc#
       if entityelementusingode(e)=95
        rem 081107 - one time in the fade out code, create puff of smoke
        if particlecorpsedust<>0
         inc particlecorpsedust
         if particlecorpsedust>15 then particlecorpsedust=11
         emit particle particlecorpsedust,object position x(tobj),object position y(tobj),object position z(tobj)
        endif  
       endif
      endif
     else
      if entityelementusingode(e)=1 and (object in screen(tobj)=0 or gfadeoutragdolls=1)
       rem but only after decaytime has elapsed
       if gfadeoutragdolls=1
        rem remove immediately after fade out
        tremovebodyfromgame=1
        rem and put alpha value back to normal
        set alpha mapping on tobj,100
       else
        tremovebodyfromgame=0
        if entityelement(e).eleprof.ex.decaytime>0
         if timer()-entityelement(e).timekilled>(entityelement(e).eleprof.ex.decaytime*1000)
          tremovebodyfromgame=1
         endif
        endif
       endif
       if tremovebodyfromgame=1
        rem remove ragdoll altogether
        if physxedition=1
         rem PHYSX - no ragdoll
        else
         ODE destroy ragdoll tobj
        endif
        if ragdollcountingame>0 then dec ragdollcountingame
        rem ensure this is called only once
        entityelementusingode(e)=0
        gosub _physics_switchoffe
        rem actually hide the clone ragdoll in case it needed for respawn later
        hide object tobj : position object tobj,-50000,-50000,-50000
        exclude object on tobj : rem X10 - 241007 - removes from collision and update work!
        rem X10 - 101007 - do not remove OBJ value, need it for respawning!
        `entityelement(e).obj=0 : tobj=0
        rem X10 clear the undesirable flag when corpse is removed
        if entityelement(e).eleprof.aiss.corpsecontainer>=0 and entityelement(e).eleprof.aiss.corpsecontainer<20
         AI CLEAR UNDESIRABLE GRID SPACE entityelement(e).eleprof.aiss.corpsecontainer,entityelement(e).eleprof.aiss.corpsex,entityelement(e).eleprof.aiss.corpsez
         entityelement(e).eleprof.aiss.corpsecontainer=-1
        endif
       endif
      endif
     endif
    endif
   endif   
   `
   rem serious error, object has left the universe (through hole in geom!)
   if showfpsinrealgame=2
    if tobj>0
     if object position y(tobj)<-20
      position object tobj,object position x(tobj),-25,object position z(tobj)
      print "Object ";e;entityelement(e).eleprof.name$;" has left the universe at ";str$(int(object position x(tobj)));",";str$(int(object position z(tobj)))
     endif
    endif
   endif
   `
  endif
 next e
 `
return

_physics_waterandgravity_item:
 `
 rem obj is twaterobj, optional e
 rem if have associated entity
 twatere=phyobjele(twaterobj)
 rem depth of surface resistance
 depth#=40.0
 rem if deep enough to cover entity, switch gravity off
 tactualtopofobject#=object position y(twaterobj)+(object size y(twaterobj)/2.0)
 if twatere>0
  rem if character, test higher
  if entityprofile(entityelement(twatere).bankindex).ischaracter=1
   tactualtopofobject#=tactualtopofobject#+25.0
  endif
  rem if ragdoll, have no Y pos, use last entity Y pos
  if entityelementusingode(twatere)>0
   tactualtopofobject#=entityelement(twatere).y+55 : rem 241007 - used to be 25
  endif
 endif
 if tactualtopofobject#<waterlevel#
  rem no gravity
  if physxedition=1
   ttobj=twaterobj : gosub _phy_gravityentityoff
  else
   ode set gravity twaterobj,0
  endif
  rem current velocity of entity (natural damping)
  tvelokay=1
  if twatere>0
   if entityelementusingode(twatere)>0
    rem ragdolls have a natural downward sink underwater
    oldvelx#= 0.0
    oldvely#=-4.0
    oldvelz#= 0.0
    tvelokay=0
   endif
  endif
  if tvelokay=1
   rem regular underwater handling
   if physxedition=1
    ttobj=twaterobj : gosub _phy_getentityvelocity
   else
    oldvelx#=ODE GET BODY LINEAR VELOCITY X(twaterobj)*0.97
    oldvely#=ODE GET BODY LINEAR VELOCITY Y(twaterobj)*0.97
    oldvelz#=ODE GET BODY LINEAR VELOCITY Z(twaterobj)*0.97
   endif
   rem resist zero gravity and entity leaves surface of water (very subtle!)
   if object position y(twaterobj)>waterlevel#-depth#
    resistby#=depth#-abs(object position y(twaterobj)-waterlevel#)
    oldvely#=oldvely#-(resistby#*0.0005)
   endif
   rem raise/lower entity based on weight (750 = 10x10x10 cube) (based on depth)
   depthfactor#=abs(object position y(twaterobj)-waterlevel#)/100.0
   if twatere>0
    depthdecent#=((entityelement(twatere).eleprof.phyweight-2000)/5000.0)*depthfactor#
    oldvely#=oldvely#-depthdecent#
   else
    rem if not entity (debris or ragdoll) sink
    depthdecent#=0.0001
    oldvely#=oldvely#-0.0001
   endif
  endif
  rem 220707 - random chaos in water based on water speed
  if hudwaterspeed>0
   rem nudge in X and Z randomly factored by water speed
   tnudge#=((depthdecent#/25.0)*(hudwaterspeed+0.1))
   cyclicchaos#=cyclicchaos#+0.03
   if rnd(5)<>1 then tnudge#=0.0
   oldvelx#=oldvelx#+(cos(cyclicchaos#)*tnudge#)
   oldvelz#=oldvelz#+(sin(cyclicchaos#)*tnudge#)
  endif
  rem finally apply new velocity
  if physxedition=1
   ttobj=twaterobj : gosub _phy_setentityvelocity
  else
   ode set linear velocity twaterobj,oldvelx#,oldvely#,oldvelz#
  endif
 else
  rem gravity on
  if physxedition=1
   ttobj=twaterobj : gosub _phy_gravityentityon
  else
   ode set gravity twaterobj,1
  endif
 endif
 `
return

_physics_waterandgravity:
 `
 rem go through all entities
 for e=1 to entityelementmax
  twaterobj=entityelement(e).obj
  if twaterobj>0
   if entityelement(e).eleprof.physics=1 or entityelementusingode(e)>0
    rem only physics objects that are subject to ODE gravity
    twatere=e : gosub _physics_waterandgravity_item
   endif
  endif
 next e
 `
 rem go through all debris
 for twaterobj=fragmentobjectoffset to fragmentobjectoffsetmax
  if object exist(twaterobj)=1
   if object visible(twaterobj)=1
    if twaterobj>0
     twatere=0 : gosub _physics_waterandgravity_item
    endif
   endif
  endif
 next twaterobj
 `
return

_physics_applyforce:
 `
 rem X10 takes todee,tdx#,tdy#,tdz#,todeforce#,todefalloff#,tpx#,tpy#,tpz#
 tobj=entityelement(todee).obj
 if tobj>0
  td#=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
  tdx#=tdx#/td# : tdy#=tdy#/td# : tdz#=tdz#/td#
  todeforce#=todeforce#*10.0 : rem bring force to affect physics ODE correctly
  tbulletforce#=(todeforce#/500.0)*(500.0-td#)*todefalloff#
  tbulletforce#=tbulletforce#+(todeforce#*(1.0-todefalloff#))
  massconsideration#=entityelement(todee).eleprof.phyweight/200.0
  if massconsideration#<1.0 then massconsideration#=1.0
  tbulletforce#=tbulletforce#/massconsideration#
  rem simpler force limiter
  tdx#=tdx#*tbulletforce#
  tdy#=tdy#*tbulletforce#
  tdz#=tdz#*tbulletforce#
  gosub _physics_limitforce
  if physxedition=1
   ttobj=tobj : gosub _phy_applyentityforce
  else
   if twithpointforce=1
    ode add force tobj,tdx#*4,tdy#*4,tdz#*4,tpx#,tpy#,tpz#
   else
    tda#=atanfull(tdx#,tdz#)
    ode set linear velocity tobj,tdx#,tdy#,tdz#
    tspinforce#=tbulletforce#/100.0
    if tspinforce#>1.0 then tspinforce#=1.0
    if tspinforce#<-1.0 then tspinforce#=-1.0
    ode set angular velocity tobj,sin(tda#)*(2.5*tspinforce#),0,cos(tda#)*(2.5*tspinforce#)
   endif
  endif
  rem register force with physics object (nudge so SET ACTIVE can be called)
  rem use a random number to send a unique ripple (so we dont keep nudging everything)
  if tobj<array count(phyobjelenudged()) then phyobjelenudged(tobj)=2
 endif
 `
return

_physics_limitforce:
 `
 maxforce#=50.0
 if tdx#>maxforce# then tdx#=maxforce#
 if tdx#<maxforce#*-1 then tdx#=maxforce#*-1
 if tdz#>maxforce# then tdz#=maxforce#
 if tdz#<maxforce#*-1 then tdz#=maxforce#*-1
 if tdy#>maxforce# then tdy#=maxforce#
 if todelimitgobelow=0
  if tdy#<0.01 then tdy#=0.01 : rem apply no downward force (objs get stuck!)
 else
  if tdy#<0.01 then tdy#=tdy#/5.0 : rem reduce so does not enter floor
 endif
 `
return

_physics_applypointforce:
 `
 rem apply point force (tpx#,tpy#,tpz#)
 twithpointforce=1
 gosub _physics_applyforce
 `
return

_physics_entitydrivenphysics:
 `
 rem use entity data to drive object via physics (character)
 todeobj=entityelement(todee).obj
 tmvx#=entityelement(todee).x-object position x(todeobj)
 todeentid=entityelement(todee).bankindex
 `x9tmvszy#=(object size y(todeobj)/2)*(entityprofile(todeentid).scale/100.0)
 `tmvszy#=(object size y(todeobj)/2) `X10 V109 - 090309 - scale is back!
 tmvszy#=(object size y(todeobj)/2)*(entityprofile(todeentid).scale/100.0)
 tmvy#=(entityelement(todee).y+tmvszy#+thover#)-object position y(todeobj)
 tmvz#=entityelement(todee).z-object position z(todeobj)
 tstress#=sqrt(abs(tmvx#)+abs(tmvy#)+abs(tmvz#))
 entitydebug$(todee)="ENTITY DRIVEN PHYSICS ("+str$(int(tmvx#))+","+str$(int(tmvz#))+")"
 rem X10 do not apply controlling position force if no health (so ragdoll can use the force that caused health to hit zero)
 if entityelement(todee).health>0
  `240907 smooth out entity char movement ode set linear velocity todeobj,tmvx#*4,tmvy#*4,tmvz#*4
  rem noticed a bug where E is used, but the element index is TODEE
  tmvx#=tmvx#+entityelement(e).eleprof.aiss.knockbackx
  tmvz#=tmvz#+entityelement(e).eleprof.aiss.knockbackz
  entityelement(e).eleprof.aiss.knockbackx=entityelement(e).eleprof.aiss.knockbackx/2
  entityelement(e).eleprof.aiss.knockbackz=entityelement(e).eleprof.aiss.knockbackz/2
  `X10 101007 - faster vertical - ode set linear velocity todeobj,tmvx#*2,tmvy#*2,tmvz#*2
  if physxedition=1
   ttobj=todeobj : gosub _phy_entitydrivenphysics
  else
   ode set linear velocity todeobj,tmvx#*2,tmvy#*4,tmvz#*2
   if entityelement(todee).norotate=0
    ode set body rotation todeobj,0,entityelement(todee).ry,0
   else
    ode set body rotation todeobj,0,0,0
   endif
  endif
 endif
 `
return

_physics_entitydrivenstaticphysics:
 `
 rem as above but for the pseudo-static objects (door/window)
 todeobj=entityelement(todee).obj
 if physxedition=1
  ttobj=todeobj : gosub _phy_entitydrivenstaticphysics
 else
  if entityelement(todee).norotate=0
   ode set body rotation todeobj,0,entityelement(todee).ry,0
  else
   ode set body rotation todeobj,0,0,0
  endif
 endif
 `
return

_physics_update:
 `
 rem debug info on entities
 if physicsdebug=1
  for e=1 to entityelementmax
   if entityelement(e).active=1
    if entityelement(e).eleprof.physics<>0
     tobj=entityelement(e).obj
     if tobj>0
      if object exist(tobj)=1
       if object in screen(tobj)=1
        center text object screen x(tobj),object screen y(tobj),"size="+str$(object size(tobj))
        center text object screen x(tobj),object screen y(tobj)+16,"weight="+str$(entityelement(e).eleprof.phyweight)
        if e=tclosestpickable
         center text object screen x(tobj),object screen y(tobj)-16,"CLOSEST="+str$(camerareach#)
        endif
       endif
      endif
     endif
    endif
   endif
  next e
 endif
 `
 rem speed gain by disabling physics objects well out of players 'interest'
 if physxedition=1
  rem PHYSX - keep entire scene active
 else
  for e=1 to entityelementmax
   if entityelement(e).active=1
    if entityelement(e).eleprof.physics<>0
     tobj=entityelement(e).obj
     if tobj>0
      if object exist(tobj)=1
       tentid=entityelement(e).bankindex
       if allentsfulllogicatstartcount>0 or entityelement(e).plrdist<500.0 or entityprofile(tentid).ischaracter=1
        rem if within range, keep enabled for player interaction
        ode set enabled tobj,1
       else
        rem only disable if not moving significantly (and not always active)
        tmotionx#=ode get body linear velocity x(tobj)
        tmotiony#=ode get body linear velocity y(tobj)
        tmotionz#=ode get body linear velocity z(tobj)
        tmotion#=abs(tmotionx#)+abs(tmotiony#)+abs(tmotionz#)
        if entityelement(e).eleprof.phyalways=0 and tmotion#<0.005
         ode set active tobj,0
         ode set enabled tobj,0
         entityelement(e).dormant=1
        else
         ode set enabled tobj,1
        endif
       endif
      endif
     endif
    endif
   endif
  next e
 endif
 `
 rem update physics
 if physxedition=1
  gosub _phy_update
 else
  ode update
 endif
 `
 rem for next run - debug readouts
 if physicsdebug=1 then set cursor 0,0
 `
return

rem
rem Called from outside this source file
rem

_physics_ragdollon:
 ode set ragdoll mode 1
return

_physics_gravityon:
 ode set gravity obj,1
return
 
_physics_gravityoff:
 ode set gravity obj,0
return

_physics_setvelocity:
 ode set linear velocity ttobj,ttx#,tty#,ttz#
return

_physics_deleteentity:
 ode destroy object tobj
return

_physics_getvelocityy:
 velocity#=abs(ODE GET BODY LINEAR VELOCITY Y(ttobj))
return

_physics_destroyjustragdoll:
  ODE destroy ragdoll ttobj
return

_physics_destroyragdoll:
  ode set linear velocity obj,0,0,0
  ode set angular velocity obj,0,0,0
  ODE destroy ragdoll tobj
return

_physics_stopvelocity:
 ode set linear velocity tobj,0,0,0
 ode set angular velocity tobj,0,0,0
return

_physics_applyphysicstoattachment:
   ode create dynamic box tobj
   tfriction=(object size x(tobj)*75)+(object size y(tobj)*75)+(object size z(tobj)*75)
   tweight=(object size x(tobj)*25)+(object size y(tobj)*25)+(object size z(tobj)*25)
   tweight=(tweight/50)*50 : tfriction=(tfriction/50)*50
   if tweight<200 then tweight=200
   ode set contact fdir1 tobj,tfriction
   ode set body mass tobj,tweight
   ode set linear velocity tobj,0,0,0
   ode set angular velocity tobj,0,0,0
   ode set gravity tobj,1
   ode set body rotation tobj,0,entityelement(e).ry,0
return

_physics_createragdoll:
 ODE Create Ragdoll from bone model obj,0.6 : rem was 0.8 up to 171007 (was 0.6 on 300707)
 rem set friction and weight for the character as a ragdoll
 ode set contact fdir1 obj,entityprofile(tttentid).phyfriction
 rem ragdoll must use 'percentage' as each bone has its own mass
 ode set body mass obj,1.0
 rem stabalize the object
 ode set linear velocity obj,0,0,0
 ode set angular velocity obj,0,0,0
return

_physics_createfragment:
  ode create dynamic sphere tfobj
  rem X10 - 280907 - new ray cast code for projectile physics
  ode set ray cast tfobj,1
  tfriction=(5*75)+(5*75)+(5*75) : tweight=(5*25)+(5*25)+(5*25)
  tweight=(tweight/50)*50 : tfriction=(tfriction/50)*50
  if tweight<200 then tweight=200
  ode set contact fdir1 tfobj,tfriction
  ode set body mass tfobj,tweight
  rem add one as we need an extra for the detonate bounce
  flakelement(tf).profile.bounceonhit=flakelement(tf).profile.bounceonhit+1
  flakelement(tf).noimpactdelay=50
  rem flak bounces, set physics accordingly
  tdx#=flakelement(tf).profile.xinc*4
  tdy#=flakelement(tf).profile.yinc*4
  tdz#=flakelement(tf).profile.zinc*4
  rem 200807 - a very slight inaccuracy for the human error of characters
  tdx#=tdx#+((rnd(100)-50)/100.0)
  tdz#=tdz#+((rnd(100)-50)/100.0)
  todelimitgobelow=1 : gosub _physics_limitforce : todelimitgobelow=0
  ode set linear velocity tfobj,tdx#*4,tdy#*2,tdz#*4
return

_physics_createdebrisshape:
  select bitdetails(debrisshapeindex).collisionmode
   case 2 : ode create dynamic box fragmento : endcase
   case 3 : ode create dynamic cylinder fragmento : endcase
   case 4 : ode create dynamic sphere fragmento : endcase
  endselect
  ode set contact fdir1 fragmento,50
  ode set body mass fragmento,10
  if debrisexplodable=3
   tdx#=debrisblastawayx#*debrisblastaway
   tdy#=debrisblastawayy#*debrisblastaway
   tdz#=debrisblastawayz#*debrisblastaway
   gosub _physics_limitforce
   ode set linear velocity fragmento,tdx#,tdy#,tdz#
   ode set angular velocity fragmento,2.5+rnd(10)/10.0,1.5+rnd(5)/10.0,rnd(2)/10.0
  else
   if debrisexplodable=1
    ode add force fragmento,0,-1,0,object position x(fragmento),object position y(fragmento)+object size y(fragmento),object position z(fragmento)
    ode set angular velocity fragmento,2.5+rnd(10)/10.0,1.5+rnd(5)/10.0,rnd(2)/10.0
   else
    ode set linear velocity fragmento,0,-20,0
    ode set angular velocity fragmento,0,0,0
   endif
  endif
return

_physics_updatesmall:
 `
 rem update physics engine
 if physxedition=1
  gosub _phy_update
 else
  ode update 0.001
 endif
 `
return
