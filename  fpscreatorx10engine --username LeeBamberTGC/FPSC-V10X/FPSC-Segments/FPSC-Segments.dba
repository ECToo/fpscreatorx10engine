rem
rem SEGMENTS
rem

_segment_validatearraysize:
 `
 rem ensure enough space in arrays
 if segidmaster+32>segidmastermax
  segidmastermax=segidmaster+32
  dim selectionbank$(segidmastermax)
  dim selectionbanklocal$(segidmastermax)
  dim segmentprofileheader(segidmastermax) as segmentprofileheadertype
  dim segmentprofile(segidmastermax,64) as segmentprofiletype
 endif
 `
return

_segment_shufflebank:

rem FPSCV104RC6 - scan entire map data, delete all segment entries not used
if segidmaster>0
 dim segmentbankused(segidmaster)
 for tttsegid=1 to segidmaster
  segmentbankused(tttsegid)=0
 next tttsegid
 rem segs in map
 for tttl=0 to layermax
  for tttx=0 to maxx
   for ttty=0 to maxy
    tttmapid=map(tttl,tttx,ttty)
    if tttmapid>0
     tttsegid = ( tttmapid && %11111111111100000000000000000000 ) >> 20
     if tttsegid>0 then segmentbankused(tttsegid)=1
    endif
    rem segs in olay
    ttto=mapolay(tttl,tttx,ttty)
    if ttto>0
     for tt=0 to 50
      tttmapid=olaylist(ttto,tt)
      if tttmapid>0
       tttsegid = ( tttmapid && %11111111111100000000000000000000 ) >> 20
       if tttsegid>0 then segmentbankused(tttsegid)=1
      endif
     next tt
    endif
   next ttty
  next tttx
 next tttl
 for tttsegid=1 to segidmaster
  if segmentbankused(tttsegid)=0
   selectionbank$(tttsegid)=""
  endif
 next tttsegid
 rem shuffle to remove empties
 for tttsegid=1 to segidmaster
  segmentbankused(tttsegid)=0
 next tttsegid
 treadsegid=1 : tlargest=0
 for tttsegid=1 to segidmaster
  if treadsegid<=segidmaster
   while selectionbank$(treadsegid)=""
    inc treadsegid : if treadsegid>segidmaster then exit
   endwhile
   if treadsegid<=segidmaster
    selectionbank$(tttsegid)=selectionbank$(treadsegid)
    selectionbanklocal$(tttsegid)=selectionbanklocal$(treadsegid)
    segmentprofileheader(tttsegid)=segmentprofileheader(treadsegid)
    for tt=0 to 64 : segmentprofile(tttsegid,tt)=segmentprofile(treadsegid,tt) : next tt
    segmentbankused(treadsegid)=tttsegid
    tlargest=tttsegid
   else
    selectionbank$(tttsegid)=""
   endif
  else
   selectionbank$(tttsegid)=""
  endif
  inc treadsegid
 next tttsegid
 rem new list size
 if segidmaster<>tlargest
  segidmaster=tlargest
  entityorsegmententrieschanged=1
 endif
 rem update bank index numbers in mapdata
 for tttl=0 to layermax
  for tttx=0 to maxx
   for ttty=0 to maxy
    tttmapid=map(tttl,tttx,ttty)
    if tttmapid>0
     tttsegid = ( tttmapid && %11111111111100000000000000000000 ) >> 20
     if tttsegid>0
      rem new segment entry place index
      newtttsegid = segmentbankused(tttsegid)
      tttmapid = tttmapid && %00000000000011111111111111111111
      tttmapid = tttmapid || ( newtttsegid << 20 )
      map(tttl,tttx,ttty)=tttmapid
     endif
    endif
    rem segs in olay
    ttto=mapolay(tttl,tttx,ttty)
    if ttto>0
     for tt=0 to 50
      tttmapid=olaylist(ttto,tt)
      if tttmapid>0
       tttsegid = ( tttmapid && %11111111111100000000000000000000 ) >> 20
       if tttsegid>0
        newtttsegid = segmentbankused(tttsegid)
        tttmapid = tttmapid && %00000000000011111111111111111111
        tttmapid = tttmapid || ( newtttsegid << 20 )
        olaylist(ttto,tt)=tttmapid
       endif
      endif
     next tt
    endif
   next ttty
  next tttx
 next tttl
 undim segmentbankused()
endif

return

_segment_savebank:

rem Save segment bank
if file exist(myownrootdir$+"mapbank\testmap\map.seg")=1 then delete file myownrootdir$+"mapbank\testmap\map.seg"
open to write 1,myownrootdir$+"mapbank\testmap\map.seg"
 write file 1,segidmaster
 if segidmaster>0
  gosub _segment_validatearraysize
  for segid=1 to segidmaster
   write string 1,selectionbank$(segid)
  next segid
 endif
close file 1

return

_segment_deletebank:

rem Destroy old segments
if segidmastermax>0
 rem changed from segidmaster
 for segid=1 to segidmastermax
  segobj=selectionbankoffset+segid
  if object exist(segobj)=1 then delete object segobj
  selectionbank$(segid)=""
 next segid
endif
segidmaster=0

return

_segment_loadbank:

rem If seg file exists
if file exist(myownrootdir$+"mapbank\testmap\map.seg")=1

rem Destroy old segments
gosub _segment_deletebank

rem Load segment bank
open to read 1,myownrootdir$+"mapbank\testmap\map.seg"
 read file 1,segidmaster
 if segidmaster>0
  gosub _segment_validatearraysize
  for segid=1 to segidmaster
   read string 1,selectionbank$(segid)
  next segid
 endif
close file 1

rem Load segments specified by bank
segdir$="segments\"
if segidmaster>0
 for segid=1 to segidmaster
  seg$=selectionbank$(segid)
  if seg$<>""
   segcategory$=getfirstdir(seg$)
   segpath$=getseconddir(seg$)
   gosub _segment_load
   if segmentprofileheader(segid).partmax=-1
    selectionbank$(segid)=""
   endif
  else
   segmentprofileheader(segid).partmax=-1
  endif
 next segid
endif

rem No file
endif

return

_segment_updatebank:

rem If seg file exists
if file exist(myownrootdir$+"mapbank\testmap\map.seg")=1

rem Clear non-present entries
for segid=segidmaster+1 to segidmastermax
 selectionbank$(segid)=""
next segid

rem Update segment bank
segdir$="segments\"
open to read 2,myownrootdir$+"mapbank\testmap\map.seg"
 read file 2,segidmaster
 if segidmaster>0
  gosub _segment_validatearraysize
  for segid=1 to segidmaster
   read string 2,tseg$
   if tseg$<>selectionbank$(segid)
    selectionbank$(segid)=tseg$
    seg$=selectionbank$(segid)
    segcategory$=getfirstdir(seg$)
    segpath$=getseconddir(seg$)
    gosub _segment_load
   endif
  next segid
 endif
close file 2

rem No file
endif

return

_segment_preloadtextures:

rem Load textures for segment
segmeshpartmax=segmentprofileheader(segid).lastmeshmax
for p=0 to segmeshpartmax
 `
 rem RADICAL change - D2 only required texture - rest generated here D.I.N.S
 `
 rem Can use multi-texture
 if segobjusedforfinalgame=1
  if segmentprofile(segid,p).multimeshmode=1
   extralimbp=segmentprofile(segid,p).multimeshstart
   if extralimbp>0
    rem points to two new meshes which may have _02 and _03 textures associated
    ttfile$=segmentprofile(segid,p).tex$
    tfilecheck$=left$(ttfile$,len(ttfile$)-4)
    if lower$(right$(tfilecheck$,6))="_01_d2"
     rem generate _02 and _03 textures in correct part of segment (mesh)
     tfile$=ttfile$ : tfile$=left$(tfile$,len(tfile$)-len("_NN_D2.TGA"))
     segmentprofile(segid,extralimbp+0).tex$=tfile$+"_02_D2.TGA"
     if file exist(segmentprofile(segid,extralimbp+0).tex$)=0
      segmentprofile(segid,extralimbp+0).tex$=tfile$+"_02_D2.DDS"
      if file exist(segmentprofile(segid,extralimbp+0).tex$)=0
       segmentprofile(segid,extralimbp+0).tex$=ttfile$
      endif
     endif
     segmentprofile(segid,extralimbp+1).tex$=tfile$+"_03_D2.TGA"
     if file exist(segmentprofile(segid,extralimbp+1).tex$)=0
      segmentprofile(segid,extralimbp+1).tex$=tfile$+"_03_D2.DDS"
      if file exist(segmentprofile(segid,extralimbp+1).tex$)=0
       segmentprofile(segid,extralimbp+1).tex$=ttfile$
      endif
     endif
    endif
   endif
  endif
 endif
 `
 rem Load actual textures based on effect requirements
 segmentprofile(segid,p).texid=0
 segmentprofile(segid,p).texdid=0
 segmentprofile(segid,p).texnid=0
 segmentprofile(segid,p).texsid=0
 texdir$=segmentprofile(segid,p).tex$
 if texdir$<>""
  `
  rem Effect or No
  tfile$=segmentprofile(segid,p).effect$
  teffectuseslightmapstage=1 : gosub _common_makeeffecttextureset
  if tfile$<>"" and guseeffectonscenesstate=1
   `
   rem Load and apply MAIN texture directly
   tstage=0
   for tlayer=0 to 3
    if tlayer=0 then texfiletouse$=texdir1$
    if tlayer=1 then texfiletouse$=texdir2$
    if tlayer=2 then texfiletouse$=texdir3$
    if tlayer=3 then texfiletouse$=texdir4$
    if tlayer=4 then texfiletouse$=texdir5$
    texuseid=loadinternaltexture(texfiletouse$)
    if texuseid=0
     rem some effects need a blank texture if no file available
     if tlayer<=ensureclearlayermax
      rem black texture if no texture
      texuseid=loadinternalimagecompressquality("texturebank\common\black.tga",1,0)
     endif
    endif
    if texuseid>0
     if tstage=0 then segmentprofile(segid,p).texdid=texuseid : segmentprofile(segid,p).texid=texuseid
     rem hardcodedtexturestages from _common_makeeffecttextureset
     if hardcodedtexturestages=2
      rem bump.fx
      if tstage=1 then segmentprofile(segid,p).texdid=texuseid
      if tstage=2 then segmentprofile(segid,p).texsid=texuseid
      if tstage=3 then segmentprofile(segid,p).texnid=texuseid
     else
      rem illumination.fx
      if tstage=1 then segmentprofile(segid,p).texdid=texuseid
      if tstage=2 then segmentprofile(segid,p).texsid=texuseid
     endif
     inc tstage
    endif
   next tlayer
   `
  else
   rem Basic Texture (D2)
   tfile$=segmentprofile(segid,p).tex$
   segmentprofile(segid,p).texid=loadinternaltexture(tfile$)
   if segmentprofile(segid,p).multimeshmode=1
    textralimbp=segmentprofile(segid,p).multimeshstart
    if textralimbp>0
     segmentprofile(segid,textralimbp+0).texid=loadinternaltexture(segmentprofile(segid,textralimbp+0).tex$)
     segmentprofile(segid,textralimbp+1).texid=loadinternaltexture(segmentprofile(segid,textralimbp+1).tex$)
    endif
   endif
  endif
 endif
 `
next p

return

_segment_preloadeffects:

rem Load effect for segment
segmeshpartmax=segmentprofileheader(segid).lastmeshmax
for p=0 to segmeshpartmax
 if segmentprofile(segid,p).effect$<>"" and segnoeffects=0 and guseeffectonscenesstate=1
  tfile$=segmentprofile(segid,p).effect$
  gosub _common_wipeeffectifnotexist
  if tfile$<>""
   debugfilename(tfile$,"effect:"+seg$)
   segmentprofile(segid,p).effectid=loadinternaleffect(tfile$)
  else
   segmentprofile(segid,p).effectid=0
  endif
 else
  segmentprofile(segid,p).effectid=0
 endif
next p

return

_segment_load:

rem Segment Object Index
segobj=selectionbankoffset+segid

rem debug info
mytimer=timer()

rem Load segment profile data
segmentprofileheader(segid).partmax=-1
segmentprofileheader(segid).preventai=0
gosub _segment_loaddata
segpartmax=segmentprofileheader(segid).partmax

rem Only if profile exists
if segpartmax<>-1
 `
 rem Check if DBO version of segment obj exists
 tsegobjpreloaded=0
 if segobjusedforfinalgame=0
  tsegobjfile$=left$(segdir$+seg$,len(segdir$+seg$)-4)+".dbo"
  rem X10 - 261107 - remove last temp file from program files (DBO)
  tsegobjfile$=turnfilenameuserlocal(tsegobjfile$)
  if file exist(tsegobjfile$)=1 and segobjusedformapeditor=0
   load object tsegobjfile$,segobj
   tsegobjpreloaded=1
  endif
 endif
 `
 rem segment mesh max
 segmeshpartmax=segmentprofileheader(segid).lastmeshmax
 `
 rem Load meshes for segment
 if tsegobjpreloaded=0
  for p=0 to segmeshpartmax
   if segmentprofile(segid,p).partmode=0
    tmeshname$=segmentprofile(segid,p).meshname$
    if segmentprofile(segid,p).csgmesh$<>"" then tmeshname$=segmentprofile(segid,p).csgmesh$
    if tmeshname$<>""
     tfile$=tmeshname$
     debugfilename(tfile$,"mesh:"+seg$)
     segmentprofile(segid,p).meshid=loadinternalmesh(tfile$)
    endif
   endif
  next p
 endif
 `
 rem Load multi-meshes for segment
 originalsegmeshpartmax=-1
 if segobjusedforfinalgame=1
  dim tempsegmentprofile(64) as segmentprofiletype
  tempp=0
  rem place where new limbs will be located (extralimbp) - we will move things like entitys/csgs to end
  extralimbp=segmeshpartmax+1
  for p=0 to segmeshpartmax
   if segmentprofile(segid,p).partmode=0
    ttmeshname$=segmentprofile(segid,p).meshname$
    if segmentprofile(segid,p).multimeshmode=1
     if segmentprofile(segid,p).csgmesh$="" and ttmeshname$<>""
      if lower$(right$(ttmeshname$,3))="a.x"
       for ttwo=0 to 1
        tmeshname$=ttmeshname$
        tmeshname$=left$(tmeshname$,len(tmeshname$)-3)
        if ttwo=0 then tmeshname$=tmeshname$+"b.x"
        if ttwo=1 then tmeshname$=tmeshname$+"c.x"
        tfile$=tmeshname$
        debugfilename(tfile$,"mesh:"+seg$)
        tempsegmentprofile(tempp)=segmentprofile(segid,p)
        if ttwo=0 then tempsegmentprofile(tempp).meshid=loadinternalmesh(tfile$)
        if ttwo=1 then tempsegmentprofile(tempp).meshid=loadinternalmesh(tfile$)
        inc tempp
       next ttwo
      else
       rem not a.x, but can still habe multi-texture so use base mesh instead
       tempsegmentprofile(tempp)=segmentprofile(segid,p)
       tempsegmentprofile(tempp).meshid=loadinternalmesh(ttmeshname$)
       inc tempp
       tempsegmentprofile(tempp)=segmentprofile(segid,p)
       tempsegmentprofile(tempp).meshid=loadinternalmesh(ttmeshname$)
       inc tempp
      endif
      segmentprofile(segid,p).multimeshstart=extralimbp
      inc extralimbp,2
     endif
    endif
   endif
  next p
  rem multimesh entries made
  if tempp>0
   rem first copy non-mesh parts (entity/csg) to new end
   for p=segpartmax to segmeshpartmax+1 step -1
    segmentprofile(segid,p+tempp)=segmentprofile(segid,p)
   next p
   rem now copy accumilated multi-meshes to updated segment profile
   temppmax=tempp : tempp=0
   for p=segmeshpartmax+1 to segmeshpartmax+temppmax
    segmentprofile(segid,p)=tempsegmentprofile(tempp) : inc tempp
   next p
   rem update max values
   segmentprofileheader(segid).partmax=segpartmax+temppmax
   segpartmax=segmentprofileheader(segid).partmax
   originalsegmeshpartmax=segmeshpartmax
   segmentprofileheader(segid).lastmeshmax=segmeshpartmax+temppmax
   segmeshpartmax=segmentprofileheader(segid).lastmeshmax
  endif
 endif
 `
 rem Load textures for segment
 gosub _segment_preloadtextures
 `
 rem Load effect for segment
 gosub _segment_preloadeffects
 `
 rem Build segment in object from segment profile
 if tsegobjpreloaded=0
  segmeshpartmax=segmentprofileheader(segid).lastmeshmax
  tpstart=0 : tpend=segmeshpartmax
  for p=tpstart to tpend
   if object exist(segobj)=0
    make object segobj,segmentprofile(segid,p).meshid,0
   else
    add limb segobj,p,segmentprofile(segid,p).meshid
   endif
   offset limb segobj,p,segmentprofile(segid,p).offx,segmentprofile(segid,p).offy,segmentprofile(segid,p).offz
   rotate limb segobj,p,0,segmentprofile(segid,p).roty,0
  next p
 endif
 `
 rem load csg meshes for scene building
 if tsegobjpreloaded=0
  for tp=0 to segpartmax
   if segmentprofile(segid,tp).partmode=1
    tmeshname$=segmentprofile(segid,tp).meshname$
    if tmeshname$<>""
     tfile$=tmeshname$
     debugfilename(tfile$,"mesh:"+seg$)
     segmentprofile(segid,tp).meshid=loadinternalmesh(tfile$)
     add limb segobj,p,segmentprofile(segid,tp).meshid
     offset limb segobj,p,segmentprofile(segid,tp).offx,segmentprofile(segid,tp).offy,segmentprofile(segid,tp).offz
     rotate limb segobj,p,0,segmentprofile(segid,tp).roty,0
     color limb segobj,p,rgb(0,255,0)
     segmentprofile(segid,tp).actuallimb=p
     inc p
    endif
   endif
  next tp
 else
  rem still need actuallimb data for CSG meshes
  p=segmeshpartmax+1
  for tp=0 to segpartmax
   if segmentprofile(segid,tp).partmode=1
    tmeshname$=segmentprofile(segid,tp).meshname$
    if tmeshname$<>"" then segmentprofile(segid,tp).actuallimb=p : inc p
   endif
  next tp
 endif
 `
 rem Save DBO of segment if not exist
 if segobjusedforfinalgame=0
  if file exist(tsegobjfile$)=0
   save object tsegobjfile$,segobj
  endif
 endif
 `
 rem Texture segment in object from segment profile
 segmeshpartmax=segmentprofileheader(segid).lastmeshmax
 for p=0 to segmeshpartmax
  if segmentprofile(segid,p).effectid=0
   texture limb segobj,p,segmentprofile(segid,p).texid
  else
   if segmentprofile(segid,p).texdid=0
    texture limb segobj,p,segmentprofile(segid,p).texid
   else
    rem multi-layered texture
    texture limb segobj,p,0,segmentprofile(segid,p).texdid
    texture limb segobj,p,1,segmentprofile(segid,p).texdid
    if segmentprofile(segid,p).texsid<>0 then texture limb segobj,p,2,segmentprofile(segid,p).texsid
    if segmentprofile(segid,p).texnid<>0 then texture limb segobj,p,3,segmentprofile(segid,p).texnid
   endif
   rem X10 do NOT apply effect now as universe shader acts on lightmapped FVF only
   rem but the above texture settings will help universe apply
   rem ulluminationmap.fx automatically (hard coded as technique setter at 280307)
   `set limb effect segobj,p,segmentprofile(segid,p).effectid
  endif
 next p
 `
 rem Set any segment transparenct (always uses transparency TGA=alpha)
 set object transparency segobj,1
 `
 rem Hide object away
 position object segobj,100000,100000,100000
 `
 rem Ensure multimeshes are hidden from segment handling (only used in node tree creation)
 if segobjusedforfinalgame=1 and originalsegmeshpartmax<>-1
  segmentprofileheader(segid).lastmeshmax=originalsegmeshpartmax
  segmeshpartmax=originalsegmeshpartmax
 endif
 `
rem no profile exists endif
endif

rem debug info and timestamp (if logged)
debugviewtext(-1,"Built "+seg$+" in "+str$(timer()-mytimer)+"ms")
timestampactivity(0,"Loaded "+str$(segid)+":"+seg$)

return

_segment_cleardata:

rem Default mesh settings
segpartmax=64
for q=0 to segpartmax
 segmentprofile(segid,q).partmode=0
 segmentprofile(segid,q).tex$=""
 segmentprofile(segid,q).texid=0
 segmentprofile(segid,q).texdid=0
 segmentprofile(segid,q).texiid=0
 segmentprofile(segid,q).texnid=0
 segmentprofile(segid,q).texsid=0
` segmentprofile(segid,q).texd$=""
` segmentprofile(segid,q).texn$=""
` segmentprofile(segid,q).texs$=""
 segmentprofile(segid,q).effect$=""
 segmentprofile(segid,q).effectid=0
 segmentprofile(segid,q).csgmesh$=""
 segmentprofile(segid,q).csgmode=0
 segmentprofile(segid,q).csgimmune=0
 segmentprofile(segid,q).transparency=0
next q

rem Default hidden parts
segmentprofile(segid).vis.overlay=0
segmentprofile(segid).vis.f=-1
segmentprofile(segid).vis.r=-1
segmentprofile(segid).vis.wb=-1
segmentprofile(segid).vis.wr=-1
segmentprofile(segid).vis.wf=-1
segmentprofile(segid).vis.wl=-1
segmentprofile(segid).vis.owb=-1
segmentprofile(segid).vis.owr=-1
segmentprofile(segid).vis.owf=-1
segmentprofile(segid).vis.owl=-1
segmentprofile(segid).vis.ctl=-1
segmentprofile(segid).vis.ctr=-1
segmentprofile(segid).vis.cbr=-1
segmentprofile(segid).vis.cbl=-1
segmentprofile(segid).vis.octl=-1
segmentprofile(segid).vis.octr=-1
segmentprofile(segid).vis.ocbr=-1
segmentprofile(segid).vis.ocbl=-1

rem Default blueprint data
segmentprofile(segid).blueprint.mode=0
segmentprofile(segid).blueprint.symbol=0
segmentprofile(segid).blueprint.floorsizey=-1
segmentprofile(segid).blueprint.sidesizex=100
segmentprofile(segid).blueprint.sidesizey=100
segmentprofile(segid).blueprint.sidesizez=100

rem Default properties data
segmentprofile(segid).properties.groundmode=0
segmentprofile(segid).properties.kindof=0

return

_segment_loaddata:

rem Default Segment Data
gosub _segment_cleardata

rem Fill this last if not in filedata
segmentprofileheader(segid).lastmeshmax=-1
segmentprofileheader(segid).preventai=0

rem Ensure segment profile still exists
if file exist(segdir$+seg$)=1

rem Export entity FPE file if flagged
if gexportassets=1
 tthumbbmpfile$=left$(segdir$+seg$,len(segdir$+seg$)-4)+".bmp"
 addfiletocollection(segdir$+seg$) : addfiletocollection(tthumbbmpfile$)
endif

rem Check if binary version of segment profile exists
tprofile$=left$(segdir$+seg$,len(segdir$+seg$)-4)+".bin"
tprofile$=turnfilenameuserlocal(tprofile$)
if isbinaryfileolderthantxtfile(tprofile$,segdir$+seg$)=1 then delete file tprofile$
if file exist(tprofile$)=0

 rem Load Segment Data from file
 dim data$(999)
 load array segdir$+seg$,data$()
 for l=0 to 999
  line$=data$(l)
  if len(line$)>0
   if lower$(left$(line$,4))=";end" then exit
   if left$(line$,1)<>";"
    `
    rem take fieldname and value
    for c=0 to len(line$)
     if mid$(line$,c)="=" then mid=c : exit
    next c
    field$=lower$(removeedgespaces(left$(line$,mid-1)))
    value$=removeedgespaces(right$(line$,len(line$)-mid))
    `
    rem take value 1 and 2 from value
    for c=0 to len(value$)
     if mid$(value$,c)="," then mid=c : exit
    next c
    value1=val(removeedgespaces(left$(value$,mid-1)))
    value2$=removeedgespaces(right$(value$,len(value$)-mid))
    if len(value2$)>0 then value2=val(value2$) else value2=-1
    `
    rem HEADER
    if field$="partmax" then segmentprofileheader(segid).partmax=value1
    if field$="lastmeshmax" then segmentprofileheader(segid).lastmeshmax=value1
    if field$="preventai" then segmentprofileheader(segid).preventai=value1
    `
    rem SEGMENT PARTS
    segpartmax=segmentprofileheader(segid).partmax
    for p=0 to segpartmax
     tryfield$="partmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).partmode=value1
     tryfield$="meshname"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).meshname$=value$
     tryfield$="offx"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).offx=value1
     tryfield$="offy"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).offy=value1
     tryfield$="offz"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).offz=value1
     tryfield$="rotx"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).rotx=value1
     tryfield$="roty"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).roty=value1
     tryfield$="rotz"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).rotz=value1
     tryfield$="texture"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).tex$=value$
`     tryfield$="textured"+str$(p)
`     if field$=tryfield$ then segmentprofile(segid,p).texd$=value$
`     tryfield$="texturen"+str$(p)
`     if field$=tryfield$ then segmentprofile(segid,p).texn$=value$
`     tryfield$="textures"+str$(p)
`     if field$=tryfield$ then segmentprofile(segid,p).texs$=value$
     tryfield$="transparency"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).transparency=value1
     tryfield$="effect"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).effect$=value$
     tryfield$="colmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).colmode=value1
     tryfield$="csgmesh"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).csgmesh$=value$
     tryfield$="csgmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).csgmode=value1
     tryfield$="csgimmune"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).csgimmune=value1
     tryfield$="lightmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).lightmode=value1
     tryfield$="multimeshmode"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).multimeshmode=value1
     tryfield$="materialindex"+str$(p)
     if field$=tryfield$ then segmentprofile(segid,p).material.index=value1
    next p
    `
    rem SEGMENT VISIBILITY
    if field$="visoverlay" then segmentprofile(segid).vis.overlay=value1
    if field$="visfloor" then segmentprofile(segid).vis.f=value1
    if field$="visroof" then segmentprofile(segid).vis.r=value1
    if field$="viswallb" then segmentprofile(segid).vis.wb=value1 : segmentprofile(segid).vis.owb=value2
    if field$="viswallr" then segmentprofile(segid).vis.wr=value1 : segmentprofile(segid).vis.owr=value2
    if field$="viswallf" then segmentprofile(segid).vis.wf=value1 : segmentprofile(segid).vis.owf=value2
    if field$="viswalll" then segmentprofile(segid).vis.wl=value1 : segmentprofile(segid).vis.owl=value2
    if field$="viscornertl" then segmentprofile(segid).vis.ctl=value1 : segmentprofile(segid).vis.octl=value2
    if field$="viscornertr" then segmentprofile(segid).vis.ctr=value1 : segmentprofile(segid).vis.octr=value2
    if field$="viscornerbr" then segmentprofile(segid).vis.cbr=value1 : segmentprofile(segid).vis.ocbr=value2
    if field$="viscornerbl" then segmentprofile(segid).vis.cbl=value1 : segmentprofile(segid).vis.ocbl=value2
    `
    rem SEGMENT BLUEPRINT
    if field$="mode" then segmentprofile(segid).blueprint.mode=value1
    if field$="symbol" then segmentprofile(segid).blueprint.symbol=value1
    if field$="floorsizey" then segmentprofile(segid).blueprint.floorsizey=value1
    if field$="sidesizex" then segmentprofile(segid).blueprint.sidesizex=value1
    if field$="sidesizey" then segmentprofile(segid).blueprint.sidesizey=value1
    if field$="sidesizez" then segmentprofile(segid).blueprint.sidesizez=value1
    `
    rem SEGMENT PROPERTIES
    if field$="groundmode" then segmentprofile(segid).properties.groundmode=value1
    if field$="kindof" then segmentprofile(segid).properties.kindof=value1
    `
   endif
  endif
 next l
 undim data$()
 `
 rem Save segment profile as binary (and strings tagged to end)
 dim temp(64) as segmentprofiletype
 open to write 1,tprofile$
 write file 1,segmentprofileheader(segid).partmax
 write file 1,segmentprofileheader(segid).lastmeshmax
 write file 1,segmentprofileheader(segid).preventai
 segpartmax=segmentprofileheader(segid).partmax
 for p=0 to segpartmax : temp(p)=segmentprofile(segid,p) : next p
 if memblock exist(1)=1 then delete memblock 1
 for p=0 to segpartmax
  temp(p).meshname$=free string()
  temp(p).tex$=free string()
  temp(p).effect$=free string()
  temp(p).csgmesh$=free string()
 next p
 make memblock from array 1,temp(0)
 write memblock 1,1
 for p=0 to segpartmax
  write string 1,segmentprofile(segid,p).meshname$
  write string 1,segmentprofile(segid,p).tex$
  write string 1,segmentprofile(segid,p).effect$
  write string 1,segmentprofile(segid,p).csgmesh$
 next p
 close file 1
 delete memblock 1
 undim temp(0)
 `
else
 `
 rem load binary version of segment profile file
 dim temp(64) as segmentprofiletype
 open to read 1,tprofile$
 read file 1,tval : segmentprofileheader(segid).partmax=tval
 read file 1,tval : segmentprofileheader(segid).lastmeshmax=tval
 read file 1,tval : segmentprofileheader(segid).preventai=tval
 segpartmax=segmentprofileheader(segid).partmax
 read memblock 1,1
 make array from memblock temp(0),1
 for p=0 to segpartmax : segmentprofile(segid,p)=temp(p) : next p
 for p=0 to segpartmax
  read string 1,tstr$ : segmentprofile(segid,p).meshname$=tstr$
  read string 1,tstr$ : segmentprofile(segid,p).tex$=tstr$
`  read string 1,tstr$ : segmentprofile(segid,p).texd$=tstr$
`  read string 1,tstr$ : segmentprofile(segid,p).texn$=tstr$
`  read string 1,tstr$ : segmentprofile(segid,p).texs$=tstr$
  read string 1,tstr$ : segmentprofile(segid,p).effect$=tstr$
  read string 1,tstr$ : segmentprofile(segid,p).csgmesh$=tstr$
 next p
 close file 1
 delete memblock 1
 undim temp(0)
 `
endif

rem If lastmesh not there, use partmax
if segmentprofileheader(segid).lastmeshmax=-1
 segmentprofileheader(segid).lastmeshmax=segmentprofileheader(segid).partmax
endif

rem File not exist endif
else
 rem File not exist, provide debug information
 debugfilename(segdir$+seg$,"")
endif

return

_segment_savedata:

rem Create seg file in string array (segid to savesegfile$)
dim data$(999) : l=-1

rem SEGMENT HEADER
inc l : data$(l)=";Segment Spec"
inc l : data$(l)=""
inc l : data$(l)=";Header"
inc l : data$(l)=""
inc l : data$(l)="partmax = "+str$(segmentprofileheader(segid).partmax)
inc l : data$(l)="lastmeshmax = "+str$(segmentprofileheader(segid).lastmeshmax)
inc l : data$(l)="preventai = "+str$(segmentprofileheader(segid).preventai)

rem SEGMENT PARTS
inc l : data$(l)=""
inc l : data$(l)=";Segment Parts"
inc l : data$(l)=""
for p=0 to segmentprofileheader(segid).partmax
 tryfield$=minstring("partmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).partmode)
 tryfield$=minstring("meshname"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).meshname$
 tryfield$=minstring("offx"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).offx)
 tryfield$=minstring("offy"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).offy)
 tryfield$=minstring("offz"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).offz)
 tryfield$=minstring("rotx"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).rotx)
 tryfield$=minstring("roty"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).roty)
 tryfield$=minstring("rotz"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).rotz)
 tryfield$=minstring("texture"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).tex$
` tryfield$=minstring("textured"+str$(p),15)
` inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).texd$
` tryfield$=minstring("texturen"+str$(p),15)
` inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).texn$
` tryfield$=minstring("textures"+str$(p),15)
` inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).texs$
 tryfield$=minstring("transparency"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).transparency)
 tryfield$=minstring("effect"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).effect$
 tryfield$=minstring("colmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).colmode)
 tryfield$=minstring("csgmesh"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+segmentprofile(segid,p).csgmesh$
 tryfield$=minstring("csgmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).csgmode)
 tryfield$=minstring("csgimmune"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).csgimmune)
 tryfield$=minstring("lightmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).lightmode)
 tryfield$=minstring("multimeshmode"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).multimeshmode)
 tryfield$=minstring("materialindex"+str$(p),15)
 inc l : data$(l)=tryfield$+" = "+str$(segmentprofile(segid,p).material.index)
 inc l : data$(l)=""
 `
 rem Ensure we never run out of array space
 if l>100 then array insert at bottom data$(),11
 `
next p

rem SEGMENT VISIBILITY
inc l : data$(l)=";Segment Visibility"
inc l : data$(l)=""
inc l : data$(l)=minstring("visoverlay",15)+" = "+str$(segmentprofile(segid).vis.overlay)
inc l : data$(l)=minstring("visfloor",15)+" = "+str$(segmentprofile(segid).vis.f)
inc l : data$(l)=minstring("visroof",15)+" = "+str$(segmentprofile(segid).vis.r)
try=segmentprofile(segid).vis.owb : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viswallb",15)+" = "+str$(segmentprofile(segid).vis.wb)+extra$
try=segmentprofile(segid).vis.owr : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viswallr",15)+" = "+str$(segmentprofile(segid).vis.wr)+extra$
try=segmentprofile(segid).vis.owf : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viswallf",15)+" = "+str$(segmentprofile(segid).vis.wf)+extra$
try=segmentprofile(segid).vis.owl : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viswalll",15)+" = "+str$(segmentprofile(segid).vis.wl)+extra$
try=segmentprofile(segid).vis.octl : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viscornertl",15)+" = "+str$(segmentprofile(segid).vis.ctl)+extra$
try=segmentprofile(segid).vis.octr : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viscornertr",15)+" = "+str$(segmentprofile(segid).vis.ctr)+extra$
try=segmentprofile(segid).vis.ocbr : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viscornerbr",15)+" = "+str$(segmentprofile(segid).vis.cbr)+extra$
try=segmentprofile(segid).vis.ocbl : if try<>-1 then extra$=","+str$(try) else extra$=""
inc l : data$(l)=minstring("viscornerbl",15)+" = "+str$(segmentprofile(segid).vis.cbl)+extra$

rem SEGMENT BLUEPRINT
inc l : data$(l)=""
inc l : data$(l)=";Segment Blueprint"
inc l : data$(l)=""
inc l : data$(l)=minstring("mode",15)+" = "+str$(segmentprofile(segid).blueprint.mode)
inc l : data$(l)=minstring("symbol",15)+" = "+str$(segmentprofile(segid).blueprint.symbol)
inc l : data$(l)=minstring("floorsizey",15)+" = "+str$(segmentprofile(segid).blueprint.floorsizey)
inc l : data$(l)=minstring("sidesizex",15)+" = "+str$(segmentprofile(segid).blueprint.sidesizex)
inc l : data$(l)=minstring("sidesizey",15)+" = "+str$(segmentprofile(segid).blueprint.sidesizey)
inc l : data$(l)=minstring("sidesizez",15)+" = "+str$(segmentprofile(segid).blueprint.sidesizez)

rem SEGMENT PROPERTIES
inc l : data$(l)=minstring("groundmode",15)+" = "+str$(segmentprofile(segid).properties.groundmode)
inc l : data$(l)=minstring("kindof",15)+" = "+str$(segmentprofile(segid).properties.kindof)

rem END MARKER
inc l : data$(l)=""
inc l : data$(l)=";end"

rem Shorten array based on L
dim newdata$(l+1) : for t=0 to l : newdata$(t)=data$(t) : next t

rem Delet the short-load BIN and DBO files
tprofile$=left$(savesegfile$,len(savesegfile$)-4)+".bin"
if file exist(tprofile$)=1 then delete file tprofile$
tprofile$=left$(savesegfile$,len(savesegfile$)-4)+".dbo"
rem X10 - 261107 - remove last temp file from program files (DBO)
tprofile$=turnfilenameuserlocal(tprofile$)
if file exist(tprofile$)=1 then delete file tprofile$

rem Save Segment Data to file
if file exist(savesegfile$)=1 then delete file savesegfile$
save array savesegfile$,newdata$()

rem Free usages
undim newdata$()
undim data$()

return

_segment_showallsegmentlimbs:

rem segment and segment rotayion used
seg=mapselection : segmaprot=maprotate-maporient
if segmaprot<0 then inc segmaprot,4

rem force show all limbs for overlay
for tl=1 to 99
 if limb exist(obj,tl)=1
  show limb obj,tl
 endif
next tl

rem rotate object ro rotation
yrotate object obj,maporient*90

`rem Set any segment transparenct - many transparency values - use profileobj
`set object transparency obj,segmentprofile(seg).transparency

return

_segment_customisesinglesegment:

rem segment and segment rotayion used
seg=mapselection : segmaprot=maprotate-maporient
if segmaprot<0 then inc segmaprot,4

rem scale any walls to scaler value (if any)
if segmentprofile(seg).blueprint.sidesizex>100
 if segmentprofile(seg).vis.wb<>-1
  if (mapscaler && %0001)
   show limb obj,segmentprofile(seg).vis.wb
   if segmentprofile(seg).vis.owb<>-1 then show limb obj,segmentprofile(seg).vis.owb
  else
   hide limb obj,segmentprofile(seg).vis.wb
   if segmentprofile(seg).vis.owb<>-1 then hide limb obj,segmentprofile(seg).vis.owb
  endif
 endif
 if segmentprofile(seg).vis.wr<>-1
  if (mapscaler && %0010)
   show limb obj,segmentprofile(seg).vis.wr
   if segmentprofile(seg).vis.owr<>-1 then show limb obj,segmentprofile(seg).vis.owr
  else
   hide limb obj,segmentprofile(seg).vis.wr
   if segmentprofile(seg).vis.owr<>-1 then hide limb obj,segmentprofile(seg).vis.owr
  endif
 endif
 if segmentprofile(seg).vis.wf<>-1
  if (mapscaler && %0100)
   show limb obj,segmentprofile(seg).vis.wf
   if segmentprofile(seg).vis.owf<>-1 then show limb obj,segmentprofile(seg).vis.owf
  else
   hide limb obj,segmentprofile(seg).vis.wf
   if segmentprofile(seg).vis.owf<>-1 then hide limb obj,segmentprofile(seg).vis.owf
  endif
 endif
 if segmentprofile(seg).vis.wl<>-1
  if (mapscaler && %1000)
   show limb obj,segmentprofile(seg).vis.wl
   if segmentprofile(seg).vis.owl<>-1 then show limb obj,segmentprofile(seg).vis.owl
  else
   hide limb obj,segmentprofile(seg).vis.wl
   if segmentprofile(seg).vis.owl<>-1 then hide limb obj,segmentprofile(seg).vis.owl
  endif
 endif
else
 if segmentprofile(seg).vis.wb<>-1
  show limb obj,segmentprofile(seg).vis.wb
  if segmentprofile(seg).vis.owb<>-1 then show limb obj,segmentprofile(seg).vis.owb
 endif
 if segmentprofile(seg).vis.wr<>-1
  show limb obj,segmentprofile(seg).vis.wr
  if segmentprofile(seg).vis.owr<>-1 then show limb obj,segmentprofile(seg).vis.owr
 endif
 if segmentprofile(seg).vis.wf<>-1
  show limb obj,segmentprofile(seg).vis.wf
  if segmentprofile(seg).vis.owf<>-1 then show limb obj,segmentprofile(seg).vis.owf
 endif
 if segmentprofile(seg).vis.wl<>-1
  show limb obj,segmentprofile(seg).vis.wl
  if segmentprofile(seg).vis.owl<>-1 then show limb obj,segmentprofile(seg).vis.owl
 endif
endif

rem default limbs states
if segmentprofile(seg).vis.f<>-1 then show limb obj,segmentprofile(seg).vis.f
if segmentprofile(seg).vis.r<>-1 then show limb obj,segmentprofile(seg).vis.r
if segmentprofile(seg).vis.ctl<>-1 then hide limb obj,segmentprofile(seg).vis.ctl
if segmentprofile(seg).vis.ctr<>-1 then hide limb obj,segmentprofile(seg).vis.ctr
if segmentprofile(seg).vis.cbr<>-1 then hide limb obj,segmentprofile(seg).vis.cbr
if segmentprofile(seg).vis.cbl<>-1 then hide limb obj,segmentprofile(seg).vis.cbl
if segmentprofile(seg).vis.octl<>-1 then hide limb obj,segmentprofile(seg).vis.octl
if segmentprofile(seg).vis.octr<>-1 then hide limb obj,segmentprofile(seg).vis.octr
if segmentprofile(seg).vis.ocbr<>-1 then hide limb obj,segmentprofile(seg).vis.ocbr
if segmentprofile(seg).vis.ocbl<>-1 then hide limb obj,segmentprofile(seg).vis.ocbl

rem apply side-maprotation for walls
twb=segmentprofile(seg).vis.wb : twr=segmentprofile(seg).vis.wr
twf=segmentprofile(seg).vis.wf : twl=segmentprofile(seg).vis.wl
towb=segmentprofile(seg).vis.owb : towr=segmentprofile(seg).vis.owr
towf=segmentprofile(seg).vis.owf : towl=segmentprofile(seg).vis.owl
if segmaprot=1
 twb=segmentprofile(seg).vis.wl :  twr=segmentprofile(seg).vis.wb
 twf=segmentprofile(seg).vis.wr :  twl=segmentprofile(seg).vis.wf
 towb=segmentprofile(seg).vis.owl :  towr=segmentprofile(seg).vis.owb
 towf=segmentprofile(seg).vis.owr :  towl=segmentprofile(seg).vis.owf
endif
if segmaprot=2
 twb=segmentprofile(seg).vis.wf :  twr=segmentprofile(seg).vis.wl
 twf=segmentprofile(seg).vis.wb :  twl=segmentprofile(seg).vis.wr
 towb=segmentprofile(seg).vis.owf :  towr=segmentprofile(seg).vis.owl
 towf=segmentprofile(seg).vis.owb :  towl=segmentprofile(seg).vis.owr
endif
if segmaprot=3
 twb=segmentprofile(seg).vis.wr :  twr=segmentprofile(seg).vis.wf
 twf=segmentprofile(seg).vis.wl :  twl=segmentprofile(seg).vis.wb
 towb=segmentprofile(seg).vis.owr :  towr=segmentprofile(seg).vis.owf
 towf=segmentprofile(seg).vis.owl :  towl=segmentprofile(seg).vis.owb
endif

rem eliminate external walls if blocked
if maprotate=0
 if towf<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty-1)<=1 then hide limb obj,towf
 if towb<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty+1)<=1 then hide limb obj,towb
 if towl<>-1 and getgroundmodefrommap(mapatl,mapatx-1,mapaty)<=1 then hide limb obj,towl
 if towr<>-1 and getgroundmodefrommap(mapatl,mapatx+1,mapaty)<=1 then hide limb obj,towr
endif
if maprotate=1
 if towf<>-1 and getgroundmodefrommap(mapatl,mapatx+1,mapaty)<=1 then hide limb obj,towf
 if towb<>-1 and getgroundmodefrommap(mapatl,mapatx-1,mapaty)<=1 then hide limb obj,towb
 if towl<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty-1)<=1 then hide limb obj,towl
 if towr<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty+1)<=1 then hide limb obj,towr
endif
if maprotate=2
 if towf<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty+1)<=1 then hide limb obj,towf
 if towb<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty-1)<=1 then hide limb obj,towb
 if towl<>-1 and getgroundmodefrommap(mapatl,mapatx+1,mapaty)<=1 then hide limb obj,towl
 if towr<>-1 and getgroundmodefrommap(mapatl,mapatx-1,mapaty)<=1 then hide limb obj,towr
endif
if maprotate=3
 if towf<>-1 and getgroundmodefrommap(mapatl,mapatx-1,mapaty)<=1 then hide limb obj,towf
 if towb<>-1 and getgroundmodefrommap(mapatl,mapatx+1,mapaty)<=1 then hide limb obj,towb
 if towl<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty+1)<=1 then hide limb obj,towl
 if towr<>-1 and getgroundmodefrommap(mapatl,mapatx,mapaty-1)<=1 then hide limb obj,towr
endif

rem inner wall to hide
if twr<>-1
 if maptile>=2 then hide limb obj,twr
endif
if twb<>-1
 if maptile=3 or maptile>=5 then hide limb obj,twb
endif
if twl<>-1
 if maptile>=4 and maptile<=14 then hide limb obj,twl
endif
if twf<>-1
 if maptile>=6 and maptile<=11 then hide limb obj,twf
endif

rem outer wall to hide
if towr<>-1
 if maptile>=2 then hide limb obj,towr
endif
if towb<>-1
 if maptile=3 or maptile>=5 then hide limb obj,towb
endif
if towl<>-1
 if maptile>=4 and maptile<=14 then hide limb obj,towl
endif
if towf<>-1
 if maptile>=6 and maptile<=11 then hide limb obj,towf
endif

rem symbol no floor hides floor/roof
if mapsymbol=1
 if segmentprofile(seg).vis.f<>-1 then hide limb obj,segmentprofile(seg).vis.f
 if segmentprofile(seg).vis.r<>-1 then hide limb obj,segmentprofile(seg).vis.r
endif

rem calculate actual corner before whole seg is rotated
ttoctl=segmentprofile(seg).vis.octl
ttoctr=segmentprofile(seg).vis.octr
ttocbr=segmentprofile(seg).vis.ocbr
ttocbl=segmentprofile(seg).vis.ocbl
toctl=-1 : toctr=-1 : tocbr=-1 : tocbl=-1
if segmaprot=0
 tctl=segmentprofile(seg).vis.ctl
 tctr=segmentprofile(seg).vis.ctr
 tcbr=segmentprofile(seg).vis.cbr
 tcbl=segmentprofile(seg).vis.cbl
 toctl=ttoctl
 toctr=ttoctr
 tocbr=ttocbr
 tocbl=ttocbl
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then toctl=segmentprofile(seg).vis.octl
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then toctr=segmentprofile(seg).vis.octr
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then tocbr=segmentprofile(seg).vis.ocbr
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then tocbl=segmentprofile(seg).vis.ocbl
endif
if segmaprot=1
 tctl=segmentprofile(seg).vis.ctr
 tctr=segmentprofile(seg).vis.cbr
 tcbr=segmentprofile(seg).vis.cbl
 tcbl=segmentprofile(seg).vis.ctl
 toctl=ttoctr
 toctr=ttocbr
 tocbr=ttocbl
 tocbl=ttoctl
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then toctl=segmentprofile(seg).vis.octr
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then toctr=segmentprofile(seg).vis.ocbr
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then tocbr=segmentprofile(seg).vis.ocbl
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then tocbl=segmentprofile(seg).vis.octl
endif
if segmaprot=2
 tctl=segmentprofile(seg).vis.cbr
 tctr=segmentprofile(seg).vis.cbl
 tcbr=segmentprofile(seg).vis.ctl
 tcbl=segmentprofile(seg).vis.ctr
 toctl=ttocbr
 toctr=ttocbl
 tocbr=ttoctl
 tocbl=ttoctr
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then toctl=segmentprofile(seg).vis.ocbr
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then toctr=segmentprofile(seg).vis.ocbl
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then tocbr=segmentprofile(seg).vis.octl
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then tocbl=segmentprofile(seg).vis.octr
endif
if segmaprot=3
 tctl=segmentprofile(seg).vis.cbl
 tctr=segmentprofile(seg).vis.ctl
 tcbr=segmentprofile(seg).vis.ctr
 tcbl=segmentprofile(seg).vis.cbr
 toctl=ttocbl
 toctr=ttoctl
 tocbr=ttoctr
 tocbl=ttocbr
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then toctl=segmentprofile(seg).vis.ocbl
` if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then toctr=segmentprofile(seg).vis.octl
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then tocbr=segmentprofile(seg).vis.octr
` if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then tocbl=segmentprofile(seg).vis.ocbr
endif

rem remove external corners if not needed
ttoctl=-1 : ttoctr=-1 : ttocbr=-1 : ttocbl=-1
if maprotate=0
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then ttoctl=toctl
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then ttoctr=toctr
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then ttocbr=tocbr
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then ttocbl=tocbl
endif
if maprotate=1
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then ttoctl=toctl
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then ttoctr=toctr
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then ttocbr=tocbr
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then ttocbl=tocbl
endif
if maprotate=2
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then ttoctl=toctl
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then ttoctr=toctr
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then ttocbr=tocbr
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then ttocbl=tocbl
endif
if maprotate=3
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty+1)>=2 then ttoctl=toctl
 if getgroundmodefrommap(mapatl,mapatx-1,mapaty-1)>=2 then ttoctr=toctr
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty-1)>=2 then ttocbr=tocbr
 if getgroundmodefrommap(mapatl,mapatx+1,mapaty+1)>=2 then ttocbl=tocbl
endif

rem inner corner limbs to show
if tctl<>-1
 if maptile>=7 and maptile<=11 then show limb obj,tctl
endif
if tctr<>-1
 if maptile=8 or maptile=10 or maptile=11 then show limb obj,tctr
endif
if tcbr<>-1
 if maptile=9 or maptile=10 or maptile=11 or maptile>=13 then show limb obj,tcbr
endif
if tcbl<>-1
 if maptile=11 or maptile=12 or maptile=14 then show limb obj,tcbl
endif

rem outer corner limbs to show
if ttoctl<>-1
 if maptile=1 then show limb obj,ttoctl
 if maptile=2 then show limb obj,ttoctl
 if maptile=3 then show limb obj,ttoctl
 if maptile=15 then show limb obj,ttoctl
endif
if ttoctr<>-1
 if maptile=1 then show limb obj,ttoctr
endif
if ttocbr<>-1
 if maptile=1 then show limb obj,ttocbr
endif
if ttocbl<>-1
 if maptile=1 then show limb obj,ttocbl
 if maptile=2 then show limb obj,ttocbl
endif

rem rotate object ro rotation
yrotate object obj,maporient*90

return

`
` Special Function for finding GROUNDMODE from NEIGHBOR MAP TILE (external wall removal)
`

function getgroundmodefrommap(mapatl,mapatx,mapaty)
 mapground=3
 if mapatx>=0
  if mapaty>=0
   if mapatx<=49
    if mapaty<=49
     mapid=map(mapatl,mapatx,mapaty)
     if mapid<>0
      mapground = ( mapid && %00000000000000001100000000000000 ) >> 14
     else
      mapground = 3
     endif
    endif
   endif
  endif
 endif
endfunction mapground

_segment_scanfornewsegments:

rem Scan for segments
segdir$="segments\"
empty array filelist$()
buildfilelist(segdir$,"")

rem If segments exist
if array count(filelist$())>0
 for chkfile=0 to array count(filelist$())
  `
  rem Segment name from folder
  seg$=filelist$(chkfile)
  if right$(seg$,4)=".fps"
  `
  rem Check segment exists in bank
  tokay=1
  if segidmaster>0
   for segid=1 to segidmaster
    if selectionbank$(segid)=seg$ then tokay=0
   next segid
  endif
  if tokay=1
   `
   rem Find Free Segment Index
   freesegid=-1
   if segidmaster>0
    for segid=1 to segidmaster
     if segmentprofileheader(segid).partmax=-1 then freesegid=segid : exit
    next segid
   endif
   `
   rem New Segment or Free One
   if freesegid=-1
    inc segidmaster : gosub _segment_validatearraysize
    segid=segidmaster
   else
    segid=freesegid
   endif
   `
   rem Extract firstdir and path from seg$
   segcategory$=getfirstdir(seg$)
   segpath$=getseconddir(seg$)
   `
   rem Load Segment
   selectionbank$(segid)=seg$
   gosub _segment_load
   `
  endif
  `
  endif
 next chkfile
endif

return

_segment_addtoworkspace:

rem If type valid
segnewloaded=0
if right$(seg$,4)=".fps"
 `
 rem Check segment exists in bank
 tokay=1
 if segidmaster>0
  for segid=1 to segidmaster
   if selectionbank$(segid)=seg$ then tokay=0 : tfoundid=segid : exit
  next segid
 endif
 if tokay=1
  `
  rem Find Free Segment Index
  freesegid=-1
  if segidmaster>0
   for segid=1 to segidmaster
    if segmentprofileheader(segid).partmax=-1 then freesegid=segid : exit
   next segid
  endif
  `
  rem New Segment or Free One
  if freesegid=-1
   inc segidmaster : gosub _segment_validatearraysize
   segid=segidmaster
   segnewloaded=1
  else
   segid=freesegid
  endif
  `
  rem Extract firstdir and path from seg$
  segcategory$=getfirstdir(seg$)
  segpath$=getseconddir(seg$)
  `
  rem Load Segment
  selectionbank$(segid)=seg$
  gosub _segment_load
  `
  rem Localization Extra
  if localdesc$<>""
   selectionbanklocal$(segid)=localdesc$
  endif
  `
 else
  `
  rem already got, assign ID from existing
  segid=tfoundid
  `
 endif
 `
endif

return

_segment_addtoselection:

rem Load segment from file requester
set dir currentsegdir$
seg$=browseropen$(6)
segdir$="segments\"
seg$=right$(seg$,len(seg$)-len(rootdir$+segdir$))
currentsegdir$=get dir$()
set dir rootdir$

rem Add selected to workspace selection
gosub _segment_addtoworkspace

return

_segment_createnewselection:

rem Create new segment using SEGEDIT (indi-tool)
set dir currentsegdir$
segedit$(1)
set dir rootdir$

return

rem Add selected to workspace selection
_prefab_addtoworkspace:

rem If type valid
prenewloaded=0
if lower$(right$(prefab$,4))=".fpp"
 `
 rem Check prefab exists in bank
 tokay=1
 if preidmaster>0
  for preid=1 to preidmaster
   if prefabbank$(preid)=prefab$ then tokay=0 : exit
  next preid
 endif
 if tokay=1
  `
  rem Find Free prefab Index
  freepreid=-1
  if preidmaster>0
   for preid=1 to preidmaster
    if prefabbank$(preid)="" then freepreid=preid : exit
   next preid
  endif
  `
  rem New prefab or Free One
  if freepreid=-1
   inc preidmaster
   if preidmaster>=100
    dim prefabbank$(preidmaster)
    dim prefabbanklocal$(preidmaster)
   endif
   preid=preidmaster
  else
   preid=freepreid
  endif
  `
  rem Extract firstdir and path from prefab$
  preategory$=getfirstdir(prefab$)
  prepath$=getseconddir(prefab$)
  `
  rem Load Prefab
  prefabbank$(preid)=prefab$
  prenewloaded=1
  `
  rem Localization Extra
  if localdesc$<>""
   prefabbanklocal$(preid)=localdesc$
  endif
  `
 endif
 `
endif

return

_prefab_addtoselection:

rem Load segment from file requester
set dir currentpredir$
prefab$=browseropen$(7)
predir$="prefabs\"
prefab$=right$(prefab$,len(prefab$)-len(rootdir$+predir$))
currentpredir$=get dir$()
set dir rootdir$

rem Add selected to workspace selection
gosub _prefab_addtoworkspace

return

