rem
rem UNIVERSE
rem

_universe_construct_skip:
 `
 rem compare this universe with last saved universe 
 rem return flag as true if the universe is the same
 universeconstructskip=1
 `
 rem if no old file, no old data so no skip
 if file exist(myownrootdir$+"levelbank\testlevel\old.dat")=0 then universeconstructskip=0 : return
 `
 rem check static entities/lights
 open to read 1,myownrootdir$+"levelbank\testlevel\old.dat"
  read file 1,oldolaylistmax
  read file 1,oldentityelementlist
  dim oldentityelement(oldentityelementlist) as entitytype 
  for i=1 to oldentityelementlist
   read file 1,e
   if e>0
    read float 1,a# : oldentityelement(e).x=a#
    read float 1,a# : oldentityelement(e).y=a#
    read float 1,a# : oldentityelement(e).z=a#
    read float 1,a# : oldentityelement(e).rx=a#
    read float 1,a# : oldentityelement(e).ry=a#
    read float 1,a# : oldentityelement(e).rz=a#
    read float 1,a# : oldentityelement(e).eleprof.light.range=a#
    read file 1,tcolr
    read file 1,tcolg
    read file 1,tcolb
    tcol=rgb(tcolr,tcolg,tcolb)
    oldentityelement(e).eleprof.light.color=tcol
    rem current entity must be static, and be identical to old otherwise cannot skip
    if e<=entityelementlist
     if entityelement(e).staticflag=1
      if entityelement(e).x<>oldentityelement(e).x then universeconstructskip=0
      if entityelement(e).y<>oldentityelement(e).y then universeconstructskip=0
      if entityelement(e).z<>oldentityelement(e).z then universeconstructskip=0
      if entityelement(e).rx<>oldentityelement(e).rx then universeconstructskip=0
      if entityelement(e).ry<>oldentityelement(e).ry then universeconstructskip=0
      if entityelement(e).rz<>oldentityelement(e).rz then universeconstructskip=0
      if entityelement(e).eleprof.light.range<>oldentityelement(e).eleprof.light.range then universeconstructskip=0
      if entityelement(e).eleprof.light.color<>oldentityelement(e).eleprof.light.color then universeconstructskip=0
     else
      tuentid=entityelement(e).bankindex
      if entityprofile(tuentid).ismarker<>2
       universeconstructskip=0 : i=oldentityelementlist
      endif
     endif
    else
     universeconstructskip=0 : i=oldentityelementlist
    endif
   endif
  next i
  if universeconstructskip=1
   if entityelementlist>oldentityelementlist
    for e=i to entityelementlist
     rem any new static entities must be used in new construction
     if entityelement(e).staticflag=1
      universeconstructskip=0
     endif
     rem any new light entities must be used in new construction
     tuentid=entityelement(e).bankindex
     if entityprofile(tuentid).ismarker=2
      universeconstructskip=0
     endif
    next e
   endif
  endif
 close file 1  
 `
 rem check map and overlays
 if universeconstructskip=1
  dim oldmap(layermax,maxx,maxy)
  dim oldolaylist(oldolaylistmax,50) as DWORD
  load array myownrootdir$+"levelbank\testlevel\oldmap.dat",oldmap()
  load array myownrootdir$+"levelbank\testlevel\oldolaylist.dat",oldolaylist()
  for lay=0 to layermax
   for y=0 to maxy-1
    for x=0 to maxx-1
     for olay=0 to 1
      if olay=0 then tolaymax=0
      if olay=1
       tolaymax=0 : olayindex=mapolay(lay,x,y)
       while olaylist(olayindex,tolaymax)>0 and tolaymax<50 : inc tolaymax : endwhile
       dec tolaymax
      endif
      if tolaymax>=0
       for olayti=0 to tolaymax
        if olay=0 then mapid=map(lay,x,y)
        if olay=1 then mapid=olaylist(olayindex,olayti)
        if olay=0 then oldmapid=oldmap(lay,x,y)
        if olay=1 then oldmapid=oldolaylist(olayindex,olayti)
        if mapid<>oldmapid
         rem there is a difference, must not skip construction
         universeconstructskip=0
        endif
       next olayti
      endif
     next olay
    next x
   next y
  next lay
 endif
 `
 rem free usages
 undim oldentityelement()
 undim oldmap()
 undim oldolaylist()
 `
return

_universe_saveforskipcheck:
 `
 rem save map, overlay and static entity info
 rem for above check as to whether to skip universe construction
 tfile$=myownrootdir$+"levelbank\testlevel\old.dat" : if file exist(tfile$)=1 then delete file tfile$
 open to write 1,tfile$
  write file 1,olaylistmax
  write file 1,entityelementlist
  for e=1 to entityelementlist
   tuentid=entityelement(e).bankindex
   if entityelement(e).staticflag=1 or entityprofile(tuentid).ismarker=2
    write file 1,e
    write float 1,entityelement(e).x
    write float 1,entityelement(e).y
    write float 1,entityelement(e).z
    write float 1,entityelement(e).rx
    write float 1,entityelement(e).ry
    write float 1,entityelement(e).rz
    write float 1,entityelement(e).eleprof.light.range
    write file 1,rgbr(entityelement(e).eleprof.light.color)
    write file 1,rgbg(entityelement(e).eleprof.light.color)
    write file 1,rgbb(entityelement(e).eleprof.light.color)    
   else
    write file 1,0
   endif
  next e
 close file 1
 tfile$=myownrootdir$+"levelbank\testlevel\oldmap.dat" : if file exist(tfile$)=1 then delete file tfile$
 save array tfile$,map()
 tfile$=myownrootdir$+"levelbank\testlevel\oldolaylist.dat" : if file exist(tfile$)=1 then delete file tfile$
 save array tfile$,olaylist()
 `
return

_universe_construct:

rem Set size of possible node tree (cubeshaped)
set static universe maxx*100,(layermax+1)*100,maxy*100

rem Reset any lighting information
delete light map lights

rem Some global statistics for game world
totalnumberofcollisionboxes=0

rem Lightmapping
activatelightmapping=glightmappingstate
if segobjusedformapeditor=1 then activatelightmapping=0

rem Shadow maps for processing data
dim mapobj(layermax,maxx,maxy)
dim mapcsg(layermax,maxx,maxy)

rem Free old objects if any
if lastsegobj>=segobjstart then delete objects segobjstart,lastsegobj

rem Construct scene
csgpassmax=3
staticlightcount=0
for csgpass=1 to csgpassmax
`
rem debug info
if csgpass=1 then debugviewtext(200,strarr$(155))
if csgpass=2 then debugviewtext(210,strarr$(156))
if csgpass=3 then debugviewtext(220,strarr$(157))
`
rem Reset workvars
segobj=segobjstart
highesty=0
`
rem Feature to fill void with floor/landscape/horizon
if 1 and segobjusedformapeditor=0
 `
 rem Fill void tiles with floor
 if csgpass=1
  `
  rem if default floor switched on
  if gusefloorstate=1
   `
   `rem get map tile ID
   `mapid=map(0,0,0) : mapselection=1
   `if mapid>0 then gosub _gridedit_getmapvalues
   `
   rem void tile filler (automatic floor is at layer zero)
   mapselection=1
   mapscaler = 0 : mapground = 3 : maprotate = 0
   maporient = 0 : mapsymbol = 0 : maptile = 0
   gosub _universe_makemapvalues
   `
   rem get map tile ID to see if we need to override
   rem Ensure full segment info is used (otherwise floor of room becomes rooms everywhere)
   if map(0,0,0)>0 then mapid=map(0,0,0) : gosub _gridedit_getmapvalues
   `   
   floormapid=mapid : lay=0
   for y=0 to maxy-1
    for x=0 to maxx-1
     if map(lay,x,y)=0
      map(lay,x,y)=mapid
     endif
    next x
   next y
   `
   rem create horizonplanes
   gosub _universe_createhorizonplanes
   `
  endif
  `
 endif
 if csgpass>1
  rem Skip horizon objects
  if gusefloorstate=1
   inc segobj,4
  endif
 endif
 `
endif
`
rem X10 cloning timers
clonetimerlast as DWORD : clonetimerlast=0
clonetimercount as DWORD : clonetimercount=0
clonetimerrest as DWORD : clonetimerrest=0
`
rem Start traversal through universe tiles
for lay=0 to layermax
 for y=0 to maxy-1
  for x=0 to maxx-1
   for olay=0 to 1
    `
    rem MAP and MAPOLAY
    if olay=0 then tolaymax=0
    if olay=1
     tolaymax=0 : olayindex=mapolay(lay,x,y)
     while olaylist(olayindex,tolaymax)>0 and tolaymax<50 : inc tolaymax : endwhile
     dec tolaymax
    endif
    if tolaymax>=0
     `
     for olayti=0 to tolaymax
      if olay=0 then mapid=map(lay,x,y)
      if olay=1 then mapid=olaylist(olayindex,olayti)
      if mapid<>0
       `
       gosub _gridedit_getmapvalues
       if object exist(selectionbankoffset+mapselection)=1
        `
        rem Set segment identity
        seg=mapselection
        `
        rem Pass 1 - Create
        if csgpass=1
         `
         rem report progress
         if treportprogressonlayer<>lay or treportprogressonlayerslice<>y
          tproggy#=(9.0/layermax)*lay
          tdebugtiming$="CLONETIME:"+str$(clonetimercount/1000)+" REMAINDER:"+str$(clonetimerrest/1000)
          debugviewtext(201+tproggy#,"["+str$(csgpass)+"] "+strarr$(158)+str$(lay)+strarr$(159)+str$(y)+"..."+tdebugtiming$)
          treportprogressonlayer=lay : treportprogressonlayerslice=y
          clonetimercount=0
          clonetimerrest=0
         endif
         `
         rem check if segment uses CSG, in which case clone not instance
         tusingcsgforthisegment=0
         for tp=segmentprofileheader(seg).lastmeshmax to segmentprofileheader(seg).partmax
          if segmentprofile(seg,tp).partmode=1
           if segmentprofile(seg,tp).csgmode=0
            tusingcsgforthisegment=1
           endif
          endif
         next tp
         `
         rem clone for manipulation of segment
         rem 100807 - added new cloning mode for fast cloning suited to this process (,3)
         inc clonetimerrest,(perftimer()-clonetimerlast)
         clonetimerlast=perftimer()
         if ghsrmode=1
          clone object segobj,selectionbankoffset+mapselection,3
         else
          rem when instance, transparent details come from origin (not for mapeditor preview though)
          if segobjusedformapeditor=0
           set object transparency selectionbankoffset+mapselection,4
          endif
          clone object segobj,selectionbankoffset+mapselection,3
         endif
         inc clonetimercount,(perftimer()-clonetimerlast)
         clonetimerlast=perftimer()
         `
         rem setup segment for universe conversion
         set object collision off segobj
         position object segobj,50+(x*100),50+(lay*100),((y*-100)-50)
         if (100+(lay*100))>highesty then highesty=(100+(lay*100))
         mapatl=lay : mapatx=x : mapaty=y
         obj=segobj : gosub _segment_customisesinglesegment
         if olay=0 then mapobj(lay,x,y)=obj
         `
         rem initially hide all non-basic meshes
         for tlimb=segmentprofileheader(seg).lastmeshmax+1 to segmentprofileheader(seg).partmax
          if limb exist(segobj,tlimb)=1
           hide limb segobj,tlimb
          endif
         next tlimb
         `
         rem show multimesh replacements, hide base mesh in those cases
         for tlimb=0 to segmentprofileheader(seg).lastmeshmax
          tmultimesh=segmentprofile(seg,tlimb).multimeshmode
          if tmultimesh=1
           if limb visible(segobj,tlimb)=1
            if segmentprofile(seg,tlimb).multimeshstart>0
`             r=0 : rem rnd(2) hmm why did I rem this out :)
             r=rnd(2)
             if r=0 then tlimbchange=tlimb
             if r=1 then tlimbchange=segmentprofile(seg,tlimb).multimeshstart+0
             if r=2 then tlimbchange=segmentprofile(seg,tlimb).multimeshstart+1
             if limb exist(segobj,tlimbchange)=0 then tlimbchange=tlimb
             hide limb segobj,tlimb : show limb segobj,tlimbchange
            endif
           endif
          endif
         next tlimb
         `
        endif
        `
        rem Pass 2 - Add CSG, Lights and Entities
        if csgpass=2
         `
         rem add any csg punch references
         for tp=segmentprofileheader(seg).lastmeshmax to segmentprofileheader(seg).partmax
          if segmentprofile(seg,tp).partmode=1
           if segmentprofile(seg,tp).csgmode=0
            rem check boundbox of CSGPUNCH with surrounding segments
            for surrl=lay-1 to lay+1
             for surry=y-1 to y+1
              for surrx=x-1 to x+1
               if surrl>=0 and surrl<layermax
                if surry>=0 and surry<40
                 if surrx>=0 and surrx<40
                   `
                   rem for each segment-limb (not this seg though)
                   mapid=map(surrl,surrx,surry)
                   if mapid<>0
                    gosub _gridedit_getmapvalues
                    if object exist(selectionbankoffset+mapselection)=1
                     surrseg=mapselection
                     surrobj=mapobj(surrl,surrx,surry)
                     for surrlimb=0 to segmentprofileheader(surrseg).lastmeshmax
                      rem only non-immune meshes
                      if segmentprofile(surrseg,surrlimb).csgimmune=0
                       rem first ensure meshes affected by a CSG must use base mesh, not multimesh
                       if segmentprofile(surrseg,surrlimb).multimeshstart>0
                        if limb visible(surrobj,segmentprofile(surrseg,surrlimb).multimeshstart+0)=1 or limb visible(surrobj,segmentprofile(surrseg,surrlimb).multimeshstart+1)=1
                         show limb surrobj,surrlimb
                         hide limb surrobj,segmentprofile(surrseg,surrlimb).multimeshstart+0
                         hide limb surrobj,segmentprofile(surrseg,surrlimb).multimeshstart+1
                        endif
                       endif
                       rem if punch limb collides with surrounding segment-limb
                       tpactual=segmentprofile(seg,tp).actuallimb
                       if limb collision(segobj,tpactual,surrobj,surrlimb)=1 and limb visible(surrobj,surrlimb)=1
                        `
                        rem report progress
                        tproggy#=(9.0/layermax)*lay
                        debugviewtext(211+tproggy#,strarr$(160)+str$(lay)+","+str$(x)+","+str$(y))
                        `
                        rem make new limb
                        ttempobj1=lastsegobj+0
                        ttempobj2=lastsegobj+1
                        if object exist(ttempobj1)=1 then delete object ttempobj1
                        if object exist(ttempobj2)=1 then delete object ttempobj2
                        make object from limb ttempobj1,segobj,tpactual
                        make object from limb ttempobj2,surrobj,surrlimb
                        `
                        rem recreate object from CSG PUNCH MESH
                        lgx#=limb position x(segobj,tpactual)
                        lgy#=limb position y(segobj,tpactual)
                        lgz#=limb position z(segobj,tpactual)
                        position object ttempobj1,lgx#,lgy#,lgz#
                        texture object ttempobj1,segmentprofile(seg,tpactual).texid
                        `
                        rem recreate object from DEST NEIGHBOR MESH
                        lgx#=limb position x(surrobj,surrlimb)
                        lgy#=limb position y(surrobj,surrlimb)
                        lgz#=limb position z(surrobj,surrlimb)
                        position object ttempobj2,lgx#,lgy#,lgz#
                        texture object ttempobj2,segmentprofile(surrseg,surrlimb).texid
                        `
                        rem perform CSG Punch on neighboring limb now
                        perform csg difference ttempobj2,ttempobj1
                        `
`                        rem CSG meshes must cast shadows (unless flagged as off)
`                        if glightshadowsstate=1 then tshadow=3 else tshadow=0

`                        rem scene scadow casting disabled (for performance)
`                        if gdynamicshadowsstate=1 then tshadow=2
                        `
                        rem reapply effect if have one
                        `x10 applies the universe effect later on, after construction!
                        `if segmentprofile(surrseg,surrlimb).effectid>0
                        ` texture object ttempobj2,0,segmentprofile(surrseg,surrlimb).texdid
                        ` if segmentprofile(surrseg,surrlimb).texiid<>0 then texture object ttempobj2,1,segmentprofile(surrseg,surrlimb).texiid
                        ` if segmentprofile(surrseg,surrlimb).texnid<>0 then texture object ttempobj2,2,segmentprofile(surrseg,surrlimb).texnid
                        ` if segmentprofile(surrseg,surrlimb).texsid<>0 then texture object ttempobj2,3,segmentprofile(surrseg,surrlimb).texsid
                        ` set object effect ttempobj2,segmentprofile(surrseg,surrlimb).effectid
                        `endif
                        `
                        rem add new limb to node tree now (polycol after csg)
                        tarbvalue=segmentprofile(surrseg,surrlimb).material.index
                        if tarbvalue=0 then tarbvalue=1
                        set object transparency ttempobj2,4
                        make static object ttempobj2,0,tarbvalue,tshadow,1
                        `
                        rem remove temp object
                        delete object ttempobj1
                        delete object ttempobj2
                        `
                        rem hide the segment-limb
                        hide limb surrobj,surrlimb
                        `
                       endif
                      endif
                     next surrlimb
                    endif
                   endif
                   `
                 endif
                endif
               endif
              next surrx
             next surry
            next surrl
           endif
          endif
         next tp
         `
         rem restore map data
         if olay=0 then mapid=map(lay,x,y)
         if olay=1 then mapid=olaylist(olayindex,olayti)
         gosub _gridedit_getmapvalues
         `
        endif
        `
        rem Pass 3 - Add To NodeTree
        if csgpass=3
         `
         rem prepare object with HSR process
         usesegobj=0
         if ghsrmode=1
          `
          rem report progress
          tproggy#=(9.0/layermax)*lay
          debugviewtext(221+tproggy#,strarr$(161)+str$(lay)+","+str$(x)+","+str$(y))
          `
          rem create super-ground-punch (arbitary usage)
`         groundpunchobj=64998
`         if object exist(groundpunchobj)=0
`          make object box groundpunchobj,80000,100,80000
`          position object groundpunchobj,0,-50,0
`          hide object groundpunchobj
`         endif
          `
          rem check boundbox of CSGPUNCH with surrounding segments
          for surrl=lay-1 to lay+1
           for surry=y-1 to y+1
            for surrx=x-1 to x+1
             if surrl>=0 and surrl<layermax
              if surry>=0 and surry<40
               if surrx>=0 and surrx<40
                 mapid=map(surrl,surrx,surry)
                 if mapid<>0
                  gosub _gridedit_getmapvalues
                  if object exist(selectionbankoffset+mapselection)=1
                   rem object bounding object to add to universe
                   surrobj=mapobj(surrl,surrx,surry)
                   if surrobj>0
                    perform csg clip segobj,surrobj
                   endif
                  endif
                 endif
               endif
              endif
             endif
            next surrx
           next surry
          next surrl
          `
          rem Now punch out ground (arbitary usage)
`         perform csg clip segobj,groundpunchobj
          `
         endif
         `
         rem make node tree addition
         for tlimb=0 to segmentprofileheader(seg).partmax
          `
          rem only visible meshes are used to make universe
          if limb exist(segobj,tlimb)=1
          if limb visible(segobj,tlimb)=1
           `
           rem shadow all except floor,wall,ceiling (and meshes with shadow switched off)
`           if glightshadowsstate=1 then tshadow=3 else tshadow=0
`           if gdynamicshadowsstate=1 then tshadow=2

           if tlimb=segmentprofile(seg).vis.f then tshadow=0
           if tlimb=segmentprofile(seg).vis.r then tshadow=0
           if tlimb=segmentprofile(seg).vis.wb then tshadow=0
           if tlimb=segmentprofile(seg).vis.wr then tshadow=0
           if tlimb=segmentprofile(seg).vis.wf then tshadow=0
           if tlimb=segmentprofile(seg).vis.wl then tshadow=0
           if tlimb=segmentprofile(seg).vis.wl then tshadow=0
           if tlimb=segmentprofile(seg).vis.owb then tshadow=0
           if tlimb=segmentprofile(seg).vis.owr then tshadow=0
           if tlimb=segmentprofile(seg).vis.owf then tshadow=0
           if tlimb=segmentprofile(seg).vis.owl then tshadow=0
           if tlimb=segmentprofile(seg).vis.owl then tshadow=0
           if tlimb=segmentprofile(seg).vis.octl then tshadow=0
           if tlimb=segmentprofile(seg).vis.octr then tshadow=0
           if tlimb=segmentprofile(seg).vis.ocbr then tshadow=0
           if tlimb=segmentprofile(seg).vis.ocbl then tshadow=0
           `
           rem set transparency for universe add
`           set object transparency segobj,segmentprofile(seg,tlimb).transparency
`           set object transparency segobj,1 `need alpha test active (depth-sort-via-alpha-test)
           rem x10 universe deals with alphatest in shader
           `set object transparency segobj,4
           rem so we can set all segments to solid (allowing blood static entity to be recognised by lightmapper as a real transparent poly)
           set object transparency segobj,0
           `
           rem add mesh to universe
           tcolmode=segmentprofile(seg,tlimb).colmode
           tarbvalue=segmentprofile(seg,tlimb).material.index
           if segmentprofile(seg,tlimb).transparency=2 then tarbvalue=0 : rem FPSCV101 - no bullethole in trasparent(2) static
           if tcolmode=1 then inc totalnumberofcollisionboxes
           if segmentprofile(seg).vis.overlay=0
            if segmentprofile(seg).properties.kindof>0
             rem currently only corridors are true for this, and ARE ALL solid!
             rem 1straight,2corner,3tjunc,4cross,5deadend
             rem V110 - 190110 - ventilation meshes are different, so no portal culling on these!
             tsegname$=getfile(selectionbank$(seg))
             if left$(lower$(tsegname$),16)="ventilation duct"
              tportalblocker=0
             else
              tportalblocker=2
             endif
            else
             tportalblocker=1
            endif
           else
            tportalblocker=0
           endif
           make static limb segobj,tlimb,tcolmode,tarbvalue,tshadow,tportalblocker
           `
           rem X10 270807 - large corner peices should be added as extra AI obstacle
           tisacorner=0
           if tlimb=segmentprofile(seg).vis.ctl then tisacorner=1
           if tlimb=segmentprofile(seg).vis.ctr then tisacorner=1
           if tlimb=segmentprofile(seg).vis.cbr then tisacorner=1
           if tlimb=segmentprofile(seg).vis.cbl then tisacorner=1
           if tlimb=segmentprofile(seg).vis.octl then tisacorner=1
           if tlimb=segmentprofile(seg).vis.octr then tisacorner=1
           if tlimb=segmentprofile(seg).vis.ocbr then tisacorner=1
           if tlimb=segmentprofile(seg).vis.ocbl then tisacorner=1
           if tisacorner=1
            rem use segobj as temp object while we create AI OBS
            useobj=universebuildobjstartoffset-1
            make object box useobj,40,100,40
            position object useobj,limb position x(segobj,tlimb),limb position y(segobj,tlimb),limb position z(segobj,tlimb)
            AI ADD STATIC OBSTACLE useobj,1,object position y(useobj)/100.0
            delete object useobj
           endif
           `
          endif
          endif
          `
         next tlimb
         `
         rem hide original object (still used for SURROBJ HSR culling)
         hide object segobj
         `
        endif
        `
        rem PassEnd
        `
        rem Increment segment objid
        inc segobj
        `
        rem When run out of segments to build map, leave immediately
        if segobj>=universebuildobjendoffset
         rem end all loop conditions - no crash - just shortened level
         lay=layermax : y=maxy-1 : x=maxx-1
         olay=1 : olayti=tolaymax
        endif
        `
       endif
      endif
     next olayti
    endif
   next olay
  next x
 next y
next lay
`
rem When all objecta added (first pass)
if csgpass=1
 rem add a zero-size high object for top of universe (need clearance for player on roofs)
 make object box segobj,0,100,0 : position object segobj,0,highesty+50,0 : inc segobj
 rem record last segment object
 lastsegobj=segobj
endif
if csgpass=3
 if object exist(segobj)=1
  set object transparency segobj,4
  make static object segobj,0,0,0,1
  hide object segobj : inc segobj
 endif
endif
`
rem next pass
next csgpass

rem V102RC6 remove all segment objects to free up memory for next phase ( except the horizon polys )
if gusefloorstate=1 then inc segobjstart,4
if lastsegobj>=segobjstart then delete objects segobjstart,lastsegobj
if gusefloorstate=1 then dec segobjstart,4

rem FPSCV104RC7 - new lightmapper
rem FPSCV105RC1 - added new flag 'glightmappingold'
useoldlightmapper=glightmappingold
usedarklightmapper=1-glightmappingold
if usedarklightmapper=1
 rem DarkLIGHTS Settings
 LM Start
endif

rem debug info
debugviewtext(230,strarr$(162))

rem add pure static entities to node tree now
eleobj=entityobjectoffset
ttick=0 : ttickmax=entityelementlist/10 : ttickmax=1
for e=1 to entityelementlist
 obj=eleobj+e
 entid=entityelement(e).bankindex
 tentid=entityelement(e).bankindex
 if obj>0 and entid>0
  rem add static entities to node tree now (x10 excludes static characters)
  if entityelement(e).staticflag=1 and entityprofile(tentid).ischaracter=0
   inc ttick : if ttick>ttickmax then ttick=0 : debugviewtext(232,strarr$(163)+str$(e)+"/"+str$(entityelementlist)+" ("+entityprofile(tentid).model$+")")
   if entityprofile(tentid).ismarker=0
    `
    rem V110 - 080110 - ensure static entities dont mess up dynamic parent objects
    ttempobj1=lastsegobj+0
    if object exist(ttempobj1)=1 then delete object ttempobj1
    clone object ttempobj1,entitybankoffset+entid
    entityelement(e).profileobj=ttempobj1
    configureobj=ttempobj1
    `   
    rem this next routine should texture, but because entobj is zero, no, need to use OBJ!!!
    `configureobj=entitybankoffset+entid (see above)
    gosub _entity_configueelementforuse
    gosub _entity_createelementasobject
    configureobj=0
    `
    rem V110 - 080110 - and once out of config, restore ptr to parent obj
    entityelement(e).profileobj=entitybankoffset+entid
    `
    if object exist(obj)=1
     `
     rem collision mode for static entities (0-poly,1-box,2-reduced) dynamic (3-cylinder,4-sphere)
     tcolmode=2 : rem default is to use a reduced mesh
     if entityprofile(tentid).collisionmode>0 and entityprofile(tentid).collisionmode<3
      tcolmode=entityprofile(tentid).collisionmode-1
     endif
     rem static entities must cast shadows (unless flagged as off)
`     if glightshadowsstate=1 then tshadow=3 else tshadow=0
`     if gdynamicshadowsstate=1 then tshadow=2
     tarbvalue=entityprofile(tentid).materialindex
     rem always write z as alpha test ensures draw order not needed
     rem x10 static entity blood zclashes in x9 code
     `enable object zwrite obj
     if entityprofile(tentid).transparency>1
      rem transparent static entities are sorted to render in a second pass now
      set object transparency obj,4
      disable object zwrite obj
      rem disabled zwrite has a built-in zbias (for X10)
     else
      rem Most x9 entities are transparency 1, but universe treats these as solid
      set object transparency obj,0
      enable object zwrite obj
     endif
     `
     rem create static object from static entity
     useobj=obj
     make static object useobj,tcolmode,tarbvalue,tshadow,0
     rem then create an AI obstacle from the static entity (+sizey ensures if sunk into floor they still work)
     `270807AI ADD STATIC OBSTACLE useobj,1,(object position y(useobj)+5)/100.0
     taddtocontainer=(object position y(useobj)+object size y(useobj))/100.0
     rem V110 - 151209 - fixes AI container crash
     if taddtocontainer<0 then taddtocontainer=0
     if taddtocontainer>19 then taddtocontainer=19
     AI ADD STATIC OBSTACLE useobj,1,taddtocontainer
     taddtocontainer2=(object position y(useobj)+5)/100.0
     if taddtocontainer<>taddtocontainer2 and object size y(useobj)>10
      rem ensure we add OBS data for large ceiling items not already covered by above
      rem V110 - 151209 - fixes AI container crash
      if taddtocontainer2<0 then taddtocontainer2=0
      if taddtocontainer2>19 then taddtocontainer2=19
      AI ADD STATIC OBSTACLE useobj,1,taddtocontainer2
     endif
     rem then delete the un-needed static entity
     delete object useobj
     `
    endif
   endif
  endif
  rem add dynamic and static lights from entities
  if entityprofile(tentid).ismarker=2
   lgx#=entityelement(e).x
   lgy#=entityelement(e).y
   lgz#=entityelement(e).z
   lgrange#=entityelement(e).eleprof.light.range
   lgr#=rgbr(entityelement(e).eleprof.light.color)
   lgg#=rgbg(entityelement(e).eleprof.light.color)
   lgb#=rgbb(entityelement(e).eleprof.light.color)
   if entityelement(e).staticflag=0
    if gdynamiclightingstate=1
     lgtype=1 : gosub _lighting_adddynamiclight
     entityelement(e).eleprof.light.index=infinilightindex
    endif
   else
    if activatelightmapping=1
     if useoldlightmapper=1
      add light map light lgx#, lgy#, lgz#, lgrange#, lgr#, lgg#, lgb#, 100, 1
     endif
     if usedarklightmapper=1
      size# = lgrange#
      falloff# = size#/2
      radius# = size#+falloff#
      zerorange# = ( radius# * glightzerorange ) / 100.0
      atten# = glightatten / (radius#*radius#)
      outer# = 1.0 + falloff#
      brighter# = radius# / outer#
      lgr#=lgr#*brighter#
      lgg#=lgg#*brighter#
      lgb#=lgb#*brighter#
      LM Add Custom Point Light lgx#, lgy#, lgz#, radius#, zerorange#, atten#,lgr#/255.0, lgg#/255.0, lgb#/255.0
     endif
     lgtype=0 : gosub _lighting_adddynamiclight
     inc staticlightcount
    endif
    if gdynamicshadowsstate=1
     array insert at bottom shadowlight()
     shadowlight().x# = lgx#
     shadowlight().y# = lgy#
     shadowlight().z# = lgz#
     shadowlight().range# = lgrange#
    endif
   endif
  endif
 endif
next e

rem New portals section of game runner
debugviewtext(240,strarr$(164))
build static portals

rem Apply shadow lights to scene (which will compute shadows direct from node tree
if gdynamicshadowsstate=1
 debugviewtext(250,strarr$(165))
 set global shadow shades 1
 set global shadow color 0,0,0,128
` disabled scene shadows for performance reasons
` for tsli=1 to array count(shadowlight(0))
`  set shadow light tsli, shadowlight(tsli).x#, shadowlight(tsli).y#, shadowlight(tsli).z#, shadowlight(tsli).range#
` next tsli
endif

rem New lightmapping section of game runner
if activatelightmapping=1 and staticlightcount>0
 rem delete old lightmaps
 debugviewtext(259,strarr$(166))
 tl=0
 while tl<65535
  tl$=myownrootdir$+"levelbank\testlevel\lightmaps\"+str$(tl)+".dds"
  if file exist(tl$)=1 then delete file tl$ else exit
  tl$=myownrootdir$+"levelbank\testlevel\lightmaps\"+str$(tl)+".png"
  if file exist(tl$)=1 then delete file tl$ else exit
  inc tl
 endwhile
 rem add universe for lightmapping
 debugviewtext(260,strarr$(167))
 `x9if useoldlightmapper=1
 ` add static objects to light map pool
 ` debugviewtext(270,strarr$(168))
 ` if glightmapsize>0
 `  create light maps glightmapsize,glightmapquality,myownrootdir$+"levelbank\testlevel\lightmaps\"
 ` else
 `  create light maps 8,100,myownrootdir$+"levelbank\testlevel\lightmaps\"
 ` endif
 `endif
endif

rem Must be done 'after' lightmapping phase
if grealgameviewstate=0 and segobjusedformapeditor=0 and goptimizemode=1
 `
 rem Saving effects (as some scene geometry needs setting changes)
 debugviewtext(273,strarr$(169))
 filename$=myownrootdir$+"levelbank\testlevel\universe.eff"
 if file exist(filename$)=1 then delete file filename$
 open to write 1,filename$
  write file 1,effectbankmax
  for eff=1 to effectbankmax
   write string 1,effectbank$(eff)
  next eff
  write string 1,thorizonplanetex$
 close file 1
 `
 rem Builds final universe reload file (even when test game)
 debugviewtext(275,strarr$(170))
 universefile$=myownrootdir$+"levelbank\testlevel\universe.dbu" : if file exist(universefile$)=1 then delete file universefile$
 universefile$=myownrootdir$+"levelbank\testlevel\universe.dbo" : if file exist(universefile$)=1 then delete file universefile$
 save static objects universefile$
 `
 rem FPSCV104RC9 - pregenerate physics universe (faster loading)
 phyunimesh$=myownrootdir$+"levelbank\testlevel\universephy.dbo" : if file exist(phyunimesh$)=1 then delete file phyunimesh$
 universeobj=universebuildobjstartoffset-1
 load object myownrootdir$+"levelbank\testlevel\universe.dbo",universeobj
 make mesh from object universeobj,universeobj
 convert mesh to vertexdata universeobj
 delete object universeobj
 make object universeobj,universeobj,0
 delete mesh universeobj
 save object phyunimesh$,universeobj
 delete object universeobj
 `
 rem If DarkLIGHT lightmapper used
 `x9 if activatelightmapping=1 and staticlightcount>0 and usedarklightmapper=1
 if usedarklightmapper=1
  `
  rem load and lightmap static universe
  universeobj=universebuildobjstartoffset-1
  if object exist(universeobj)=1 then delete object universeobj
  load object universefile$,universeobj
  if glightshadowsstate=0
   rem Quick Lightmapping
   LM Add Collision Object universeobj
  else
   rem Full Lightmapping
   LM Add Transparent Collision Object universeobj,1
  endif
  rem 0,0,1=flatshaded (calculates normal based on face)
`  LM Add Light Map Object universeobj,0,0,1
  rem V110 - 140110 - uses mesh geometry normals where available
  LM Add Light Map Object universeobj,0,0,0
  LM Build collision Data
  `
  rem ambient setting (full ambient control in scene)
  LM Set Ambient Light glightambientr/100.0,glightambientg/100.0,glightambientb/100.0
  if glightsunr<>0 or glightsung<>0 or glightsunb<>0
   LM Add Directional Light glightsunx,glightsuny,glightsunz,glightsunr/100.0,glightsung/100.0,glightsunb/100.0
  endif
  `
  rem settings
  LM Boost Curved Surface Quality glightmaxsize,(glightboost*1.0)
  `
  rem start the light mapping thread
  lm set light map name ""
  lm set light map file format 1 : rem DDS
  lm set light map folder myownrootdir$+"levelbank\testlevel\lightmaps\"
  quality#=glightquality/100.0
  LM Build Light Maps Thread glighttexsize,quality#,glightblurmode,glightthreadmax
  load dll "Kernel32.dll",1
  while LM Get Complete()=0
   debugviewtext(276,LM Get Status( )+"  "+str$(int(LM Get Percent()))+"%")
   call dll 1,"Sleep",1
  endwhile
  delete dll 1
  `
  rem close lightmapper
  LM Reset
  `
  rem save lightmapped universe
  if file exist(universefile$)=1 then delete file universefile$
  set object light universeobj,1
  `X10 not needed set light mapping on universeobj,0,1
  save object universefile$,universeobj
  delete object universeobj
  `
  rem load static universe back in
  load static objects universefile$,gdividetexturesize
  `
 endif
 `
` moved to game_load rem X10 If universe has no effect load on, and apply it
` if guniverseeffectindex=0
`  guniverseeffectindex=loadinternaleffectunique("effectbank\universe\universe.fx",1)
`  set static objects effect guniverseeffectindex
` endif
 `
 rem Only perform these saves if BUILDING EXE
 if gcompilestandaloneexe=1
  `
  rem X10 - 240907 - standalone requires AISS OBS data to be calculated soon
  gosub _aiss_level : gosub _aiss_free
  `
  rem Version control on EXE Building
  gosub _version_universe_construct
  `
 else
  `
  rem Not building final EXE, but need to retain infinilight data (for construction skip)
  gosub _version_universe_savelightdata
  `
 endif
 `
 rem X10 save old map, overlay and static entity data for future test game pass
 gosub _universe_saveforskipcheck
 `
endif

return

_universe_recreateinfinilights:
 `
 rem V109 BETA3 - 210408 - when use DBU-skip, new elements do not tally with inifnilight LGT data, so recreate
 rem for the test gamwe quick rebuild feature
 `
 rem Reset dynamic light array
 activatedynamiclightscount=0
 empty array infinilight(0)
 testmarkerstart=50000
 testmarker=testmarkerstart
 staticlightcount=0
 infinilightindex=0
 `
 rem Lighting flag
 activatelightmapping=glightmappingstate
 if segobjusedformapeditor=1 then activatelightmapping=0
 `
 rem Rebuild inifnilights
 for e=1 to entityelementlist
  entid=entityelement(e).bankindex
  tentid=entityelement(e).bankindex
  rem add dynamic and static lights from entities
  if entityprofile(tentid).ismarker=2
   lgx#=entityelement(e).x
   lgy#=entityelement(e).y
   lgz#=entityelement(e).z
   lgrange#=entityelement(e).eleprof.light.range
   lgr#=rgbr(entityelement(e).eleprof.light.color)
   lgg#=rgbg(entityelement(e).eleprof.light.color)
   lgb#=rgbb(entityelement(e).eleprof.light.color)
   if entityelement(e).staticflag=0
    if gdynamiclightingstate=1
     lgtype=1 : gosub _lighting_adddynamiclight
     entityelement(e).eleprof.light.index=infinilightindex
    endif
   else
    if activatelightmapping=1
     if usedarklightmapper=1
      size# = lgrange#
      falloff# = size#/2
      radius# = size#+falloff#
      zerorange# = ( radius# * glightzerorange ) / 100.0
      atten# = glightatten / (radius#*radius#)
      outer# = 1.0 + falloff#
      brighter# = radius# / outer#
      lgr#=lgr#*brighter#
      lgg#=lgg#*brighter#
      lgb#=lgb#*brighter#
     endif
     lgtype=0 : gosub _lighting_adddynamiclight
     inc staticlightcount
    endif
   endif
  endif
 next e
 `
return

_universe_destruct:

rem Remove universe and all constructed preview assets
delete static objects : set static universe maxx*100,(layermax+1)*100,maxy*100

return

_universe_camera:

rem Input source
tkeystate30=0 : tkeystate32=0 : tkeystate17=0 : tkeystate31=0 : tkeystate44=0
if inputsys.kscancode=87 then tkeystate17=1
if inputsys.kscancode=83 then tkeystate31=1
if inputsys.kscancode=65 then tkeystate30=1
if inputsys.kscancode=68 then tkeystate32=1
if inputsys.kscancode=90 then tkeystate44=1
cammovex#=inputsys.xmousemove
cammovey#=inputsys.ymousemove

rem Camera old information
cox#=camera position x(playercam)
coy#=camera position y(playercam)
coz#=camera position z(playercam)

rem Control camera movement
movement=0 : speed#=6.0
x#=camera angle x(playercam) : z#=camera angle z(playercam) : sy#=camera angle y(playercam) : y#=sy#
if tkeystate30=1 then dec y#,90 : movement=1
if tkeystate32=1 then inc y#,90 : movement=1
rotate camera playercam,0,y#,0
if tkeystate17=1 or tkeystate30=1 or tkeystate32=1 then move camera playercam,speed# : movement=1
if tkeystate31=1 then move camera playercam,speed#*-1.0 : movement=1
rotate camera playercam,x#,sy#,z#

rem Float Key
if tkeystate44=1 then position camera playercam,camera position x(playercam),camera position y(playercam)+4.0,camera position z(playercam) : grav#=-1.0

rem Camera new information
cmx#=camera position x(playercam)
cmy#=camera position y(playercam)-grav#
cmz#=camera position z(playercam)

rem Overall ellipse collision for camera
tcameraeyey#=20.0
if deactivatecollision=0
 if static volume(cox#,coy#-tcameraeyey#,coz#,cmx#,cmy#-tcameraeyey#,cmz#,1.0)=1
  cmx#=cox#+get static collision x()
  cmy#=coy#+get static collision y()
  cmz#=coz#+get static collision z()
  tcolmaterialtype=get static collision value()-1
  colmaterialtype=tcolmaterialtype
  grav#=1
 else
  inc grav#,1
 endif
endif

rem Non node tree collision floor stopper (and edge of universe stopper)
if cmx#<0.0 then cmx#=0.0
if cmx#>maxx*100.0 then cmx#=maxx*100.0
if cmy#<45.0 then cmy#=45.0
if cmz#<maxy*-100.0 then cmz#=maxy*-100.0
if cmz#>0.0 then cmz#=0.0

rem Update camera position
position camera playercam,cmx#,cmy#,cmz#
zrotate camera playercam,curveangle(0,camera angle z(playercam),1.75)
position listener cmx#/10.0,cmy#/10.0,cmz#/10.0
rotate listener 0,camera angle y(playercam),0

rem Camera rotation speeds
t=abs(cammovex#)+abs(cammovey#)
if t=1 then camrotspeed#=0.05
if t=2 then camrotspeed#=0.1
if t=3 then camrotspeed#=0.15
if t=4 then camrotspeed#=0.2
if t>=5 then camrotspeed#=0.25

rem Control camera view
camangx#=camera angle x(playercam)+(cammovey#*camrotspeed#)
camangy#=camera angle y(playercam)+(cammovex#*camrotspeed#)
if wrapvalue(camangx#)>85 and wrapvalue(camangx#)<180 then camangx#=85.0
if wrapvalue(camangx#)>180 and wrapvalue(camangx#)<275 then camangx#=275.0
rotate camera playercam,camangx#,camangy#,camera angle z(playercam)

return

_universe_preparelimbflags:

rem Create limb flag array
limbflagmax=segmentprofileheader(seg).lastmeshmax
undim limbflag()
dim limbflag(limbflagmax)

rem Fill array with null limbs
for tlimb=0 to limbflagmax
 limbflag(tlimb)=0
next tlimb

return

_universe_createhorizonplanes:
 `
 rem TODO take MAXX and MAXY into account!
 `
 rem Load texture for horizon plane
 thorizonplanetex$=""
 thorizonplanetexid=segmentprofile(mapselection,0).texid
 if thorizonplanetexid<>0
  thorizonplanetex$=segmentprofile(mapselection,0).tex$
 else
  thorizonplanetexid=segmentprofile(mapselection,0).texdid
  if thorizonplanetexid<>0
   thorizonplanetex$=segmentprofile(mapselection,0).texd$
  else
   thorizonplanetex$="texturebank\common\ground_D2.tga"
   thorizonplanetexid=loadinternalimage(thorizonplanetex$)
  endif
 endif
 `
 rem Place horizon planes on four sides
 tdim=(40*100)/2.0 : tdimneg=tdim*-1 : tdimlong=tdim*3 : lay=0
 rem Left
 make object box segobj,tdim*2,10,tdimlong*2 : position object segobj,tdimneg,(lay*100)-5,(maxy*-50)
 scale object texture segobj,40,120
 texture object segobj,thorizonplanetexid : inc segobj
 rem Right
 make object box segobj,tdim*2,10,tdimlong*2 : position object segobj,(maxx*100)+tdim,(lay*100)-5,(maxy*-50)
 scale object texture segobj,40,120
 texture object segobj,thorizonplanetexid : inc segobj
 rem Top
 make object box segobj,tdim*2,10,tdim*2 : position object segobj,(maxx*50),(lay*100)-5,tdim
 scale object texture segobj,40,40
 texture object segobj,thorizonplanetexid : inc segobj
 rem Bottom
 make object box segobj,tdim*2,10,tdim*2 : position object segobj,(maxx*50),(lay*100)-5,(maxy*-100)+tdimneg
 scale object texture segobj,40,40
 texture object segobj,thorizonplanetexid : inc segobj
 `
 rem And place fog to finish horizon blur to sky (by colour)
 rem FPSCV104RC3 - fog is controlled by FPI elsewhere
 `fog on : fog distance 2000.0,4000.0 : fog color 0,0,0
 `
return

_universe_makemapvalues:
 `
 mapid = 0
 mapid = mapid + ( ( mapselection && %111111111111 ) << 20 )
 mapid = mapid + ( ( mapscaler && %1111 ) << 16 )
 mapid = mapid + ( ( mapground && %11 ) << 14 )
 mapid = mapid + ( ( maprotate && %11 ) << 12 )
 mapid = mapid + ( ( maporient && %11 ) << 10 )
 mapid = mapid + ( ( mapsymbol && %111111 ) << 4 )
 mapid = mapid + ( ( maptile && %1111 ) )
 rem mapid out
 `
return


