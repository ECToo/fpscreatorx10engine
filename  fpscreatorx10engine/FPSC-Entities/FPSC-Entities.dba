rem
rem ENTITY (Control)
rem

_entity_startentitiesoff:
 `
 rem Prepare entities for logical usage
 for e=1 to entityelementlist
  if entityelement(e).active=1 and entityelement(e).spawn.leader=0
   entityelement(e).logiccount=0
   entityelement(e).logictimestamp=timer()
   entityelement(e).dormant=1
   rem check if entity starts inside geometry
   entid=entityelement(e).bankindex
   if entityprofile(entid).ischaracter=1
    tettry=0 : tskip=0
    ttryy#=entityelement(e).y
    ellipseheight#=1.0
    if entityelement(e).obj
     if object exist(entityelement(e).obj)=1
      if object size y(entityelement(e).obj)<50
       tskip=1
      endif
     endif
    endif
    if tskip=0
     while tettry<25
      if static volume(entityelement(e).x,ttryy#+33,entityelement(e).z,entityelement(e).x,ttryy#+32,entityelement(e).z,ellipseheight#)=0 then exit
      ttryy#=ttryy#+1.0
      inc tettry
     endwhile
     if tettry>=25
      rem entity stuck - so make it immobile to shut down struggle!
      entityelement(e).eleprof.isimmobile=1
     else
      rem entities can find floor initially (not playerstart,trigger,light,emission)
      entityelement(e).y=ttryy#
      entityelement(e).mover.inmotion=1
      entityelement(e).mover.grav=0.0
     endif
    endif
   endif
  endif
  `
  rem X10 - 210807 - record starting coordinates (for AISS max range limit)
  entityelement(e).eleprof.startx=entityelement(e).x
  entityelement(e).eleprof.starty=entityelement(e).y
  entityelement(e).eleprof.startz=entityelement(e).z
  `
 next e
 timestamp=timer()
 `
 rem Overwrite any GUN or FLAK settings with mods-from-entity-weapons
 for e=1 to entityelementlist
  entid=entityelement(e).bankindex
  tgunid$=entityprofile(entid).isweapon$
  gosub _entity_getgunidandflakid
  if tgunid>0
   gun(tgunid).settings.accuracy=entityelement(e).eleprof.accuracy
   gun(tgunid).settings.reloadqty=entityelement(e).eleprof.reloadqty
   gun(tgunid).settings.iterate=entityelement(e).eleprof.fireiterations
   gun(tgunid).settings.impactforce=entityelement(e).eleprof.ex.impactforce
   if tflakid=0
    gun(tgunid).settings.damage=entityelement(e).eleprof.damage
   else
    flak(tflakid).profile.damage=entityelement(e).eleprof.damage
    flak(tflakid).profile.lifespan=entityelement(e).eleprof.lifespan
    flak(tflakid).profile.bounceonhit=entityelement(e).eleprof.bounceqty
    flak(tflakid).profile.explodeonhit=entityelement(e).eleprof.explodeonhit
    `
    rem some assumptions over how FLAK settings affect flak itself
    flak(tflakid).profile.zinc=entityelement(e).eleprof.throwspeed
    flak(tflakid).profile.yinc=entityelement(e).eleprof.throwangle/10.0
    flak(tflakid).profile.yspeed=1+((entityelement(e).eleprof.throwangle/2.0)/1000.0)
    flak(tflakid).throwangle=entityelement(e).eleprof.throwangle
    if entityelement(e).eleprof.throwangle>0
     flak(tflakid).profile.weight=0.5
    else
     flak(tflakid).profile.weight=0.0
    endif
    `
   endif
  endif
 next e
 `
 rem also ensure entity characters have switched to their weapon (gundata not avail at createelements)
 for e=1 to entityelementlist
  obj=entityelement(e).obj
  entid=entityelement(e).bankindex
  if obj>0 and entid>0
   if entityprofile(entid).ischaracter=1
    if object exist(obj)=1
     if entityprofile(entid).firespotlimb>-1
      rem spawn leaders do not require attached weapon
      if entityelement(e).spawn.leader=0
       tobj=obj : gosub _entity_switchattachment
       rem V110 - 130110 - as we now have the gundata, ensure its loaded if flagged
       if entityelement(e).eleprof.ex.loadedweapon=1
        tgunid=entityelement(e).currentweapon
        if tgunid>0
         entityelement(e).currentammo=gun(tgunid).settings.reloadqty
        endif
       endif 
      endif
     endif
    endif
   endif
  endif
 next e
 `
return

_entity_resetentitiestorestartstates:
 `
 rem uses tcopyorrestart (1-resttart)
 rem copy start-data-entity-backup to real entityelements
 if tcopyorrestart=0
  dim copyofentityelement(entityelementmax) as entitytype
  for e=1 to entityelementmax
   copyofentityelement(e)=entityelement(e)
  next e
 else
  for e=1 to entityelementmax
   entityelement(e)=copyofentityelement(e)
  next e
 endif
 `
return

_entity_resetentitiesifplrleaps:
 `
 rem Reset logic if player leaps from one location to another
 for e=1 to entityelementlist
  if entityelement(e).active=1
   entityelement(e).logiccount=0
   entityelement(e).logictimestamp=timer()
   entityelement(e).dormant=1
  endif
 next e
 `
return

_entity_rejigifwaterlevelchanges:
 `
 rem Prepare entities for logical usage
 for e=1 to entityelementlist
  if entityelement(e).active=1 and entityelement(e).spawn.leader=0
   entid=entityelement(e).bankindex
   if entityelement(e).obj
    if object exist(entityelement(e).obj)=1
     if object position y(entityelement(e).obj)<waterlevel#
      if entityelement(e).eleprof.physics=1
       rem regular physics objects only (not pseudo static entities like windows)
       ttx#=0 : tty#=2.5 : ttz#=0
       ttobj=entityelement(e).obj : gosub _physics_setvelocity
      endif
     endif
    endif
   endif
  endif
 next e
 `
return

_entity_addetoprioritylist:
 `
 rem add entity to prority status
 if entityelement(e).priorityai=0
  entityelement(e).priorityai=1
  inc logicprioritycount
 endif
 `
return

_entity_removeefromprioritylist:
 `
 rem remove entity from prority status
 if entityelement(e).priorityai=1
  if entityelement(e).priorityduration=0
   entityelement(e).losttargetcount=99999
   entityelement(e).priorityai=0
   if logicprioritycount>0
    dec logicprioritycount
   endif
  endif
 endif
 `
return

_entity_stealpriorityandgivetoe:
 `
 rem Steal from furthest, give to this one (E)
 if lastlogicpriorityfurtheste>0
  if entityelement(e).priorityai=0
   if entityelement(lastlogicpriorityfurtheste).priorityai=1
    if entityelement(lastlogicpriorityfurtheste).priorityduration=0
     tste=e : e=lastlogicpriorityfurtheste : gosub _entity_removeefromprioritylist
     e=tste : entityelement(e).logiccount=0
     gosub _entity_addetoprioritylist
    endif
   endif
  endif
 endif
 `
return

_entity_blastinitentities:
 `
 rem give entities a 10 cycle blast of logic (to set up things like decals and floating collectables)
 for tencycles=1 to 10
  for e=1 to entityelementlist
   if entityelement(e).active=1 and entityelement(e).spawn.leader=0
    entid=entityelement(e).bankindex
    if entid>0
     obj=entityelement(e).obj
     entityelement(e).logictimestamp=timer()
     gosub _entity_controlsingleai
     tdx#=entityelement(e).x-mex# : tdz#=entityelement(e).z-mez# : tdy#=entityelement(e).y-mey#
     entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
     rem if too far away to see properly
     if entityelement(e).plrdist<1000.0
      entityelement(e).logiccount=0
      entityelement(e).dormant=0
     else
      entityelement(e).logiccount=0
      entityelement(e).dormant=1
     endif
     rem X10 if visible, also not dormant
     if obj>0
      if object visible(obj)=1
       entityelement(e).logiccount=0
       entityelement(e).dormant=0
      endif
     endif
    endif
   endif
  next e
 next tencycles
 `
 rem Bring all entities alive quickly
 allentsfulllogicatstartcount=100
 `
 rem 030805 - and once call to entity control to start off visuals/decals/etc
 gosub _entity_controlelements
 `
return

_entity_showdebugstringinfo:
 `
 if e>0 and obj>0
  if entityelement(e).priorityai<>0 then ink rgb(255,255,255),0
  if entityelement(e).plrdist<500
   rem V109 - 140109 - added leader=0 to aviod showing invisible spawn entities (corrupt visible text output)
   if object in screen(obj)=1 and entityelement(e).spawn.leader=0
    `
    rem Entity Name and Debug string
    center text object screen x(obj),object screen y(obj)-80,"ID:"+str$(e)+" OBJ:"+str$(obj)+" DIST:"+str$(int(entityelement(e).plrdist))+" POS:"+str$(int(entityelement(e).x))+","+str$(int(entityelement(e).y))+","+str$(int(entityelement(e).z))
    center text object screen x(obj),object screen y(obj)-60,entityelement(e).eleprof.name$
    center text object screen x(obj),object screen y(obj)-40,entitydebug$(e)
    `
    rem Entity Status Info
    tentid=entityelement(e).bankindex
    if entityprofile(tentid).ischaracter<>0
     if entityelement(e).ai.libindex>=1 and entityelement(e).ai.libindex<=array count(scriptbank$(0))
      tainame$=scriptbank$(entityelement(e).ai.libindex)
     else
      tainame$=str$(entityelement(e).ai.libindex)
     endif
     `150110center text object screen x(obj),object screen y(obj)-20,"A:"+tainame$+" S:"+str$(entityelement(e).ai.state)+" WS:"+str$(entityelement(e).ai.waypoint.state)+" L:"+str$(entityelement(e).eleprof.lives)+" H:"+str$(entityelement(e).health)+" LT:"+str$(entityelement(e).losttargetcount)+"("+str$(int(entityelement(e).actualtargetx))+","+str$(int(entityelement(e).actualtargety))+","+str$(int(entityelement(e).actualtargetz))+") RCC:"+str$(entityelement(e).raycastcount)+" AF:"+str$(entityelement(e).animframe)+" AOBJ:"+str$(entityelementwhichobj(e))+" SLOT:"+str$(entityelementwhichslot(e))+" ACT:"+str$(entityelement(e).activated)
     center text object screen x(obj),object screen y(obj)-20,"A:"+tainame$+" S:"+str$(entityelement(e).ai.state)+" WS:"+str$(entityelement(e).ai.waypoint.state)+" L:"+str$(entityelement(e).eleprof.lives)+" H:"+str$(entityelement(e).health)+" AIMODE:"+str$(entityelement(e).eleprof.aiss.lastactionmode)+" AF:"+str$(entityelement(e).animframe)+" AOBJ:"+str$(entityelementwhichobj(e))+" SLOT:"+str$(entityelementwhichslot(e))+" ACT:"+str$(entityelement(e).activated)
     if entityelement(e).currentweapon>0
      center text object screen x(obj),object screen y(obj),"W:"+str$(entityelement(e).currentweapon)+" WA:"+str$(entityelement(e).currentammo)+"\"+str$(entityelement(e).currentclipammo)
     else
      center text object screen x(obj),object screen y(obj),"HAS W:"+str$(entityelement(e).eleprof.hasweapon)
     endif
    else
     if entityprofile(tentid).isweapon<>0
      tgunid=entityprofile(tentid).isweapon
      center text object screen x(obj),object screen y(obj)-20," AI:"+str$(entityelement(e).ai.libindex)+" S:"+str$(entityelement(e).ai.state)+strarr$(99)+str$(gun(tgunid).settings.damage)+" H:"+str$(entityelement(e).health)
     else
      center text object screen x(obj),object screen y(obj)-20," AI:"+str$(entityelement(e).ai.libindex)+" S:"+str$(entityelement(e).ai.state)+" H:"+str$(entityelement(e).health)+" AF:"+str$(entityelement(e).animframe)
     endif
    endif
    `
   endif
  endif
  if entityelement(e).priorityai<>0 then ink rgb(255,255,0),0
 endif
 `
return

_entity_controlelements:

rem FPSCV10X - solve slow life for entities at distance
if allentsfulllogicatstartcount>0
 dec allentsfulllogicatstartcount
endif

rem Entity Performance
gameperftimestamplocal=perftimer()

rem General data for control management
mex#=camerapositionx : mey#=camerapositiony : mez#=camerapositionz
meheight#=(ellipsevolumesize#-0.25)*30.0

rem handle AI sound
managebroadcastsound()
gosub _aiss_broadcastsound

rem maintain constant game speed
timeelapsed#=(1.0/50.0)*(timer()-timestamp) : timestamp=timer()

rem Debug entire AI logic
if gshowdebugtextingamestate=1
 if debugviewtog=1
  set cursor 0,100
  ink rgb(128,255,128),0
  print strarr$(98)
  print
 endif
endif

rem X10 - Global ragdoll timing (can use 5 at a time, 3 seconds decay per ragdoll usage)
if timer()>ragdollcounttimetick
 ragdollcounttimetick=timer()+3000
 rem ragdoll limit based on the dynamic moving ones, not the static
 rem ones which freeze after about three seconds
 if ragdollcountingame>0 then dec ragdollcountingame
endif

rem Go through all entities for LOGIC
superstealpriority=0
tonestealperaiphase=0
tonestealperaiphasedist#=99999
logicpriorityfurthest#=0
for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 obj=entityelement(e).obj
 if entityelement(e).active=1 and entityelement(e).dormant=0
  `
  rem only non-spawn-masters with valid profile indexes
  if entid>0 and entityelement(e).spawn.leader=0
   `
   rem reset kill flag
   tkillentitynow=0
   `
   rem always fade entity to lifespan no matter logic slice
   if entityelement(e).spawn.life>0
    if timer()>entityelement(e).spawn.life
     entityelement(e).spawn.life=0
     tkillentitynow=1
    endif
   endif
   `
   rem always kill an entity falling out of universe
   if entityelement(e).y<-100
    tkillentitynow=1
   endif
   `
   rem kill now
   if tkillentitynow=1
    tdamage=entityelement(e).health
    tdamagesource=0 : timpacttype=1
    tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
    ttodestroyevenifimmune=entityelement(e).eleprof.strength : rem store for later return
    if entityelement(e).eleprof.strength=0 then entityelement(e).eleprof.strength=1
    gosub _entity_deducthealth : entityelement(e).eleprof.strength=ttodestroyevenifimmune
    tkillentitynow=0
   endif
   `
   rem logic timeslice
   tlogic#=entityelement(e).logiccount-timeelapsed#
   entityelement(e).logiccount=tlogic#
   if entityelement(e).eleprof.phyalways<>0 then entityelement(e).logiccount=0
   if entityelement(e).logiccountburst>0 then entityelement(e).logiccountburst=entityelement(e).logiccountburst-1 : entityelement(e).logiccount=0
   `
   rem X10 full AI - performance gains in other ways
   entityelement(e).logiccount=0
   if entityelement(e).logiccount<=0
    `
    rem time slice of logic (..since entity last thought..)
    timeslice#=(1.0/50.0)*(timer()-entityelement(e).logictimestamp)
    entityelement(e).logictimestamp=timer()
    `
    rem logic control
    gosub _entity_controlsingleai
    `
    rem when move, sounds might also need moving
    if entityelement(e).eleprof.physics<=2
     for tsnd=0 to 2
      if tsnd=0 then ttsnd=entityelement(e).soundset
      if tsnd=1 then ttsnd=entityelement(e).soundset1
      if tsnd=2 then ttsnd=entityelement(e).soundlooping
      if ttsnd>0
       if sound exist(ttsnd)=1
        if sound looping(ttsnd)=1
         posinternal3dsound(ttsnd,entityelement(e).x,entityelement(e).y,entityelement(e).z)
        endif
       endif
      endif
     next tsnd
    endif
    `
    rem free up a counter for a new AI character to be selected
    if entityelement(e).priorityai=1
     tokay=0
     if entityelement(e).active=0 or entityelement(e).plrdist>1000
      entityelement(e).priorityduration=0
      tokay=1
     endif
     if tokay=1
      gosub _entity_removeefromprioritylist
     else
      rem work out which E is the furthest back
      tpridist#=entityelement(e).plrdist
      if tpridist#>logicpriorityfurthest#
       logicpriorityfurthest#=tpridist#
       logicpriorityfurtheste=e
      endif
     endif
     rem priority duration protects from being lost or stolen for a while (running away)
     if entityelement(e).priorityduration>0
      entityelement(e).priorityduration=entityelement(e).priorityduration-1
     else
      entityelement(e).priorityduration=0
     endif
    endif
    `
    rem calculate player activity distance
    tdx#=entityelement(e).x-mex# : tdz#=entityelement(e).z-mez#
    entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))
    `
    rem can I see checkpoints here
    if entityprofile(entid).ismarker=1 and entityprofile(entid).lives=0
     if entityelement(e).plrdist<120.0
      if checkpointentity<>e
       playinternal3dsound(entityelement(e).soundset,mex#,mey#,mez#)
       checkpointentity=e
      endif
     endif
    endif
    `
    rem logic count based on distance (cancelled for important AI above)
    if allentsfulllogicatstartcount>0
     rem FPSCV10X - all entities should have immediate burst of logic to get started
     entityelement(e).logiccount=0
    else
     entityelement(e).logiccount=entityelement(e).plrdist/5.0
    endif
    `
   endif
   `
  endif
  `
 else
  `
  rem only if not dormant
  if entityelement(e).dormant=0
   `
   rem Inactive entity, however characters have logic even when dead
   if entityprofile(entid).ischaracter=1
    if entityelement(e).eleprof.cantakeweapon=1
     tgunid=entityelement(e).currentweapon
     if tgunid>0
      rem X10 follow ode influenced dropped attached weapon
      tdropobj=entityelement(e).attachmentobj
      if tdropobj>0
       x1#=object position x(tdropobj)
       y1#=object position y(tdropobj)
       z1#=object position z(tdropobj)
      else
       x1#=entityelement(e).x
       y1#=entityelement(e).y
       z1#=entityelement(e).z
      endif
      tdx#=x1#-mex# : tdy#=y1#-(mey#-40) : tdz#=z1#-mez#
      entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
      rem X10 weapon can also disappear after X seconds
      tremoveweaponfromgame=0
      if entityelement(e).eleprof.ex.decaytime>0
       if timer()-entityelement(e).timekilled>(entityelement(e).eleprof.ex.decaytime*1000)
        tremoveweaponfromgame=1
       endif
      endif
      if entityelement(e).plrdist<35
       rem player collects weapon from enemy (stores takeweaponammo in Quantity)
       weaponindex=tgunid
       weaponinvposition=pi : tgunid=weaponindex
       tqty=rnd(gun(tgunid).settings.reloadqty)
       gosub _player_addweapon
       rem for weapnisammo collections, add required ammo
       if gotweapon>0
        if gun(tgunid).settings.weaponisammo=0
         tqty=gun(tgunid).settings.reloadqty*entityelement(e).eleprof.quantity
         weaponclipammo(gotweapon)=weaponclipammo(gotweapon)+tqty
        else
         if tqty=0 then tqty=1
         if weaponammo(gotweapon)=0
          weaponammo(gotweapon)=tqty
         else
          weaponclipammo(gotweapon)=weaponclipammo(gotweapon)+tqty
         endif
        endif
       endif
       rem and play a reload sound from the gun (collection sound=reload)
       if gunsound(tgunid,2).soundid>0
        if sound exist(gunsound(tgunid,2).soundid)=1
         if sound playing(gunsound(tgunid,2).soundid)=0
          playinternalBC3dsound(gunsound(tgunid,2).soundid,camera position x(),camera position y(),camera position z(),1)
         endif
        endif
       endif
       rem and remove weapon from dead entity
       tremoveweaponfromgame=1
      endif
      if tremoveweaponfromgame=1
       rem remove weapon from game
       entityelement(e).currentweapon=0
       rem remove attached weapon from entity also
       tobj=entityelement(e).attachmentobj
       rem X10 and remove ode influence of dropped weapon
       if phyobjele(tobj)=-1
        gosub _physics_deleteentity
        phyobjele(tobj)=0
       endif
       if tobj>0
        hide object tobj
        rem move the parent gun as cannot hide it while being used as an instance
        position object tobj,-50000,-50000,-50000
       endif
      endif
     endif
    endif
   endif
  else
   `
   rem calculate distance from player even if dormant
   tdx#=entityelement(e).x-mex# : tdy#=entityelement(e).y-mey# : tdz#=entityelement(e).z-mez#
   entityelement(e).plrdist=sqrt(abs(tdx#*tdx#)+abs(tdy#*tdy#)+abs(tdz#*tdz#))
   `
   rem X10 objects are not dormant if they are near player
   rem moved entityelement(e).eleprof.phyalways flag use to ODE UPDATE code
   if entityelement(e).plrdist<500.0 or entityprofile(entid).ischaracter=1
    entityelement(e).dormant=0
   endif
   `
  endif
  `
 endif
next e

rem Entity Performance
inc gameperfentities1, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()

rem end of debug entire AI logic
if gshowdebugtextingamestate=1
 if debugviewtog=1
  ink rgb(255,255,0),0
 endif
endif

rem Steal priority if new entity closer
if tonestealperaiphase>0
 e=tonestealperaiphase : gosub _entity_stealpriorityandgivetoe
endif

rem Drop a priority entity if need to get some AI speed back
if logicpriorityfurtheste>0
 lastlogicpriorityfurthest#=logicpriorityfurthest#
 lastlogicpriorityfurtheste=logicpriorityfurtheste
 if logicprioritycount>int(logicprioritymax#)
  e=logicpriorityfurtheste
  gosub _entity_removeefromprioritylist
 endif
endif

rem Entity Performance
inc gameperfentities2, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()

rem Go through all entities for MOVEMENT
for e=1 to entityelementlist
 if entityelement(e).dormant=0
  obj=entityelement(e).obj
  entid=entityelement(e).bankindex
  gosub _entity_controlspawn
  if entityelement(e).spawn.leader=0
   if entityelement(e).active=1
    gosub _entity_controlwaypoints
    gosub _entity_controlforce
    gosub _entity_controlcollision
    gosub _entity_controlmovements
    gosub _entity_controldelayeddamage
   endif
  endif
 endif
next e

rem Entity Performance
inc gameperfentities3, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()

rem Calculate any logic drop increments/decrements
if screen fps()>=30
 if logicprioritymax#<10.0
  logicprioritymax#=logicprioritymax#+0.02
 endif
else
 logicprioritymax#=2.0
endif

rem X10 flag is set if a refraction element used
grefractionelementused=0

rem X10 timer based speed - machine independent
incspeed#=(1.0/40.0)*(timer()-lastincrementspeedtime) : lastincrementspeedtime=timer()

rem Go through all entities for VISUAL
for e=1 to entityelementlist
 obj=entityelement(e).obj
 entid=entityelement(e).bankindex
 rem V109 - 140109 - added allentsfulllogicatstartcount>0 so all level entities could sort themselves out (weapon pickups)
 if entityelement(e).active=1 and (entityelement(e).dormant=0 or allentsfulllogicatstartcount>0)
  if obj>0
   `
   if object exist(obj)=1
    `
    rem DEBUGENT 
    `text object screen x(obj),object screen y(obj),str$(entityelement(e).x)+" "+str$(entityelement(e).y)+" "+str$(entityelement(e).z)
    `text object screen x(obj),object screen y(obj)+30,str$(object position x(obj))+" "+str$(object position y(obj))+" "+str$(object position z(obj))
    `
    rem Operate spin and float system
    tspin#=0.0 : thover#=0.0
    if entityelement(e).spinrate<>0
     entityelement(e).spinvalue=entityelement(e).spinvalue+(entityelement(e).spinrate*incspeed#)
     tspin#=wrapvalue(entityelement(e).spinvalue)
    endif
    if entityelement(e).floatrate<>0
     entityelement(e).floatvalue=entityelement(e).floatvalue+(4*incspeed#)
     thover#=entityelement(e).floatrate+(cos(wrapvalue(entityelement(e).floatvalue))*entityelement(e).floatrate)
    endif
    `
    rem update entity object position (keep position for univese vis-culling)
    if entityelement(e).eleprof.physics=1
     rem regular physics driven
     entityelement(e).x=object position x(obj)
     entityelement(e).y=object position y(obj)
     entityelement(e).z=object position z(obj)
     entityelement(e).ry=object angle y(obj)
    else
     if entityelement(e).eleprof.physics=2
      rem entity driven physics (character)
      todee=e : gosub _physics_entitydrivenphysics
     else
      if entityelement(e).eleprof.physics=3
       rem entity is typically immobile (door/window)
       todee=e : gosub _physics_entitydrivenstaticphysics
      else
       rem no physics influences
       position object obj,entityelement(e).x,entityelement(e).y+thover#,entityelement(e).z
      endif
     endif
    endif
    `
    rem Animations need consistency when suddenly obj is visible
    gosub _entity_controlanim
    `
    rem if actually visible to camera
    if object visible(obj)=1
     `
     rem Only need decal creation if an existing obj is visible
     gosub _entity_controldecals
     `
     rem handle object rotation
     if entityelement(e).norotate=0
      yrotate object obj,entityelement(e).ry+tspin#
     endif
     `
     rem update animation frame of entity
     if entityelement(e).animframeupdate=1
      rem X10 actual object may be parent slot managed
      actualobj=entityelementwhichobj(e)
      if actualobj=0 then actualobj=obj
      stop object actualobj : set object interpolation actualobj,100
      rem X10 parent slot set elsewhere, when frame was initialised
      set object frame actualobj,entityelement(e).animframe
      entityelement(e).animframeupdate=0
     endif
     `
     rem Update head if available
     if entityprofile(entid).headlimb<>-1
      if limb exist(obj,entityprofile(entid).headlimb)=1
       rotate limb obj,entityprofile(entid).headlimb,curveangle(entityelement(e).ai.headangle,limb angle x(obj,entityprofile(entid).headlimb),3.0),limb angle y(obj,entityprofile(entid).headlimb),limb angle z(obj,entityprofile(entid).headlimb)
      endif
     endif
     `
     rem any visual overlay info
     if gshowentitygameinfostate=1 then gosub _entity_showdebugstringinfo
     `
     rem update alpha fade value
     if gmultiplayergame=1 and entityprofile(entid).ischaracter=1
      rem multiplayer - bug in 5.8, characters cannot control alpha (seem to be influenced by other objects)
      `x10 has no such bug (and interferes with char fade) set alpha mapping on obj,100
      `if entityprofile(entid).ischaracter<>0
      ` if entityelement(e).invincibleactive<>0
      `  ghost object on obj
      ` else
      `  ghost object off obj
      ` endif
      `endif
      rem find out which player
      ttplrindex=0 : ttplrel=0
      for ttel=1 to multiplayeridlinkmax
       if multiplayeridlink(ttel)<>1
        if characterchoiceentityindex(ttel)=e and ttplrel=0 then ttplrindex=multiplayerplrindex(ttel) : ttplrel=el
       endif
      next ttel
      if ttplrel>0 and player(ttplrindex).health>0
       rem X10 - 081107 - ensure healthy entities have full alpha (for now)
       set object transparency obj,2
       if entityelement(e).invincibleactive<>0
        set alpha mapping on obj,50
       else
        set alpha mapping on obj,100
       endif
       entityelement(e).ai.alphafade=100
      else
       rem X10 - 081107 - in multiplayer, fade out characters when they die
       `rem for the 12+ TEEN rating mode
       `if entityelement(e).ai.alphafade>0
       ` if entityelement(e).ai.alphafade>50 then entityelement(e).ai.alphafade=50
       ` entityelement(e).ai.alphafade=entityelement(e).ai.alphafade-2
       ` if entityelement(e).ai.alphafade<0 then entityelement(e).ai.alphafade=0
       ` entityelement(e).ai.destalphafade=entityelement(e).ai.alphafade
       `endif
       `set alpha mapping on obj,entityelement(e).ai.alphafade
       `X10-141107 - instant disappear (the fall back thing is still too 16+)
       entityelement(e).ai.alphafade=0
       entityelement(e).ai.destalphafade=0
       set alpha mapping on obj,entityelement(e).ai.alphafade
      endif
     else
      rem keep for single player
      if entityelement(e).invincibleactive<>0
       set alpha mapping on obj,50+rnd(25)
      else
       if entityelement(e).ai.alphafadeupdate=1
        set alpha mapping on obj,entityelement(e).ai.alphafade
        entityelement(e).ai.alphafadeupdate=0
       endif
      endif
     endif
     `
     rem X10 flag is set if a refraction element used
     if object in screen(obj)=1
      if entityelementusingrefraction(e)=1
       grefractionelementused=1
      endif
     endif
     `
     rem blob shadow control (all other non local plrs) (might be performance issue here)
     if entityelement(e).attachmentblobobj>0 and entityelement(e).beenkilled=0
      if object exist(entityelement(e).attachmentblobobj)=1
       rem override blob shadow for per-entity 'prompt icon'
       rem only if showallyicon flag is set to YES
       if entityelement(e).eleprof.aiss.thinkingprompt>0 and entityelement(e).eleprof.ex.showallyicon=1
        entityelement(e).eleprof.aiss.thinkingcount=entityelement(e).eleprof.aiss.thinkingcount-1
        if entityelement(e).eleprof.aiss.thinkingcount>0
         rem use blob shadow to create order-icon above entity
         `tmvszy#=(object size y(obj)/2) X10 V109 - 090309 - apply scale
         tmvszy#=((object size y(obj)/2)*entityprofile(entid).scale)/100.0
         tmvy#=object position y(obj)+tmvszy#
         position object entityelement(e).attachmentblobobj,camera position x(playercam),camera position y(playercam),camera position z(playercam)
         point object entityelement(e).attachmentblobobj,object position x(obj),tmvy#,object position z(obj)
         tmvy#=tmvy#+(entityelement(e).eleprof.aiss.thinkingcount/3.0)
         position object entityelement(e).attachmentblobobj,object position x(obj),tmvy#,object position z(obj)
         set object cull entityelement(e).attachmentblobobj,0
         show object entityelement(e).attachmentblobobj
         texture object entityelement(e).attachmentblobobj,attachmenticonimagestart+entityelement(e).eleprof.aiss.thinkingprompt
         scale object entityelement(e).attachmentblobobj,50,50,50
         if entityelement(e).eleprof.aiss.thinkingcount<20
          set alpha mapping on entityelement(e).attachmentblobobj,entityelement(e).eleprof.aiss.thinkingcount*5
         else
          if entityelement(e).eleprof.aiss.thinkingcount>40
           set alpha mapping on entityelement(e).attachmentblobobj,(50-entityelement(e).eleprof.aiss.thinkingcount)*10.0
          else
           set alpha mapping on entityelement(e).attachmentblobobj,100
          endif
         endif
         set object mask entityelement(e).attachmentblobobj,%100000,%0000,%00
        else
         rem restore blob shadow
         set object cull entityelement(e).attachmentblobobj,1
         set alpha mapping on entityelement(e).attachmentblobobj,100
         texture object entityelement(e).attachmentblobobj,attachmenticonimagestart+0
         rotate object entityelement(e).attachmentblobobj,90,0,0
         scale object entityelement(e).attachmentblobobj,100,100,100
         set object mask entityelement(e).attachmentblobobj,%110010,%0100,%10 : rem shadow in game
         entityelement(e).eleprof.aiss.thinkingcount=0
         entityelement(e).eleprof.aiss.thinkingprompt=0
        endif
       else
        rem blob shadow use
        if shadowobj(entityelement(e).obj)=0
         if (gmultiplayergame=0 and entityelement(e).health>0) or (gmultiplayergame=1 and entityelement(e).collisionactive<>0)
          `dst#=static raycast(entityelement(e).x,entityelement(e).y+5,entityelement(e).z,entityelement(e).x,entityelement(e).y-50,entityelement(e).z)
          dst#=AI RAY CAST(entityelement(e).x,entityelement(e).y+5,entityelement(e).z,entityelement(e).x,entityelement(e).y-50,entityelement(e).z)
          if dst#<>-1
           dst#=dst#*55.0
          else
           dst#=0
          endif
         else
          dst#=0.0
         endif
        else
         dst#=0.0
        endif
        if dst#>0
         dst#=dst#-5.0
         `tmvszy#=(object size y(obj)/2) X10 V109 - 090309 - apply scale
         tmvszy#=((object size y(obj)/2)*entityprofile(entid).scale)/100.0
         tmvy#=object position y(obj)-tmvszy#
         position object entityelement(e).attachmentblobobj,object position x(obj),(tmvy#-dst#)+0.5,object position z(obj)
         show object entityelement(e).attachmentblobobj
         tsc#=(100.0-dst#) : scale object entityelement(e).attachmentblobobj,tsc#,tsc#,tsc#
        else
         hide object entityelement(e).attachmentblobobj
        endif
       endif
      endif
      rem 011007 - added object exist(entityelement(e).attachmentblobobj+1+1)=1
      if object exist(entityelement(e).attachmentblobobj+1)=1 and object exist(entityelement(e).attachmentblobobj+1+1)=1
       if entityelement(e).eleprof.ex.showhealthbar=0 or gmultiplayergame=1
        rem arena has no helth bar, and nor do entities that have it switched off
       else
        rem health bar blob border and bar
        for t=0 to 1
         tattachmentblobobj2=entityelement(e).attachmentblobobj+1+t
         `tmvszy#=(object size y(obj)/2) X10 V109 - 090309 - apply scale
         tmvszy#=((object size y(obj)/2)*entityprofile(entid).scale)/100.0
         tmvy#=object position y(obj)+tmvszy#
         tmvy#=tmvy#+(tmvszy#*0.1)
         position object tattachmentblobobj2,object position x(obj),tmvy#,object position z(obj)
         set object to camera orientation tattachmentblobobj2
         set object cull tattachmentblobobj2,0
         if t=1
          rem move health bar
          if entityelement(e).eleprof.strength>0
           thealthperc#=entityelement(e).health
           thealthperc#=thealthperc#/(entityelement(e).eleprof.strength+0.0)
          else
           thealthperc#=1.0
          endif
          scale object tattachmentblobobj2,100*thealthperc#,100,100
         endif
         if entityelement(e).plrdist<300
          set alpha mapping on tattachmentblobobj2,100
          show object tattachmentblobobj2
         else
          if entityelement(e).plrdist<400
           set alpha mapping on tattachmentblobobj2,(400-entityelement(e).plrdist)
           show object tattachmentblobobj2
          else
           hide object tattachmentblobobj2
          endif
         endif
        next t
       endif
      endif
     endif
     `
    else
     `
     rem Limited debug info view of entities not visible (for spawn debugging)
     if gshowentitygameinfostate=1 then gosub _entity_showdebugstringinfo
     `
    endif
    `
   endif
   `
  else
   `
   rem entity has no OBJ
   if entityprofile(entid).ismarker=4
    rem emission markers can emit decals of course
    gosub _entity_controldecals
   endif
   `
  endif
 endif
 `
 rem 060807 - monitor entity for splash (dead or alive, or not facing at the time)
 if entityelement(e).dormant=0
  if obj>0
   if object exist(obj)=1
    gosub _entity_monitorforsplash
   endif
  endif
 endif
 `
next e

rem Display vis col map (as radar test)
`if (debugviewmode<>0 or showfpsinrealgame=2) and entitysystemdisabled=0 and 0
if 0
 lock pixels
 thorizpos=64
 metx=camerapositionx/25 : mety=camerapositiony/100 : metz=camerapositionz/-25
 line thorizpos,470,thorizpos+82,470 : line thorizpos,553,thorizpos+82,553
 line thorizpos,470,thorizpos,553 : line thorizpos+82,470,thorizpos+82,553
 for tx=metx-20 to metx+20
  for ty=mety to mety
   for tz=metz-20 to metz+20
    tdot=0
    if tx>=0 and tx<=160 and ty>=0 and ty<=5 and tz>=0 and tz<=160
     if viscolmap(tx,ty,tz)<>0
      tdot=1
     endif
    else
     if (tx=-1 or tx=161) and tz>=0 and tz<=160
      tdot=1
     endif
     if (tz=-1 or tz=161) and tx>=0 and tx<=160
      tdot=1
     endif
    endif
    if tdot=1
     dot thorizpos+41+((tx-metx)*2),511+((tz-metz)*2)
     dot thorizpos+41+((tx-metx)*2),512+((tz-metz)*2)
     dot thorizpos+42+((tx-metx)*2),511+((tz-metz)*2)
     dot thorizpos+42+((tx-metx)*2),512+((tz-metz)*2)
    endif
   next tz
  next ty
 next tx
 unlock pixels
endif

rem Entity Performance
inc gameperfentities4, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()

rem X10 AI control of entities
gosub _aiss_control

rem Entity Performance
inc gameperfentities5, perftimer()-gameperftimestamplocal : gameperftimestamplocal=perftimer()

return

_entity_monitorforsplash:
 `
 rem X10 entity can have a splash if they enter the water at force
 if (entityelement(e).eleprof.physics=1 or entityelement(e).eleprof.physics=2) and splashdecalid>0
  rem if regular physics obj or character obj
  waterlevelforsplash#=waterlevel#
  if entityelement(e).eleprof.physics=2
   rem character/ragdoll center
   tactualbaseofobject#=object position y(entityelement(e).obj)
  else
   tactualbaseofobject#=object position y(entityelement(e).obj)-(object size y(entityelement(e).obj)/2.0)
  endif
  if tactualbaseofobject#<waterlevelforsplash#
   if entityelement(e).decalloop=0
    rem measure velocity on impact with water
    velocity#=0.0
    if entityelement(e).obj>0 and entityelement(e).obj<array count(phyobjele())
     ttobj=entityelement(e).obj : gosub _physics_getvelocityy
    endif
    if entityelement(e).eleprof.physics=2
     velocity#=velocity#*5.0
    endif
    if velocity#>25.0
     rem set so only do one splash per entry into water
     if waterdecalripple<>0
      rem and only if water does ripple
      entityelement(e).decalloop=1
      decalx=object position x(entityelement(e).obj)
      decalz=object position z(entityelement(e).obj)
      if camera position y(playercam)<waterlevel#
       decaly=waterlevel#
      else
       decaly=(waterlevel#-50)+(velocity#/2.0)
      endif
      if decaly>waterlevel# then decaly=waterlevel#
      gosub _entity_makeasplash
     endif
    endif
   else
    rem entity in IN water
    rem if entity disturbing surface, fire off random rippe now and then
    if rnd(150)=0 and waterdecalripple<>0
     rem and only if water does ripple
     if abs(object position y(entityelement(e).obj)-waterlevel#)<25.0
      decalid=waterdecalripple
      decalorient=0
      decalx=object position x(entityelement(e).obj)
      decaly=waterlevel#+1.0
      decalz=object position z(entityelement(e).obj)
      decalorient=2
      decalscalemodx=20+(abs(entityelement(e).eleprof.phyweight)/50.0) : decalscalemody=decalscalemodx
      decalalpha=15
      originatore=0 : gosub _decalelement_create     
     endif
    endif
   endif
  else
   rem if entity leaves water, reset splash flag
   if entityelement(e).decalloop=1
    if tactualbaseofobject#>waterlevelforsplash#
     rem completely out of water, gravity back on
     entityelement(e).decalloop=0
    endif
   endif
  endif
 endif
 `
return

_entity_fillviscolmap:
 `
 rem Fill empty map tiles with no-walk id
 for tmx=0 to 39
  for tmz=0 to 39
   for tml=0 to 4
    for tx=0 to 3
     for tz=0 to 3
      viscolmap((tmx*4)+tx,tml,(tmz*4)+tz)=0
     next tz
    next tx
   next tml
  next tmz
 next tmx
 `
 rem use map data to determine where layer holes are (so characters cannot fall off ledges)
 for tmx=0 to 39
  for tmz=0 to 39
   for tml=0 to 19
    if map(tml,tmx,tmz)=0
     for tx=0 to 3
      for tz=0 to 3
       viscolmap((tmx*4)+tx,tml,(tmz*4)+tz)=-2
      next tz
     next tx
    endif
   next tml
  next tmz
 next tmx
 `
return

_entity_shotbygun:

rem need gunid, e, bulletraytype, x#, x1#
tix#=x#-x1# : tiy#=y#-y1# : tiz#=z#-z1#
tnorm#=(abs(tix#)+abs(tiy#)+abs(tiz#))/3.0
tix#=tix#/tnorm# : tiy#=tiy#/tnorm# : tiz#=tiz#/tnorm#
`
rem bulletraytype (1-pierce, 2-shotgun)
tentid=entityelement(e).bankindex
if gmultiplayergame=0
 rem impact force property is 75 is norma0 for mild blast
 tforce#=0.01*(gun(gunid).settings.impactforce*gun(gunid).settings.impactforce)
 rem entity prone to force
 if entityelement(e).eleprof.isimmobile=0
  rem apply force
  rem X10 also, if a ragdoll when shot, also apply force
  rem X10 or it is a character (soon to be ragdoll)
  if entityelement(e).eleprof.physics=1
   rem using advanced physics (force is soft if entity destroyed in hit)
   todee=e : tdx#=tix# : tdy#=tiy# : tdz#=tiz# : todefalloff#=0.0
   todeforce#=tforce# : tpx#=x# : tpy#=y# : tpz#=z# : gosub _physics_applypointforce
  else
   if entityprofile(tentid).ischaracter=1
    rem X10 240907 - used now for brief knock back effect
    if useknockbackasplayershotcharacter=1
     entityelement(e).eleprof.aiss.knockbackx=tix#*15
     entityelement(e).eleprof.aiss.knockbackz=tiz#*15
    else
     entityelement(e).eleprof.aiss.knockbackx=0
     entityelement(e).eleprof.aiss.knockbackz=0
    endif
    rem X10 and used later when convert to ragdoll
    if entityelement(e).health<=0
     rem if health low
     entityelement(e).force.active=1+tforce#
     entityelement(e).force.ix=tix#
     entityelement(e).force.iy=tiy#
     entityelement(e).force.iz=tiz#
     rem 040707 - provide origin of force (for later use in ragdoll velocity)
     entityelement(e).force.originx=x1#
     entityelement(e).force.originy=y1#
     entityelement(e).force.originz=z1#
    endif
   else
    rem using regular force calc
    entityelement(e).force.active=1
    entityelement(e).force.ix=tix#*tforce#
    entityelement(e).force.iy=tiy#*tforce#
    entityelement(e).force.iz=tiz#*tforce#
    rem 040707 - provide origin of force
    entityelement(e).force.originx=x1#
    entityelement(e).force.originy=y1#
    entityelement(e).force.originz=z1#
   endif
  endif
 endif
endif

return

_entity_controlsingleai:

rem get functional overview
gosub _entity_controlrecalcdist

rem before any point of logic, if no health in main AI, die
if entityelement(e).ai.libindex=entityelement(e).ai.libmain
 if entityelement(e).health<=0
  entityelement(e).ai.libindex=entityelement(e).ai.libdestroy
  entityelement(e).ai.waypoint.state=0
  entityelement(e).ai.headangle=0
  entityelement(e).ai.state=0
 endif
endif

rem New AI Script flag
trundefaultscript=0
taddforcesphere=0

rem Get AI Script for Entity Element
aiindex=entityelement(e).ai.libindex
gosub _ai_control
`
rem X10 special force sphere (subtle enough not to move anything, but nudge physics)
if entityelement(e).obj>0
 if phyobjelenudged(entityelement(e).obj)<>0
  rem send vibrations to nudge other entites in area
  taddforcesphere=1
 endif
endif
`
rem Apply force if actioned
if taddforcesphere>0
 spherex#=entityelement(e).x
 spherey#=entityelement(e).y
 spherez#=entityelement(e).z
 sphereforce#=taddforcesphere/100.0
 gosub _entity_addforcesphere
endif
`
rem Weapon Control for entities
if entityelement(e).fireweapon=1
 tgunid=entityelement(e).currentweapon
 if tgunid>0
  `
  rem WEAPON USAGE
  `
  rem start of shot pos
  if entityprofile(entid).firespotlimb>-1
   x1#=limb position x(obj,entityprofile(entid).firespotlimb)
   y1#=limb position y(obj,entityprofile(entid).firespotlimb)
   z1#=limb position z(obj,entityprofile(entid).firespotlimb)
  else
   x1#=entityelement(e).x
   y1#=entityelement(e).y+45.0
   z1#=entityelement(e).z
  endif
  `
  rem weapon type
  flakid=gun(tgunid).settings.flakindex
  if flakid=0
   `
   rem BULLET
   rem initial shot creates light flash
   if spotmultiplier#<>5.0
    spotflash=100 : spotmultiplier#=1.0
    tx#=x1# : ty#=y1# : tz#=z1#
    tcolr=gun(tgunid).settings.muzzlecolorr/3
    tcolg=gun(tgunid).settings.muzzlecolorg/3
    tcolb=gun(tgunid).settings.muzzlecolorb/3
    gosub _lighting_spotflash
   endif
   `
   rem X10 gunsmoke effect (only if not laser)
   if gun(tgunid).settings.muzzlelasertype=0
    if particlegunsmoke<>0
     inc particlegunsmoke
     if particlegunsmoke>5 then particlegunsmoke=1
     rem emissions are switched off, can create them individually using new command
     emit particle particlegunsmoke,x1#,y1#,z1#
    endif
   endif
   `
   rem discharge sound (single fire, or automatic loop sound)
   tsndid=gunsoundcompanion(tgunid,1,rnd(2)).soundid
   if tsndid>0
    set sound volume tsndid,soundvolumes(1)
    if gun(tgunid).action.automatic.s>0
     if entityelement(e).firesoundloop=0
      play sound tsndid,gun(tgunid).sound.fireloopend : rem some sound bug
      loop sound tsndid,0,gun(tgunid).sound.fireloopend
      entityelement(e).firesoundloop=tsndid
     endif
    else
     play sound tsndid
    endif
    posinternal3dsound(tsndid,x1#,y1#,z1#)
    broadcast3dsound(x1#,y1#,z1#,100.0)
   endif
   `
   rem gun data for accuracy
   trayaccuracy=gun(tgunid).settings.accuracy
   `
   rem project gun-line-for-shot (from raw-calc or target)
   if entityelement(e).actualtarget<>0
    rem no accuracy drift if close
    x2#=entityelement(e).actualtargetx
    y2#=entityelement(e).actualtargety
    z2#=entityelement(e).actualtargetz
    tdx#=abs(x2#-x1#)
    tdy#=abs(y2#-y1#)
    tdz#=abs(z2#-z1#)
    tdd#=sqrt((tdx#*tdx#)+(tdy#*tdy#)+(tdz#*tdz#))
    rem greater than 200 units add drift
    if tdd#>200.0
     rem add a basic distance drift to enemy shooing (human error)
     trayaccuracy=(trayaccuracy*5)+rnd((tdd#-200)*2)
     rem Work out final trajectory of shot
     x2#=entityelement(e).actualtargetx+trayaccuracy-rnd(trayaccuracy*2)
     y2#=entityelement(e).actualtargety+trayaccuracy-rnd(trayaccuracy*2)
     z2#=entityelement(e).actualtargetz+trayaccuracy-rnd(trayaccuracy*2)
    endif
   else
    position object hudbankoffset+3,x1#,y1#,z1#
    rotate object hudbankoffset+3,0,entityelement(e).mover.da,0
    move object hudbankoffset+3,gun(tgunid).settings.range
    disable object zdepth hudbankoffset+3
    x2#=object position x(hudbankoffset+3)+trayaccuracy-rnd(trayaccuracy*2)
    y2#=object position y(hudbankoffset+3)+trayaccuracy-rnd(trayaccuracy*2)
    z2#=object position z(hudbankoffset+3)+trayaccuracy-rnd(trayaccuracy*2)
   endif
   `
   rem had bulletray hit anything solid
   tbullethit=0 : tbullethitstatic=0
   tbullethitmaterial=0 : tbullethitflesh=0
   entityelement(e).raycastcount=0
   rem X10 new ray cast quicker
   if 1
    dst#=AI ray cast(x1#,y1#,z1#,x2#,y2#,z2#) `but we need info coming back for material
    if dst#<>-1
     dstx#=(x2#-x1#)*dst#
     dsty#=(y2#-y1#)*dst#
     dstz#=(z2#-z1#)*dst#
     dst#=sqrt(abs(dstx#*dstx#)+abs(dsty#*dsty#)+abs(dstz#*dstz#))
     if dst#<>0
      x#=x1#+dstx# : x2#=x#
      y#=y1#+dsty# : y2#=y#
      z#=z1#+dstz# : z2#=z#
      tbullethitstatic=1 : tbullethit=1
      tcolmaterial=0 : tbullethitmaterial=tcolmaterial
     endif
    endif
   else
    dst#=static raycast(x1#,y1#,z1#,x2#,y2#,z2#)
    if dst#<>0
     x#=checklist fvalue a(6) : x2#=x#
     y#=checklist fvalue b(6) : y2#=y#
     z#=checklist fvalue c(6) : z2#=z#
     tbullethitstatic=1 : tbullethit=1
     tcolmaterial=get static collision value()-1
     if tcolmaterial>=0 and tcolmaterial<=99 then tbullethitmaterial=tcolmaterial
    endif
   endif
   `
   rem if it hits player before wall, hurt player
   if entityelement(e).actualtarget=1
    dst#=intersect object(hudbankoffset+2,x1#,y1#,z1#,x2#,y2#,z2#)
    if dst#<>0 or tdd#<125.0
     tbullethitstatic=0
    endif
   endif
   `
   rem where wall not hit, must be a hit
   if tbullethitstatic=0
    trange#=gun(tgunid).settings.range
    tperc#=(trange#-dst#)/trange#
    if dst#<200 then tperc#=1.0
    bulletdamage#=gun(tgunid).settings.damage : dec bulletdamage#,rnd(bulletdamage#/5)
    if gun(tgunid).settings.damage>5
     rem enemy fire always one half the players effectiveness after first few points
     tperc#=tperc#*0.5
    endif
    tdamage#=bulletdamage#*tperc# : tdamage=tdamage#
    if entityelement(e).actualtarget=1
     rem player was the target
     if tdamage>0 then gosub _player_takedamage
     if player(1).health<=0
      rem hear the full sound of what killed you
      if tsndid>0
       playinternal3dsound(tsndid,camera position x(),camera position y(),camera position z())
      endif
     endif
    else
     rem entity was the target (store E while leap to other entity for damage control)
     if entityelement(e).actualtarget>1 and tdamage>0
      tdamagesource=0 : timpacttype=1
      tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
      stte=e : e=entityelement(e).actualtarget-1
      gosub _entity_deducthealth
      stgunid=gunid : gunid=tgunid
      bulletraytype=gun(gunid).settings.damagetype
      x#=x2# : y#=y2# : z#=z2# : rem destination of target is point of impact here
      useknockbackasplayershotcharacter=0
      gosub _entity_shotbygun
      gunid=stgunid
      e=stte
      tentid=entityelement(e).bankindex
      entid=entityelement(e).bankindex
     endif
    endif
    tbullethitstatic=0 : tbullethit=1
    tbullethitflesh=1
   endif
   `
   rem bullet result
   if tbullethit=1
    `x9rem debris where the bullet struck
    `for p=1 to 32
    ` if debris(p)=0
    `  rem debris where the bullet struck
    `  position particles p,x#,0,z#
    `  position particle emissions p,0,y#/20.0,0
    `  set particle emissions p,10
    `  debris(p)=40
    `  exit
    ` endif
    `next p
    `x9 rem add scorch if hit universe static polygons
    rem scorch from 50 shots too intense, do not scorch from enemy shots
    `if tbullethitstatic=1
    ` tscorchtype=gun(tgunid).settings.scorchtype
    ` gosub _entity_doscorch
    `endif    
   endif
   `
  else
   `
   rem FLAK (grenames, rockets)
   tsndid=gunsoundcompanion(tgunid,1,rnd(2)).soundid
   playinternal3dsound(tsndid,x1#,y1#,z1#)
   broadcast3dsound(x1#,y1#,z1#,15.0)
   `
   rem determine if need to pitch the launch based on direction and distance
   flakpitch=0
   if flak(flakid).throwangle=0
    rem LAUNCH
    tdx#=mex#-entityelement(e).x
    tdz#=mez#-entityelement(e).z
    tdy#=(mey#-50)-entityelement(e).y
    flakpitch=atanfull(tdy#,sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#)))*-1
   else
    rem LOB
    if entityelement(e).actualtarget<>0
     y2#=entityelement(e).actualtargety
     if y2#>entityelement(e).y-100.0
      x2#=entityelement(e).actualtargetx
      z2#=entityelement(e).actualtargetz
      tdx#=abs(x2#-entityelement(e).x)
      tdy#=abs(y2#-entityelement(e).y)
      tdz#=abs(z2#-entityelement(e).z)
      tdd#=sqrt((tdx#*tdx#)+(tdy#*tdy#)+(tdz#*tdz#))
      flakpitch=22.0+((45.0/500.0)*tdd#)
      if flakpitch>80 then flakpitch=80
      if flakpitch<22.0 then flakpitch=22.0
      flakpitch=flakpitch*-1.0
     endif
    endif
   endif
   `
   rem launch the flak
   flakangle=entityelement(e).mover.da : flakowner=e
   flakx=x1#+newxvalue(0,flakangle+flak(flakid).throwangle,flak(flakid).throwforward)
   flaky=y1#+flak(flakid).throwheight
   flakz=z1#+newzvalue(0,flakangle+flak(flakid).throwangle,flak(flakid).throwforward)
   flakspeed#=2.0
   gosub _flakelement_create
   `
  endif
  rem a pause while guns cools down (fingers of shooter release trigger and repress)
  entityelement(e).fireweapon=2
 else
  rem fired but no weapon carried
 endif
else
 if entityelement(e).fireweapon=101
  `
  rem NON-WEAPON MELEE USAGE
  rem is called at end of melee strike animation, so hurt target (allies can melee enemies too)
  `
  tdamage=entityprofile(entid).strength/5
  if tdamage=0 then tdamage=1
  if entityelement(e).actualtarget=1
   rem player was the target
   if tdamage>0 then gosub _player_takedamage
   if player(1).health<=0
    rem hear the full sound of what killed you
    if tsndid>0
     playinternal3dsound(tsndid,camera position x(),camera position y(),camera position z())
    endif
   endif
  else
   rem entity was the target (store E while leap to other entity for damage control)
   if entityelement(e).actualtarget>1 and tdamage>0
    tdamagesource=0 : timpacttype=1
    tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
    stte=e : e=entityelement(e).actualtarget-1
    gosub _entity_deducthealth
    e=stte
   endif
  endif
  `  
  rem completed melee strike, withdraw arm ready to hit again (cool down)
  entityelement(e).fireweapon=102
  `
 else
  `
  rem WEAPON COOL DOWN
  if entityelement(e).fireweapon>0 and entityelement(e).fireweapon<100
   if entityelement(e).fireweapon>0
    tgunid=entityelement(e).currentweapon
    entityelement(e).fireweapon=entityelement(e).fireweapon+1
    if gun(tgunid).action.automatic.s>0
     if entityelement(e).currentammo<=0 and entityelement(e).firesoundloop>0
      stop sound entityelement(e).firesoundloop
      entityelement(e).firesoundloop=0
     endif
     if entityelement(e).fireweapon>6
      entityelement(e).fireweapon=0
     endif
    else
     if entityelement(e).fireweapon>30 then entityelement(e).fireweapon=0
    endif
   endif
  endif
  `
  rem MELEE COOL DOWN
  if entityelement(e).fireweapon>100 and entityelement(e).fireweapon<200
   entityelement(e).fireweapon=entityelement(e).fireweapon+1
   if entityelement(e).fireweapon>130 then entityelement(e).fireweapon=0
  endif  
  `
 endif
endif
`
rem If firing over, but fire loop still going, stop it
if entityelement(e).fireweapon=0
 if entityelement(e).firesoundloop>0
  stop sound entityelement(e).firesoundloop
  entityelement(e).firesoundloop=0
 endif
endif
`
rem Switch to FPI AI Scripts
if trundefaultscript>0
 `
 rem About to leave main?
 tleavingmain=0
 if entityelement(e).ai.libindex=entityelement(e).ai.libmain then tleavingmain=1
 `
 rem Switch to specified AI scripts
 entityelement(e).ai.libindex=trundefaultscript-1
 trundefaultscript=0
 `
 rem If returning from internal AI switch
 if entityelement(e).ai.usinginternalai=1
  rem restore old state values
  entityelement(e).ai.waypoint.state=entityelement(e).ai.oldwaypointstate
  entityelement(e).ai.alphafade=entityelement(e).ai.oldalphafade
  entityelement(e).ai.state=entityelement(e).ai.oldstate
  entityelement(e).ai.usinginternalai=0
 else
  if trundefaultscriptinternal=1 and tleavingmain=1
   gosub _entity_storemainai
  endif
  entityelement(e).ai.waypoint.state=0
  entityelement(e).ai.state=0
 endif
 `
 rem Always reset these after AI script switch
 entityelement(e).ai.headdestangle=0
 entityelement(e).ai.headangle=0
 `
endif

return

_entity_doscorch:
 rem material damage
 if tbullethitmaterial>0
  tscorchsize2#=4.0+(rnd(10)/10.0) : tscorchtype2=11+tbullethitmaterial
  if tscorchtype2>15 then tscorchtype2=12 : rem FPSCV101 - fix
  add static scorch tscorchsize2#,tscorchtype2
 endif
 if tbullethitflesh>0
  rem blood splat
  tscorchtype3=8+rnd(3)
  tscorchsize3#=10.0+((tbullethitflesh/100.0)*(20.0+rnd(20)))
  add static scorch tscorchsize3#,tscorchtype3
 else
  rem bullethole
  tscorchsize#=2.0+(rnd(10)/10.0)
  if tscorchtype>=2 then tscorchsize#=3.0+(rnd(10)/10.0)
  add static scorch tscorchsize#,tscorchtype
 endif
return

_entity_controlspawn:

rem Only leaders control spawn events (activated is automatic for spawn switch on)
if entityelement(e).spawn.leader=1 and entityelement(e).spawn.atstart=0 and entityelement(e).activated=1 then entityelement(e).spawn.atstart=1
if entityelement(e).spawn.leader=1 and entityelement(e).spawn.atstart=1
 rem Count down to next spawn
 if entityelement(e).spawn.afterdelay=1
  entityelement(e).spawn.leadercount=entityelement(e).spawn.leadercount-1
 endif
 rem If count goes to zero (and have some left 'upto')
 tpermitaspawn=0
 if entityelement(e).spawn.upto>0
  if entityelement(e).spawn.leadercount<=0 then tpermitaspawn=1
  if entityelement(e).spawn.whendead=1
   for te=1+e to e+entityelement(e).spawn.max
    tobj=entityelement(te).obj
    if tobj>0
     if object exist(tobj)=1 and entityelement(te).active=0
      if entityelement(te).beenkilled=1
       rem X10 and not still in ragdoll decent
       if entityelementusingode(te)<=1
        rem X10 - 101007 - flag would be reset and no allow a respawn here, so remove reset (it is not further down duting recreation)
        `entityelement(te).beenkilled=0
        tpermitaspawn=1 : exit
       endif
      endif
     endif
    endif
   next te
  endif
 endif
 rem X10 240707 - singleplrspawnfreeze used when physics tops 100,000 (prevent physics penetration via more spawning)
 if tpermitaspawn=1 and singleplrspawnfreeze=0
  rem Restart spawn cycle
  entityelement(e).spawn.leadercount=entityelement(e).spawn.delay+rnd(entityelement(e).spawn.delayrandom)
  rem Find child of this leader to spawn
  tproduceqty=0
  tnumbertospawn=entityelement(e).spawn.qty+rnd(entityelement(e).spawn.qtyrandom)
  for te=1+e to e+entityelement(e).spawn.max
   tobj=entityelement(te).obj
   if tobj>0
    if object exist(tobj)=1 and entityelement(te).active=0 and entityelementusingode(te)<=1
     `
     rem only if the entity to spawn is not still a ragdoll
     `
     rem find place not occupied if entity driven object
     if entityelement(te).eleprof.physics=0 or entityelement(te).eleprof.physics=2
      `
      tentid=entityelement(e).bankindex
      if entityprofile(tentid).ischaracter=0
       `
       rem non-characters do not deviate from spawn position
       entityelement(te).x=entityelement(e).spawn.x
       entityelement(te).y=entityelement(e).spawn.y
       entityelement(te).z=entityelement(e).spawn.z
       tokay=1
       `
      else
       `
       rem X10 suggest only spawn when spawn area free of all entities :)
       entityelement(te).x=entityelement(e).spawn.x+rnd(50)-25
       entityelement(te).y=entityelement(e).spawn.y
       entityelement(te).z=entityelement(e).spawn.z+rnd(50)-25
       tokay=1
       `
       rem X10 - 101007 - scan spawn buddies and move this spawner if someone already at origin
       tscanradius=0
       while tscanradius<360
        tcannostandhere=0
        for scane=e+1 to e+entityelement(e).spawn.max
         tscanobj=entityelement(scane).obj
         if tscanobj>0 and scane<>te
          if object exist(tscanobj)=1 and entityelement(scane).active=1
           tscandx#=entityelement(te).x-entityelement(scane).x
           tscandy#=entityelement(te).y-entityelement(scane).y
           tscandz#=entityelement(te).z-entityelement(scane).z
           tscandist#=sqrt(abs(tscandx#*tscandx#)+abs(tscandy#*tscandy#)+abs(tscandz#*tscandz#))
           if tscandist#<25
            tcannostandhere=1
           endif
          endif
         endif
        next scane
        inc tscanradius,45
        if tcannostandhere=1
         entityelement(te).x=newxvalue(entityelement(e).spawn.x,tscanradius,30.0)   
         entityelement(te).z=newzvalue(entityelement(e).spawn.z,tscanradius,30.0)   
        else
         tscanradius=370
        endif
       endwhile
       `
      endif
      `
     else
      entityelement(te).x=entityelement(e).spawn.x
      entityelement(te).y=entityelement(e).spawn.y
      entityelement(te).z=entityelement(e).spawn.z
      tokay=1
     endif
     `
     rem if space, init entity with AIINIT
     if tokay=1
      `
      entityelement(te).active=1
      entityelement(te).dormant=1
      entityelement(te).beenkilled=0 : rem X10 - 101007 - seems flag not always reset!
      entityelement(te).ai.libindex=entityelement(te).ai.libinit
      entityelement(te).ai.waypoint.state=0
      entityelement(te).ai.waypoint.tracker=0
      entityelement(te).ai.waypoint.current=0
      entityelement(te).ai.state=0
      entityelement(te).ai.headangle=0
      entityelement(te).ai.headdestangle=0
      entityelement(te).ai.usinginternalai=0
      entityelement(te).ai.oldstate=0
      entityelement(te).ai.oldwaypointstate=0
      entityelement(te).actualtarget=0
      entityelement(te).losttargetcount=0
      `
      rem X10 - V109 - 180309 - defaults to fading in spawned objects
      entityelement(te).ai.alphafade=0
      entityelement(te).ai.oldalphafade=0
      entityelement(te).ai.destalphafade=100      
      `
      entityelement(te).rx=entityelement(e).rx
      entityelement(te).ry=entityelement(e).ry
      entityelement(te).rz=entityelement(e).rz
      entityelement(te).mover.da=entityelement(e).ry
      `
      entitybreadcrumbs(te,0).x=0
      entityelement(te).mover.grav=1.0
      entityelement(te).mover.moved=0
      entityelement(te).mover.inmotion=0
      entityelement(te).mover.ix=0
      entityelement(te).force.ix=0
      entityelement(te).mover.iy=0
      entityelement(te).force.iy=0
      entityelement(te).mover.iz=0
      entityelement(te).force.iz=0
      entityelement(te).force.active=0
      entityelement(te).logiccount=0
      entityelement(te).blockedby=0
      `
      entityelement(te).delaydamagecount=0
      entityelement(te).delaydamagesource=0
      entityelement(te).delaydamage=0
      entityelement(te).delayimpact=0
      entityelement(te).delaydamagex#=0
      entityelement(te).delaydamagey#=0
      entityelement(te).delaydamagez#=0
      entityelement(te).delaydir=0
      `
      rem reset entity that reappears in game
      if entityelement(te).eleprof.strength>0
       entityelement(te).health=entityelement(e).eleprof.strength
      else
       entityelement(te).health=1
      endif
      entityelement(te).eleprof.lives=entityelement(e).eleprof.lives
      entityelement(te).shotdamage=0
      entityelement(te).shotdamagesource=0
      `
      rem clear out dake player info
      tplrid=entityelement(e).fakeplayerid
      player(tplrid).inventorymax=0
      `
      rem put weapon back in character hands
      entityelement(te).currentweapon=entityelement(e).eleprof.hasweapon
      entityelement(te).currentclipammo=9999
      entityelement(te).firesoundloop=0
      entityelement(te).currentammo=0
      entityelement(te).fireweapon=0
      `
      rem clear this so entity can fall and make a splash again
      entityelement(te).decalloop=0
      `
      rem give entity infinite or finite life
      if entityelement(e).spawn.life>0
       entityelement(te).spawn.life=timer()+(entityelement(e).spawn.life*1000)
      else
       entityelement(te).spawn.life=0
      endif
      `
      rem X10 170807 - all spawned entities are always active (otherwise distance physics all wrong)
      entityelement(te).eleprof.phyalways=1
      `
      rem X10 if entity was cloned for ragdoll, destroy it and recreate
      if entityelementwhichslot(te)=-1
       rem entitiy has no slot (clone), so destroy
       if entityelementusingode(te)>0
        gosub _physics_destroyragdoll
        entityelementusingode(te)=0
        if ragdollcountingame>0 then dec ragdollcountingame
       endif
       rem as we have to reuse the ragdoll when this respawned entity dies, we
       rem need to recreate it fully (performance drain should be negligable)
       preclonedcorpseobj=preclonedcorpseobjbase+te
       if preclonedcorpseobj=tobj
        if 1
         rem X10 - 101007 - need to reset 'preclonedcorpseobj' for new ragdoll use
         ttobj=preclonedcorpseobj : gosub _physics_destroyjustragdoll
        else
         delete object preclonedcorpseobj
         clone object preclonedcorpseobj,entitybankoffset+entid,2
         set object effect preclonedcorpseobj,gskinningforagdolleffect
         rem X10 - 251007 - ensure ragdoll corpses also use transparency (so render after sky)
         tentid=entityelement(te).bankindex
         tmintransmode=entityprofile(tentid).transparency
         if tmintransmode<2 then tmintransmode=2
         set object transparency preclonedcorpseobj,tmintransmode         
        endif
        position object preclonedcorpseobj,0,0,0
        hide object preclonedcorpseobj
       endif
       rem restore actual entity object (previously ragdoll stored 40000+)
       entityelement(te).obj=entityobjectoffset+te
       tobj=entityelement(te).obj
       rem now recreate as regular entity
       tentid=entityelement(te).bankindex
`       gosub _entity_createdynamicentityobj
      endif
      `
      rem X10 - 101007 - do not recvreate for respawn, just use old one
      attach object to static tobj
      `
      rem X10 remove physics dropped attachment when respawn (so entity can carry it again)
      tdropobj=entityelement(te).attachmentobj
      if tdropobj>0
       if phyobjele(tdropobj)=-1
        tobj=tdropobj : gosub _physics_deleteentity
        phyobjele(tdropobj)=0
       endif
      endif
      `
      rem object setting
      if entityelement(te).eleprof.physics=1 or entityelement(te).eleprof.physics=2
       ste=e : e=te : gosub _physics_switchoffe : e=ste
      endif
      tentid=entityelement(te).bankindex
      tsizey#=0 : if entityprofile(tentid).ischaracter=0 then tsizey#=object size y(tobj)/2
      position object tobj,entityelement(te).x,entityelement(te).y+tsizey#,entityelement(te).z
      set alpha mapping on tobj,entityelement(te).ai.alphafade
      rotate object tobj,0,0,0
      show object tobj
      if entityelement(te).eleprof.physics=1 or entityelement(te).eleprof.physics=2
       ste=e : stentid=entid : e=te : entid=entityelement(e).bankindex
       gosub _physics_setupewithphysics
       tvel=entityelement(e).spawn.vel+rnd(entityelement(e).spawn.velrandom)
       tangle=entityelement(e).spawn.angle+rnd(entityelement(e).spawn.anglerandom)
       gosub _physics_pushusingtvelandangle
       e=ste : entid=stentid
      endif
      `
      rem X10 - 101007 - settle physics from any previous activity
      tobj=entityelement(te).obj
      gosub _physics_stopvelocity
      `
      rem reset visuals
      entid=entityelement(te).bankindex
      rem X10 actual object may be parent slot managed
      actualobj=entityelementwhichobj(e)
      if actualobj=0 then actualobj=tobj
      if total object frames(actualobj)>0
       set object frame actualobj,0
       if entityprofile(entid).ischaracter=1
        if entityprofile(entid).animmax>=1
         teai=0 : if entityanim(entid,1).start>0 then teai=1
         tbaseframe=teai : gosub _entity_getactualframestart : tfstart=tactualframe
         tbaseframe=teai : gosub _entity_getactualframefinish : tffinish=tactualframe
         loop object actualobj,tfstart,tffinish
        else
         loop object actualobj : stop object actualobj
        endif
       endif
      endif
      `
      rem set spawned entity collision
      if entityprofile(entid).isweapon>0 or entityprofile(entid).isammo>0
       entityelement(te).collisionactive=0
       set object collision off tobj
      else
       entityelement(te).collisionactive=1
       set object collision on tobj
      endif
      `
      rem X10 reestablish this entity association with the AI
      if entityprofile(entityelement(te).bankindex).ischaracter=1
       aiobjid=tobj : storee=e : e=te
       gosub _aiss_createaientity
       entityelement(e).eleprof.aiss.actionmode=entityelement(e).eleprof.ex.initmode
       e=storee
      endif
      rem V110 - 080110 - ensure respawns on starting spot
      if AI Entity Exist(tobj)=1
       AI Set Entity Position tobj,entityelement(te).x,object position y(tobj),entityelement(te).z
      endif
      `
      rem write entity to viscolmap if space available, else find new place
      `x9if entityelement(te).eleprof.physics=0 or entityelement(te).eleprof.physics=2
      ` tx=entityelement(te).x/25
      ` ty=entityelement(te).y/100
      ` tz=entityelement(te).z/-25
      ` if tx>=0 and ty>=0 and tz>=0
      `  if tx<=viscolx and ty<=viscoly and tz<=viscolz
      `   viscolmap(tx,ty,tz)=te
      `  endif
      ` endif
      `endif
      `      `
      rem reduce overall UPTO count
      entityelement(e).spawn.upto=entityelement(e).spawn.upto-1
      if entityelement(e).spawn.upto<=0
       entityelement(e).spawn.upto=0
       exit
      endif
      `
      rem go to end if no more to produce
      inc tproduceqty
      if tproduceqty>=tnumbertospawn
       te=e+entityelement(e).spawn.max
       exit
      endif
      `
     endif
     `
    endif
   endif
  next te
 endif
endif

return

_entity_controlwaypoints:

rem waypoint behaviour substatesystem
if entityelement(e).ai.waypoint.state>0
 w=entityelement(e).ai.waypoint.current
 if entityelement(e).ai.waypoint.state=1
  `
  rem before set-off make sure can see destination
  tokay=0
  telex#=entityelement(e).x
  teley#=entityelement(e).y+35.0
  telez#=entityelement(e).z
  tdistx#=telex#-waypointcoord(w).x
  tdisty#=teley#-waypointcoord(w).y+35.0
  tdistz#=telez#-waypointcoord(w).z
  tdist#=sqrt(abs(tdistx#*tdistx#)+abs(tdisty#*tdisty#)+abs(tdistz#*tdistz#))
  if tdist#<1000.0
   tmpx#=waypointcoord(w).x
   tmpy#=waypointcoord(w).y+35.0
   tmpz#=waypointcoord(w).z
   entityelement(e).raycastcount=0
   if static raycast(telex#,teley#,telez#,tmpx#,tmpy#,tmpz#)=0
    tokay=1
   endif
  endif
  `
  rem setup walk to get to next waypoint
  entityelement(e).mover.dx=waypointcoord(w).x
  entityelement(e).mover.dy=waypointcoord(w).y
  entityelement(e).mover.dz=waypointcoord(w).z
  entityelement(e).mover.moved=1
  entityelement(e).mover.run=0
  entityelement(e).ai.waypoint.state=2
  `
  rem characters animate when waypoint is followed, if alive
  entid=entityelement(e).bankindex
  if entityprofile(entid).ischaracter=1 and entityelement(e).health>0
   if entityelement(e).animdo<>entityelement(e).animset-1
    entityelement(e).animset=3
   endif
  endif
  `
 endif
 if entityelement(e).ai.waypoint.state=2
  rem walking along wayppoint
  entityelement(e).mover.dx=waypointcoord(w).x
  entityelement(e).mover.dy=waypointcoord(w).y
  entityelement(e).mover.dz=waypointcoord(w).z
  entityelement(e).mover.moved=1
  entityelement(e).mover.run=0
  tdx#=entityelement(e).mover.dx-entityelement(e).x
  tdz#=entityelement(e).mover.dz-entityelement(e).z
  entityelement(e).mover.da=atanfull(tdx#,tdz#)
  distx#=waypointcoord(w).x-entityelement(e).x
  distz#=waypointcoord(w).z-entityelement(e).z
  dist#=sqrt(abs(distx#*distx#)+abs(distz#*distz#))
  if dist#<7.0*(entityelement(e).eleprof.speed/100.0)
   rem decision on direction
   if entityelement(e).ai.waypoint.direction=1
    rem forward
    linkto=waypointcoord(w).link
    if linkto>0
     entityelement(e).ai.waypoint.state=4
    else
     if w>=waypoint(entityelement(e).ai.waypoint.tracker).finish
      entityelement(e).ai.waypoint.state=5
     else
      entityelement(e).ai.waypoint.state=3
     endif
    endif
   else
    rem backward
    linkto=waypointcoord(w).link
    if linkto>0
     entityelement(e).ai.waypoint.state=4
    else
     if w<=waypoint(entityelement(e).ai.waypoint.tracker).start
      entityelement(e).ai.waypoint.state=5
     else
      entityelement(e).ai.waypoint.state=3
     endif
    endif
   endif
   rem ensure action taken immediately
   entityelement(e).logiccount=0
  endif
 endif
 if entityelement(e).ai.waypoint.state=999
  rem internal state - wait for force to end in main AI
  if entityelement(e).ai.libindex=entityelement(e).ai.libmain
   if entityelement(e).force.active=0 and entityelement(e).ai.waypoint.tracker>0
    rem resume waypoint logic (only if alive and have waypoints)
    if entityelement(e).health>0
     entityelement(e).ai.waypoint.state=1
     entityelement(e).logiccount=0
    endif
   endif
  endif
 endif
endif

return

_entity_controlforce:

rem control force events via inertia values
if entityelement(e).force.active=1
 rem no force if entity immobile
 if entityelement(e).eleprof.isimmobile=1
  entityelement(e).force.active=0
 else
  rem degrade inertia values
  forceineffect=0
  if entityelement(e).force.ix<>0.0 then forceineffect=1 : entityelement(e).force.ix=entityelement(e).force.ix/1.1
  if entityelement(e).force.iz<>0.0 then forceineffect=1 : entityelement(e).force.iz=entityelement(e).force.iz/1.1
  rem apply gravity constant only when above ground
  entityelement(e).force.iy=entityelement(e).force.iy-1.0
  rem update entity position with inertia values if in effect
  if forceineffect=1
   rem restrict by active raycast collision
   tmpx1#=entityelement(e).x
   tmpz1#=entityelement(e).z
   tmpheight#=entityelement(e).y+40
   tnorm#=abs(entityelement(e).force.ix)+abs(entityelement(e).force.iz)
   tmpx2#=tmpx1#+entityelement(e).force.ix+((entityelement(e).force.ix/tnorm#)*20.0)
   tmpz2#=tmpz1#+entityelement(e).force.iz+((entityelement(e).force.iz/tnorm#)*20.0)
   entityelement(e).raycastcount=0
   if static raycast(tmpx1#,tmpheight#,tmpz1#,tmpx2#,tmpheight#,tmpz2#)=0
    rem move the element if no collision or collision too far away
    entityelement(e).mover.stepcount=1
    entityelement(e).mover.ix=entityelement(e).force.ix
    entityelement(e).mover.iy=entityelement(e).force.iy
    entityelement(e).mover.iz=entityelement(e).force.iz
    entityelement(e).ai.waypoint.state=999
    entityelement(e).mover.inmotion=1
   endif
   rem so small we can make them zero
   if entityprofile(entid).ischaracter=1
    rem characters regain themselves quicker
    if abs(entityelement(e).force.ix)<2 then entityelement(e).force.ix=0.0
    if abs(entityelement(e).force.iz)<2 then entityelement(e).force.iz=0.0
   else
    rem inanimate objects slide to a stop
    if abs(entityelement(e).force.ix)<0.1 then entityelement(e).force.ix=0.0
    if abs(entityelement(e).force.iz)<0.1 then entityelement(e).force.iz=0.0
   endif
  else
   entityelement(e).force.active=0
  endif
 endif
endif

return

_entity_controlanim:

rem entity with an object
if obj>0
 `
 rem X10 actual object may be parent slot managed
 actualobj=entityelementwhichobj(e)
 if actualobj=0 then actualobj=obj
 `
 rem animation and slerp handling
 if entityelement(e).animset>0
  entityelement(e).animdo=entityelement(e).animset-1
  entityelement(e).animtime=4
  entityelement(e).animset=0
  rem X10 - play frame through parentslot manager
  playframeanimset=entityelement(e).animdo : gosub _slot_playframe
  actualobj=entityelementwhichobj(e)
  if actualobj=0 then actualobj=obj
  rem X10 - play animation in parent slot immediately (and only once when parent slot created for this type of animation)
  if entityelementwhichobj(e)>0
   rem using parent slots
   if parentslotjustcreated=1
    rem go straight to loop object command
    entityelement(e).animtime=1
    parentslotjustcreated=0
   else
    rem skip loop object command (parent already doing it)
    entityelement(e).animtime=0
   endif  
  else
   rem not using parent slots
   stop object actualobj : set object interpolation actualobj,25
   tbaseframe=entityelement(e).animdo : gosub _entity_getactualframestart
   set object frame actualobj,tactualframe
   entityelement(e).animtime=4
  endif
 endif
 if entityelement(e).animdo>=0
  rem handle transition into loop anim
  if entityelement(e).animtime=1
   tbaseframe=entityelement(e).animdo : gosub _entity_getactualframestart : tfstart=tactualframe
   tbaseframe=entityelement(e).animdo : gosub _entity_getactualframefinish : tffinish=tactualframe
   rem hack as we know the anims (die anims) (multiplayer)
   if gmultiplayergame=1
    if entityelement(e).animdo=11 then entityelement(e).animonce=1
    if entityelement(e).animdo=14 then entityelement(e).animonce=1
    if entityelement(e).animdo=17 then entityelement(e).animonce=1
    if entityelement(e).animdo=20 then entityelement(e).animonce=1
   endif
   set object interpolation actualobj,100
   if entityelement(e).animonce=1
    loop object actualobj,tffinish-0.001,tffinish
    set object frame actualobj,tfstart
    entityelement(e).animonce=0
    set object speed actualobj,100
   else
    loop object actualobj,tfstart,tffinish
    if entityelement(e).animdir=1
     set object speed actualobj,-125
    else
     set object speed actualobj,125
    endif
   endif
  endif
  if entityelement(e).animtime>0 then entityelement(e).animtime=entityelement(e).animtime-1
  rem monitor any animation
  if 1
   rem downside is different entities have different speeds,
   rem but instances of the parent entity must all animate the same speed - doh!
   tbaseframe=entityelement(e).animdo
   eachanimhasmovespeed#=1.0
   entid=entityelement(e).bankindex
   if entityprofile(entid).ischaracter=1
    if entityelement(e).attachmentweapontype>0 and tbaseframe>0
     eachanimhasmovespeed#=entityanim(entid,50+tbaseframe).speed
    else
     eachanimhasmovespeed#=entityanim(entid,tbaseframe).speed
    endif
   endif
   rem copy character speed to entity (so inc frame and dec frame work same speed)
   entityelement(e).animspeed=2*eachanimhasmovespeed#
   eachcharacterhasspeed#=entityelement(e).eleprof.speed/100.0
   tanimspeednow#=200*eachanimhasmovespeed#
   tanimspeednow#=tanimspeednow#*eachcharacterhasspeed#
   tanimspeednow#=tanimspeednow#*timeelapsed#
   `trestcenter text object screen x(obj),object screen y(obj),str$(eachanimhasmovespeed#)+"+"+str$(eachcharacterhasspeed#)+" = "+str$(tanimspeednow#)
   if entityelement(e).animdir=1
    set object speed actualobj,tanimspeednow#*-1
   else
    set object speed actualobj,tanimspeednow#
   endif
  endif
 endif
 `
 rem slerp limbs back into place
 if entityelement(e).limbslerp>0
  rem x9 noew anim system
  `tlcount=0
  `for tl=0 to entityelement(e).limbslerp-1
  ` if tl>0
  `  if limb exist(entityelement(e).obj,tl)=1
  `   tlx#=limb angle x(entityelement(e).obj,tl)/1.1
  `   tly#=limb angle y(entityelement(e).obj,tl)/1.1
  `   tlz#=limb angle z(entityelement(e).obj,tl)/1.1
  `   rotate limb entityelement(e).obj,tl,tlx#,tly#,tlz#
  `   if tlx#=0 and tly#=0 and tlz#=0 then inc tlcount
  `  endif
  ` else
  `  inc tlcount
  ` endif
  `next tl
  `if tlcount>=entityelement(e).limbslerp
  entityelement(e).limbslerp=0
  `endif
 endif
 `
endif

return

_entity_makeasplash:
 `
 rem takes DECAL X Y Z, velocity#
 if waterdecalripple<>0
  ` 
  rem show splash
  decalid=splashdecalid
  decalorient=0
  decalscalemodx=100
  decalscalemody=decalscalemodx
  decalalpha=velocity# : if decalalpha>50 then decalalpha=50
  originatore=0 : gosub _decalelement_create
  `
  rem play splash sound
  tmatindex=9 : tsoundtrigger=material(tmatindex).impactid
  tspd#=(material(tmatindex).freq*2)+rnd(material(tmatindex).freq)
  tsx#=decalx : tsy#=decaly : tsz#=decalz
  tvol#=velocity# : if tvol#>100 then tvol#=100
  gosub _physics_triggermaterialsound
  `
 endif
 `
return

_entity_controldecals:

rem decal effects from entity element
tindex=entityelement(e).decalindex
if tindex<>0
 if tindex<0
  decalid=abs(tindex)
 else
  decalid=entitydecal(entid,tindex-1)
 endif
 if decalid>0
  rem entityelement(e).decalmode
  rem 0-once face player
  rem 1-once keep angle
  rem 2-loop face player
  rem 3-loop keep angle
  rem 4-once face up
  rem 5-loop face up
  rem 6-character-spot-decal (at end of entity characters gun if available)
  rem new for X10
  rem 7-character-spot-newmuzzleflash (at end of entity characters gun if available)
  decalorient=0 : decalalpha=100
  decalx=entityelement(e).x : decalz=entityelement(e).z
  if entityelement(e).decalmode>=4 and entityelement(e).decalmode<=5
   decaly=entityelement(e).y+0.5
  else
   decaly=entityelement(e).y
  endif
  if entityelement(e).decalmode=1
   rem used for windows, where glass smash decal must exactly match
   if entityelement(e).obj>0
    decalx=decalx+object collision center x(entityelement(e).obj)
    decaly=decaly+object collision center y(entityelement(e).obj)
    decalz=decalz+object collision center z(entityelement(e).obj)
   endif
  endif
  if entityelement(e).decalmode=1 or entityelement(e).decalmode=3
   decalorient=1 : decalorientx#=entityelement(e).rx : decalorienty#=entityelement(e).ry : decalorientz#=entityelement(e).rz
  endif
  if entityelement(e).decalmode=4 or entityelement(e).decalmode=5
   decalorient=2
  endif
  decalscalemodx=entityelement(e).decalsizex
  decalscalemody=entityelement(e).decalsizey
  if entityelement(e).decalmode=6 or entityelement(e).decalmode=7
   if entityprofile(entid).ischaracter=1
    tobj=entityelement(e).attachmentobj
    if tobj>0
     tobjlimb=entityelement(e).attachmentobjfirespotlimb
     decalx=limb position x(tobj,tobjlimb)
     decaly=limb position y(tobj,tobjlimb)
     decalz=limb position z(tobj,tobjlimb)
     rem X10 correct by moving decal forward to 'end' of gun
     tdx#=(camera position x(playercam)-decalx)
     tdy#=(camera position y(playercam)-decaly)
     tdz#=(camera position z(playercam)-decalz)
     tdd#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#)+abs(tdy#*tdy#))
     tdx#=(tdx#/tdd#)*5.0
     tdy#=(tdy#/tdd#)*5.0
     tdz#=(tdz#/tdd#)*5.0
     decalx=decalx+tdx#
     decaly=decaly+tdy#
     decalz=decalz+tdz#
     decalscalemodx=25
     decalscalemody=25
    endif
   endif
   decalorient=3
  endif
  if entityelement(e).decalmode=0 or entityelement(e).decalmode=1 or entityelement(e).decalmode=4 or entityelement(e).decalmode=6 or entityelement(e).decalmode=7
   rem play decal once
   entityelement(e).decalindex=0
   if entityelement(e).decalmode=7
    rem X10 new 3D muzzle flash
    muzzlex#=decalx : muzzley#=decaly : muzzlez#=decalz
    muzzlerx#=0 : muzzlery#=0 : muzzlerz#=0
    tmobj=entityelement(e).attachmentobj
    rem V109 - 280109 - stopped working, replaced with entity angle variable
    `if tmobj>0
    ` if object exist(tmobj)=1
    `  muzzlerx#=object angle x(tmobj)
    `  muzzlery#=object angle y(tmobj)
    `  muzzlerz#=object angle z(tmobj)
    ` endif
    `endif
    muzzlerx#=0 : muzzlery#=entityelement(e).ry+180 : muzzlerz#=0
    muzzlegunid=entityelement(e).currentweapon
    rem work out distance from gun to target 
    muzzlelaserdistance#=300.0 : rem default if no target
    if entityelement(e).actualtarget<>0
     x2#=entityelement(e).actualtargetx
     y2#=entityelement(e).actualtargety
     z2#=entityelement(e).actualtargetz
     tdx#=abs(x2#-muzzlex#)
     tdy#=abs(y2#-muzzley#)
     tdz#=abs(z2#-muzzlez#)
     muzzlelaserdistance#=sqrt((tdx#*tdx#)+(tdy#*tdy#)+(tdz#*tdz#))
    endif
    muzzlescale#=3 : gosub _muzzle_placeflash
   else
    rem decal for gun flash in front of character
    originatore=e : gosub _decalelement_create  
   endif
  endif
  if entityelement(e).decalmode=2 or entityelement(e).decalmode=3 or entityelement(e).decalmode=5
   rem loop decal continually recreating it
   `x9entityelement(e).decalloop=entityelement(e).decalloop+1
   `if entityelement(e).decalloop>=15
   ` entityelement(e).decalloop=0
   rem X10 _coninue code relies on frame animation coming to an end (not decalloop counter)
   currentdecald=entityelement(e).decalslotused
   originatore=e : gosub _decalelement_continue
   entityelement(e).decalslotused=currentdecald
   `endif
  endif
 endif
endif

return

_entity_controlcollision:

rem no movement if entity immobile
if entityelement(e).mover.moved=1
 if entityelement(e).eleprof.isimmobile=1
  entityelement(e).mover.moved=0
 endif
endif

rem entity has moved, collision a consideration
if entityelement(e).mover.moved=1 and entityelement(e).force.active=0
 `
 rem tragectory of entity movement
 tdx#=entityelement(e).mover.dx-entityelement(e).x
 tdy#=entityelement(e).mover.dy-entityelement(e).y
 tdz#=entityelement(e).mover.dz-entityelement(e).z
 tdist#=sqrt(abs(tdx#*tdx#)+abs(tdz#*tdz#))+30
 `
 rem ensure projected movement is free of large entity obstacles
 dstbest#=99999.9 : dstbestfound=0
 tblockedtox=entityelement(e).mover.dx
 tblockedtoy=entityelement(e).mover.dy
 tblockedtoz=entityelement(e).mover.dz
 `
 rem if blocked, a quicker check to see if collision disabled on it
 tusethisasweneeddoorstoblock=1
 if tusethisasweneeddoorstoblock=1
  if entityelement(e).blockedby>0
   if entityelement(e).blockedtox=tblockedtox and entityelement(e).blockedtoy=tblockedtoy and entityelement(e).blockedtoz=tblockedtoz
    te=entityelement(e).blockedby
    if entityelement(te).active=0 or entityelement(te).collisionactive=0
     entityelement(e).blockedby=0
    else
     dstbestfound=te
    endif
   else
    entityelement(e).blockedby=0
   endif
  endif
  rem obstacle detection removed for V1 (speed issue)
  if entityelement(e).blockedby=0 and entitysystemdisabled=0
   rem intensive scan for solid entity obstacles
   for te=1 to entityelementlist
    if te<>e
     if entityelement(te).active=1
      if entityelement(te).obj>0 and entityelement(te).collisionactive=1
       tentid=entityelement(te).bankindex
       if entityprofile(tentid).ischaracter=0
        rem ensure only entity with DOOR characteristics are rayscanned
        if entityelement(te).editorfixed<>0
         dst#=intersect object(entityelement(te).obj,entityelement(e).x,entityelement(e).y+40.0,entityelement(e).z,entityelement(e).mover.dx,entityelement(e).mover.dy+40.0,entityelement(e).mover.dz)
         if dst#>0 and dst#<tdist#-30
          if dst#<dstbest# then dstbest#=dst# : dstbestfound=te
         endif
        endif
       endif
      endif
     endif
    endif
   next te
   if dstbestfound>0
    rem if collide with close entity, recalc distance to move so we just touch it
    entityelement(e).blockedby=dstbestfound
    entityelement(e).blockedtox=tblockedtox
    entityelement(e).blockedtoy=tblockedtoy
    entityelement(e).blockedtoz=tblockedtoz
    tdist#=dstbest#-1.0 : dstbestfound=0
   endif
  endif
 endif
 `
 rem go ahead - can move or not move
 if dstbestfound=0
  `
  rem get angle from tragectory
  tda#=atanfull(tdx#,tdz#)
  tstepup#=0.0
  `
  rem strafe adjusts mover angle
  if entityelement(e).mover.strafe<>0
   tda#=tda#+entityelement(e).mover.strafe
   tdistold#=tdist#
   tdist#=50.0
  endif
  `
  rem When need to slide past other things
  if entityelement(e).mover.slidevel<>0
   tda#=tda#+entityelement(e).mover.slidevel
  endif
  `
  rem strafe dist over-shot so character not in wall, reduce back to real dist
  tdist#=tdist#-30.0
  `
  rem speed calc using timestamp
  tspeed#=tdist# : if tspeed#>3.0 then tspeed#=3.0
  `
  rem calculate mover inertias for per-cycle movement
  entityelement(e).mover.ix=newxvalue(0,tda#,tspeed#)
  entityelement(e).mover.iz=newzvalue(0,tda#,tspeed#)
  if entityelement(e).nogravity=1
   entityelement(e).mover.iy=tdy#/(tdist#/tspeed#)
  else
   entityelement(e).mover.iy=0.0
  endif
  if tdist#<1.0
   entityelement(e).mover.stepcount=0
  else
   entityelement(e).mover.stepcount=tdist#/tspeed#
  endif
  entityelement(e).mover.inmotion=1
  `
 else
  `
  rem if blocked, losing target
  entityelement(e).losttargetcount=entityelement(e).losttargetcount+1
  `
 endif
 `
 rem checks over
 entityelement(e).mover.moved=0
 `
endif

return

_entity_move_removeref:
 tx=entityelement(e).x/25 : ttryx=tx
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25 : ttryz=tz
 if tx>=0 and ty>=0 and tz>=0
  if tx<=viscolx and ty<=viscoly and tz<=viscolz
   viscolmap(tx,ty,tz)=0
  endif
 endif
return

_entity_move_avoidentities:
 tx=entityelement(e).x/25
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25
 if ty>=0 and ty<=viscoly
  tnearest=0 : tnearestds#=9999
  for lsx=tx-2 to tx+2
   for lsz=tz-2 to tz+2
    if lsx>=0 and lsz>=0
     if lsx<=viscolx and lsz<=viscolz
      localscan=viscolmap(lsx,ty,lsz)
      if localscan>0
       rem touching entity
       tentid=entityelement(localscan).bankindex
       if entityprofile(tentid).ischaracter=1
        if entityelement(localscan).mover.inmotion=0 or e>localscan
         rem ensure this E does not enter cylinder of locally scanned E
         tldx#=entityelement(e).x-entityelement(localscan).x
         tldz#=entityelement(e).z-entityelement(localscan).z
         tlds#=sqrt(abs(tldx#*tldx#)+abs(tldz#*tldz#))
         if tlds#<36.0
          if tnearestds#>tlds# then tnearestds#=tlds# : tnearest=localscan
         endif
        endif
       endif
      endif
     endif
    endif
   next lsz
  next lsx
  if tnearest>0
   tldx#=entityelement(e).x-entityelement(tnearest).x
   tldz#=entityelement(e).z-entityelement(tnearest).z
   tlan#=atanfull(tldx#,tldz#)
   if (int(e/2.0)*2.0)=int((e/2.0)*2.0)
    entityelement(e).mover.slidevel=entityelement(e).mover.slidevel+1
    tlan#=tlan#+3
   else
    entityelement(e).mover.slidevel=entityelement(e).mover.slidevel-1
    tlan#=tlan#-3
   endif
   entityelement(e).x=newxvalue(entityelement(tnearest).x,tlan#,36.0)
   entityelement(e).z=newzvalue(entityelement(tnearest).z,tlan#,36.0)
   tavoidedentity=1
  endif
 endif
return

_entity_move_restoreref:
 rem get tile coord
 tputback=0
 tx=entityelement(e).x/25
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25
 tslidearoundhole=0
 if tx>=0 and tx<=viscolx and ty>=0 and ty<=viscoly and tz>=0 and tz<=viscolz
  rem or an obstacle (entity, not player) either above or below
  if viscolmap(tx,ty,tz)>0 then tputback=1
  rem FPSCV105RC2 - added all voids as obstacles in VISCOLMAP (so characters canont run off ledges)
  if viscolmap(tx,ty,tz)=-2
   rem if following player..
   if entityelement(e).plrtrailindex>0
    rem default where character and player on same level
    rem MEY#=560
    rem entityelement(e).y=501
    if abs((mey#-59)-entityelement(e).y)<3
     rem do not allow movement if on exact same level as it is likely
     rem the player jumped or skimmed a hole, and the enemy would fall into it
     tputback=1
    else
     rem only allow movement into hole if the player is lower than entity
     rem only allow movement into higher place if the player is higher than entity
     tputback=0
    endif
    if tputback=1
     entityelement(e).losttargetcount=100
     tputback=1
    endif
   else
    rem if blocked, instantly lose target
    entityelement(e).losttargetcount=100
    tputback=1
   endif
  endif
  tryy = (entityelement(e).y+35)/100 : if tryy<=viscoly and viscolmap(tx,tryy,tz)>0 then tputback=1
  tryy = (entityelement(e).y-35)/100 : if tryy>=0 and viscolmap(tx,tryy,tz)>0 then tputback=1
 else
  tputback=1
 endif
 if tputback=1
  tkillfallingentity=0
  if entityelement(e).y<0
   rem entity left by falling off the universe, restore but remove all health and lives
   tkillfallingentity=1
  else
   rem restore by bouncing tragectory back
   if entityelement(e).mover.grav>1
    entityelement(e).mover.grav=entityelement(e).mover.grav*-1
   endif
  endif
  `  
  rem X10 if hit a hole, slide along its edge in the direction of the target
  remstart
  if tslidearoundhole=1
   rem if we reset the X, will we still hit the hole?
   storedx#=entityelement(e).x
   entityelement(e).x=toldx#
   tx=entityelement(e).x/25
   if viscolmap(tx,ty,tz)=-2
    rem no, so try using the old Z instead?
    entityelement(e).x=storedx#
    tx=entityelement(e).x/25
    entityelement(e).z=toldz#
    tz=entityelement(e).z/-25
    if viscolmap(tx,ty,tz)=-2
     rem ok, so basically tried to go into a corner, no way forward, step back
    else
     rem there is no hole here, so we use the old Z and move on!
     if entityelement(e).x<toldx#
      rem X-
      tslidearoundhole=2
     else
      rem X+
      tslidearoundhole=3
     endif
    endif    
   else
    rem there is no hole here, so we use the old X and move on!   
    if entityelement(e).z<toldz#
     rem Z-
     tslidearoundhole=4
    else
     rem Z+
     tslidearoundhole=5
    endif
   endif
   entityelement(e).x=toldx#
   entityelement(e).y=toldy#
   entityelement(e).z=toldz#
   if 1
    rem LEE, seems this slide past hole works, but enemy gets stuck at the
    rem very corner where the hole ends?? have not a clue why!!
    rem so use STRAFE trigger (losttarget for now)
    entityelement(e).losttargetcount=100
   else
    if tslidearoundhole=2 then entityelement(e).x=entityelement(e).x-1
    if tslidearoundhole=3 then entityelement(e).x=entityelement(e).x+1
    if tslidearoundhole=4 then entityelement(e).z=entityelement(e).z-1
    if tslidearoundhole=5 then entityelement(e).z=entityelement(e).z+1
    tx=entityelement(e).x/25
    ty=entityelement(e).y/100
    tz=entityelement(e).z/-25
    rem final check, if somehow in hole, use OLD values
    if tx>=0 and tx<=viscolx and ty>=0 and ty<=viscoly and tz>=0 and tz<=viscolz
     if viscolmap(tx,ty,tz)=-2
      entityelement(e).x=toldx#
      entityelement(e).y=toldy#
      entityelement(e).z=toldz#
     endif
    endif 
   endif
  else
  remend
  entityelement(e).x=toldx#
  entityelement(e).y=toldy#
  entityelement(e).z=toldz#
  `
  entityelement(e).mover.stepcount=tstep#
  if tkillfallingentity=1 and entityelement(e).health>0
   entityelement(e).eleprof.lives=1
   entityelement(e).eleprof.strength=1
   tdamage=entityelement(e).health
   entityelement(e).health=1
   tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
   gosub _entity_deducthealth
  endif
 endif
 rem place back in viscolmap
 tx=entityelement(e).x/25
 ty=entityelement(e).y/100
 tz=entityelement(e).z/-25
 if tx>=0 and ty>=0 and tz>=0
  if tx<=viscolx and ty<=viscoly and tz<=viscolz
   viscolmap(tx,ty,tz)=e
  endif
 endif
return

_entity_controlmovements:
 `
 rem V109 - 040708 - only DarkAI.FPI should use DarkAI
 tshoulduseAI=0
 if lower$(right$(entityelement(e).eleprof.aimain$,10))="darkai.fpi" then tshoulduseAI=1
 `
 rem Formerly commented out but needed for old script compatibility (copied from X9(v111))
 rem uses MOVER IX IY IZ and STEPCOUNT to move entity around the scene
 if entityelement(e).eleprof.isimmobile=0 and tshoulduseAI=0
  `
  rem server controlled entities never have motion
  tstep#=entityelement(e).mover.stepcount
  if entityelement(e).servercontrolled=1
   entityelement(e).mover.inmotion=0
  endif
  `
  rem clear viscolmap data if going to move
  rem V110 - 140110 - ensures antigrav platforms using nofloorlogic are not stopped by thin air
  if entityelement(e).mover.inmotion=1 and entityelement(e).nofloorlogic=0
   gosub _entity_move_removeref
  endif
  `
  rem control position movement
  toldx#=entityelement(e).x
  toldy#=entityelement(e).y
  toldz#=entityelement(e).z
  if tstep#>0.0
   `
   rem machine-independent inertia
   tbit#=(1.0*timeelapsed#)
   if tstep#>tbit#
    rem standard paced inertia movememt
    tix#=entityelement(e).mover.ix*timeelapsed#
    tiy#=entityelement(e).mover.iy*timeelapsed#
    tiz#=entityelement(e).mover.iz*timeelapsed#
    if entityelement(e).mover.run=1 then tix#=tix#*2.0 : tiy#=tiy#*2.0 : tiz#=tiz#*2.0
    if entityelement(e).eleprof.speed<>100
     tss#=entityelement(e).eleprof.speed/100.0
     tix#=tix#*tss# : tiy#=tiy#*tss# : tiz#=tiz#*tss#
    endif
   else
    rem ensure steps are taken to the last decimal bit
    tbit#=tstep#
    tix#=entityelement(e).mover.ix*tbit#
    tiy#=entityelement(e).mover.iy*tbit#
    tiz#=entityelement(e).mover.iz*tbit#
   endif
   rem movement
   entityelement(e).x=entityelement(e).x+tix#
   entityelement(e).y=entityelement(e).y+tiy#
   entityelement(e).z=entityelement(e).z+tiz#
   entityelement(e).mover.stepcount=tstep#-tbit#
   `
  endif
  `
  rem ensure entity characters do not croud each other
  tavoidedentity=0
  if entityelement(e).mover.inmotion=1
   if entityprofile(entid).ischaracter=1
    gosub _entity_move_avoidentities
   endif
  endif
  if tavoidedentity=0
   if entityelement(e).mover.slidevel<>0
    entityelement(e).mover.slidevel=entityelement(e).mover.slidevel/1.1
    if abs(entityelement(e).mover.slidevel)<1.0
     entityelement(e).mover.slidevel=0
    endif
   endif
  endif
  `
  rem simple volume check for free-moving entities
  if entityelement(e).mover.inmotion=1
   tokay=0 : tgravitydefeated=0
   if entityelement(e).nogravity=0
    if entityelement(e).nofloorlogic=0
     rem full gravity and volume handling of entities in motion
     if entitysystemdisabled=0
      rem can be a little heavy on CPU time (any ideas to speed up?)
      entityelement(e).y=entityelement(e).y-entityelement(e).mover.grav
      if static volume(toldx#,toldy#+30,toldz#,entityelement(e).x,entityelement(e).y+30,entityelement(e).z,1.0)=1
       entityelement(e).x=toldx#+get static collision x()
       entityelement(e).y=toldy#+get static collision y()
       entityelement(e).z=toldz#+get static collision z()
       colmaterialtype=-1
       if get static collision floor()=1
        tgravitydefeated=1 : colmaterialtype=get static collision value()-1
       endif
       tokay=1
      endif
     endif
    else
     rem quick no-vertical-no-gravity handling (always floor)
     entityelement(e).y=entityelement(e).y-entityelement(e).mover.grav
     if entityelement(e).y<entityelement(e).nofloorlogic-1
      entityelement(e).y=entityelement(e).nofloorlogic-1
      tgravitydefeated=1 : colmaterialtype=-1
      tokay=1
     endif
     rem allow physics to do this - no static geom detection for v1 (speed issue)
     rem V109 - BETA11 - reactivated this as it helps nofloorlogic characters keep out of walls!
     if 1
      tdx2#=entityelement(e).x-toldx#
      tdz2#=entityelement(e).z-toldz#
      tda2#=atanfull(tdx2#,tdz2#)
      tdforex#=newxvalue(0,tda2#,30.0)
      tdforez#=newzvalue(0,tda2#,30.0)
      if static raycast(toldx#,toldy#+30,toldz#,entityelement(e).x+tdforex#,entityelement(e).y+30,entityelement(e).z+tdforez#)<>0
       entityelement(e).x=toldx#
       entityelement(e).z=toldz#
       tokay=1
      else
       rem V109 BETA11 - 130508 - check change in floor height, if so do not go there (stairs and holes)
       ttddist#=static raycast(entityelement(e).x+tdforex#,entityelement(e).y+30,entityelement(e).z+tdforez#,entityelement(e).x+tdforex#,entityelement(e).y-30,entityelement(e).z+tdforez#)
       if abs(ttddist#-30.0)>2.0
        entityelement(e).x=toldx#
        entityelement(e).z=toldz#
        tokay=1
       endif
      endif
     endif
    endif
   endif
   if tokay=1
    plrid=entityelement(e).fakeplayerid
    `V109 - 040708 - not changing structure of X10 entity data
    `if entityprofile(entid).footfallmax>0 and plrid>1
    ` rem V110 BETA5 - 080608 - manually controlled footfalls (from FPE data)
    ` manuallycontrolledfootfallframe=1
    ` if obj>0
    `  tcurrentkeyframe=object frame(obj)
    `  for q=0 to entityprofile(entid).footfallmax-1
    `   if entityfootfall(entid,q).keyframe=tcurrentkeyframe then manuallycontrolledfootfallframe=1+tcurrentkeyframe : exit
    `  next q
    `  `entitydebug$(e)="footfallmax="+str$(entityprofile(entid).footfallmax)+" obj="+str$(obj)+" manuallycontrolledfootfallframe="+str$(manuallycontrolledfootfallframe)+"/"+str$(tcurrentkeyframe)
    `  if manuallycontrolledfootfallframe>1
    `   rem make a footfall sound for the entity
    `   movement=1 : leapedlanded=0 : plrid=entityelement(e).fakeplayerid
    `   gosub _player_playfootfall
    `   `entitydebug$(e)="footfallmax="+str$(entityprofile(entid).footfallmax)+" obj="+str$(obj)+" manuallycontrolledfootfallframe="+str$(manuallycontrolledfootfallframe)+"/"+str$(tcurrentkeyframe)+"   PING!"
    `  endif
    ` endif
    ` manuallycontrolledfootfallframe=0
    `else
     rem default - timer based footfalls
     if tstep#>0.0
      if entityelement(e).mover.run=1
       basespeed#=55
      else
       basespeed#=35
      endif
      if entityelement(e).eleprof.speed<>100
       tss#=entityelement(e).eleprof.speed/100.0
       basespeed#=basespeed#*tss#
      endif
      movement=1 : leapedlanded=0 : plrid=entityelement(e).fakeplayerid
      if plrid>1 then gosub _player_playfootfall
     `endif
    endif
    if entityelement(e).force.active=1
     if tgravitydefeated=1
      entityelement(e).force.iy=0
     else
      entityelement(e).force.ix=0 : entityelement(e).force.iz=0
     endif
    endif
   endif
   if tgravitydefeated=1
    rem determine if fall hurt character
    if entityelement(e).y<entityelement(e).mover.gravlasty-entityelement(e).eleprof.hurtfall
     rem level substantial different from last stood on ground
     tdamage=1+((abs(entityelement(e).y-entityelement(e).mover.gravlasty)-entityelement(e).eleprof.hurtfall)/5.0)
     tdamagex#=entityelement(e).x : tdamagey#=entityelement(e).y : tdamagez#=entityelement(e).z
     tdamagesource=0 : timpacttype=1
     gosub _entity_deducthealth
    endif
    rem record last ground player stood on
    entityelement(e).mover.gravlasty=entityelement(e).y
    rem restore gravity
    entityelement(e).mover.grav=1
   else
    entityelement(e).mover.grav=entityelement(e).mover.grav+1
   endif
  endif
  `
  rem if not moving (colliding), increment losttarget counter
  if entityelement(e).mover.inmotion=1
   if abs(entityelement(e).x-toldx#)+abs(entityelement(e).z-toldz#)<(1.0*timeelapsed#)
    entityelement(e).losttargetcount=entityelement(e).losttargetcount+1
   else
    entityelement(e).losttargetcount=0
   endif
  endif
  `
  rem restore entity viscolmap data
  rem V110 - 140110 - ensures antigrav platforms using nofloorlogic are not stopped by thin air
  if entityelement(e).mover.inmotion=1 and entityelement(e).nofloorlogic=0
   gosub _entity_move_restoreref
  endif
  `
  rem if gravity stops entity, and was in motion, and no-more-moving, deactivate motion
  if entityelement(e).mover.inmotion=1
   if tgravitydefeated=1 and tstep#=0
    rem entity stops moving
    entityelement(e).mover.inmotion=0
    rem stop animation too if logic count far from resolution
    if entityprofile(entid).animmax>=1
     if entityelement(e).animdo>=1 and entityelement(e).animdo<=5
      entityelement(e).animset=1+1
     endif
    endif
   endif
  endif
  `
 endif
 `
 rem control rotation movement
 entityelement(e).ry=curveangle(entityelement(e).mover.da,entityelement(e).ry,2.0/timeelapsed#)
 `
 rem control alpha level movement
 if entityelement(e).ai.destalphafade<>entityelement(e).ai.alphafade
  if entityelement(e).ai.alphafade<entityelement(e).ai.destalphafade
   entityelement(e).ai.alphafade=entityelement(e).ai.alphafade+(10.0*timeelapsed#)
   if entityelement(e).ai.alphafade>entityelement(e).ai.destalphafade
    entityelement(e).ai.alphafade=entityelement(e).ai.destalphafade
   endif
  else
   entityelement(e).ai.alphafade=entityelement(e).ai.alphafade-(10.0*timeelapsed#)
   if entityelement(e).ai.alphafade<entityelement(e).ai.destalphafade
    entityelement(e).ai.alphafade=entityelement(e).ai.destalphafade
   endif
  endif
  entityelement(e).ai.alphafadeupdate=1
 endif
 `
 rem update animation frame of entity
 if entityelement(e).animframe<>entityelement(e).destanimframe
  tss#=1.0 : if entityelement(e).eleprof.speed<>100 then tss#=entityelement(e).eleprof.speed/100.0
  if entityelement(e).animframe<entityelement(e).destanimframe
   entityelement(e).animframe=entityelement(e).animframe+(entityelement(e).animspeed*timeelapsed#*tss#)
   if entityelement(e).animframe>entityelement(e).destanimframe
    entityelement(e).animframe=entityelement(e).destanimframe
   endif
  else
   entityelement(e).animframe=entityelement(e).animframe-(entityelement(e).animspeed*timeelapsed#*tss#)
   if entityelement(e).animframe<entityelement(e).destanimframe
    entityelement(e).animframe=entityelement(e).destanimframe
   endif
  endif
  entityelement(e).animframeupdate=1
 endif
 `
 rem make sure head rotates and can restore itself (in proportion)
 if entityelement(e).ai.headangle<>entityelement(e).ai.headdestangle
  if entityelement(e).ai.headangle<entityelement(e).ai.headdestangle
   entityelement(e).ai.headangle=entityelement(e).ai.headangle+(10*timeelapsed#)
   if entityelement(e).ai.headangle>entityelement(e).ai.headdestangle
    entityelement(e).ai.headangle=entityelement(e).ai.headdestangle
   endif
  else
   entityelement(e).ai.headangle=entityelement(e).ai.headangle-(10*timeelapsed#)
   if entityelement(e).ai.headangle<entityelement(e).ai.headdestangle
    entityelement(e).ai.headangle=entityelement(e).ai.headdestangle
   endif
  endif
 else
  rem add subtle movements in headangle
  entityelement(e).ai.headangle=curvevalue(entityelement(e).ai.headdestangle-5.0+(rnd(100)/10.0),entityelement(e).ai.headangle,3.0)
 endif
 `
return

_entity_controlattachments:

rem ensure attachments are updated and visible
tobj=entityelement(e).attachmentobj
if tobj>0
 tentid=entityelement(e).bankindex
 if object exist(tobj)=1
  if entityelement(e).beenkilled=0
   rem manual position of gun attachment 
   `x9glue object to limb tvweapobj,tobj,entityprofile(tentid).firespotlimb
   `position object tobj,0,0,0
   limbpx#=object position x(entityelement(e).obj)
   limbpy#=object position y(entityelement(e).obj)
   limbpz#=object position z(entityelement(e).obj)
   if entityelement(e).obj>0
    if object exist(entityelement(e).obj)=1
     tentid=entityelement(e).bankindex
     if entityprofile(tentid).firespotlimb>=0
      rem X10 position of entity hand where gun rests
      limbpx#=limb position x(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      limbpy#=limb position y(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      limbpz#=limb position z(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      rem V109 - 070109 - replaced limb direction with orientation (fix weapon align bug)
      `limbax#=limb direction x(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      `limbay#=limb direction y(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      `limbaz#=limb direction z(entityelement(e).obj,entityprofile(tentid).firespotlimb)
      set object to object orientation tobj,entityelement(e).obj,entityprofile(tentid).firespotlimb,0
     endif
    endif
   endif  
   rem X10 new flag for position object which updates frame abs world matrix immediately
   rem in cases where this subroutine is called AFTER the main update() call inside the 
   rem first FASTSYNC after the main SYNC command
   `rotate object tobj,limbax#,limbay#,limbaz# `070109 - above orientation solves this
   position object tobj,limbpx#,limbpy#,limbpz#,1
  else
   rem attachment free of entity, using physics to settle in scene
  endif
  `
  rem X10 - 141107 - hide weapon if character totally invisible
  `131107 - was this : show object tobj
  if gmultiplayergame=1 and entityelement(e).ai.alphafade=0
   hide object tobj
  else
   show object tobj
  endif
  `
 endif
 
endif

return

_entity_controllighting:

rem handle entity lighintg
gosub _lighting_applyentitycolor

return

_entity_storemainai:
 `
 rem store old behaviour (for internal AI changes such as HURT)
 if entityelement(e).ai.usinginternalai=0
  entityelement(e).ai.oldwaypointstate=entityelement(e).ai.waypoint.state
  entityelement(e).ai.oldalphafade=entityelement(e).ai.alphafade
  entityelement(e).ai.oldstate=entityelement(e).ai.state
  entityelement(e).ai.usinginternalai=1
  entityelement(e).logiccount=0
 endif
 `
return

_entity_setnewai:
 rem store old behaviour
 gosub _entity_storemainai
 rem setting waypoint state to 1 causes animation to retriger on return
 if entityelement(e).health<=0
  entityelement(e).ai.oldwaypointstate=999
 else
  if entityelement(e).ai.waypoint.state>0 and entityelement(e).ai.waypoint.state<99
   entityelement(e).ai.oldwaypointstate=1
  else
   entityelement(e).ai.oldwaypointstate=0
  endif
 endif
 rem trigger entity behaviour (aifile$)
 gosub _ai_findlibindex
 entityelement(e).ai.libindex=libindex
 entityelement(e).ai.waypoint.state=0
 entityelement(e).ai.alphafade=100
 entityelement(e).ai.state=0
 rem some resets to prevent cross-code
 entityelement(e).animframe=entityelement(e).destanimframe
 entityelement(e).animtime=0
 rem ensure it is immediate
 entityelement(e).logiccount=0
return

_entity_hasbulletrayhit:
 `
 rem optimise : only entities with range of the players range (of gun)
 `
 rem bulletray is x1#,y1#,z1#,x2#,y2#,z2#=bulletrayhit,gunrange#
 brayx1#=x1# : brayy1#=y1# : brayz1#=z1#
 brayx2#=x2# : brayy2#=y2# : brayz2#=z2#
 bulletrayhit=0 : bulletrayhitdist#=0.0
 `
 rem if bullet ray passed waterlevel, create a splash at intersection
 if (brayy1#>waterlevel# and brayy2#<waterlevel#) or (brayy1#<waterlevel# and brayy2#>waterlevel#)
  `
  rem calculate intersect vector
  tbix#=brayx2#-brayx1#
  tby#=brayy1# : tbiy#=brayy2#-brayy1#
  tbz#=brayz1# : tbiz#=brayz2#-brayz1#
  trange=sqrt(abs(tbix#*tbix#)+abs(tbiz#*tbiz#))
  trange#=trange
  tbix#=tbix#/trange#
  tbiy#=tbiy#/trange#
  tbiz#=tbiz#/trange#
  tperc#=(brayy1#-waterlevel#)/abs(tbiy#)
  tbx#=brayx1#+(tbix#*tperc#)
  tby#=brayy1#+(tbiy#*tperc#)
  tbz#=brayz1#+(tbiz#*tperc#)
  `
  rem create a small splash at this point
  rem and only if water does ripple
  if waterdecalripple<>0
   `
   decalid=splashdecalid
   decalorient=0
   decalx=tbx#
   decalscalemodx=10
   decalscalemody=decalscalemodx+rnd(10)
   decaly=waterlevel#-((100-decalscalemody)/2)
   decalz=tbz#
   decalalpha=50
   originatore=0 : gosub _decalelement_create
   `
   rem play splash sound
   tmatindex=9 : tsoundtrigger=material(tmatindex).impactid
   tspd#=(material(tmatindex).freq*2)+rnd(material(tmatindex).freq)
   tsx#=decalx : tsy#=decaly : tsz#=decalz
   tvol#=100.0 : gosub _physics_triggermaterialsound  
   tsoundtrigger=0
   `
   rem create a ripple at intersect point
   decalid=waterdecalripple
   decalorient=0
   decalx=tbx#
   decaly=waterlevel#+1.0
   decalz=tbz#
   decalorient=2
   decalscalemodx=25 : decalscalemody=decalscalemodx
   decalalpha=15
   originatore=0 : gosub _decalelement_create  
   `
  endif
  `
 endif
 `  
 rem go through entities
 tclosestdist#=99999.0
 tcloseste=0 : tlimbifany=-1
 for e=1 to entityelementlist
  gosub _entity_controlrecalcdist
  if dist#<gunrange# and entityelement(e).obj>0
   rem within range of gun
   `
   rem X10 - 061207 - can only shoot friends if mature rating active
   tcanshootfriends=1
   if bloodmode$="off"
    if entityelement(e).eleprof.ex.alignment<>1
     rem any none enemy character cannot be shot
     tcanshootfriends=0
    endif
   endif
   `
   rem X10 - 101007 - spawn leaders take no hits whatsoever
   if entityelement(e).active<>0 and entityelement(e).spawn.leader=0 and tcanshootfriends=1
    `
    rem if character (animated by GPU, work out general hit (faster paced target)
    dst#=0.0 : entid=entityelement(e).bankindex
    if entityprofile(entid).ischaracter=1
     if gmultiplayergame=0
      tbbase#=-25 : tbheight#=30 : if entityelement(e).crouchprofile=1 then tbheight#=10
     else
      tbbase#=0 : tbheight#=55 : if entityelement(e).crouchprofile=1 then tbheight#=35
     endif
     if (entityelement(e).collisionactive=1 and entityelement(e).invincibleactive=0) or gmultiplayergame=0
      dstx#=object position x(entityelement(e).obj)
      dsty#=object position y(entityelement(e).obj)
      dstz#=object position z(entityelement(e).obj)
      tbx#=brayx1# : tbix#=brayx2#-brayx1#
      tby#=brayy1# : tbiy#=brayy2#-brayy1#
      tbz#=brayz1# : tbiz#=brayz2#-brayz1#
      trange=sqrt(abs(tbix#*tbix#)+abs(tbiz#*tbiz#))
      trange#=trange/10.0
      tbix#=tbix#/trange#
      tbiy#=tbiy#/trange#
      tbiz#=tbiz#/trange#
      for st=1 to trange step 10
       if tbx#>=dstx#-15 and tbx#<=dstx#+15
        if tby#>=dsty#+tbbase# and tby#<=dsty#+tbheight#
         if tbz#>=dstz#-15 and tbz#<=dstz#+15
          ttbix#=tbx#-brayx1#
          ttbiy#=tby#-brayy1#
          ttbiz#=tbz#-brayz1#
          dst#=sqrt(abs(ttbix#*ttbix#)+abs(ttbiy#*ttbiy#)+abs(ttbiz#*ttbiz#))
          st=trange
          exit
         endif
        endif
       endif
       tbx#=tbx#+tbix#
       tby#=tby#+tbiy#
       tbz#=tbz#+tbiz#
      next st
     endif
    else
     rem X10 added this condition so bullets go through open doors
     if entityelement(e).collisionactive=1
      dst#=intersect object(entityelement(e).obj,brayx1#,brayy1#,brayz1#,brayx2#,brayy2#,brayz2#)
     endif
    endif
    `
    rem if intersect
    if dst#>0
     if dst#<tclosestdist#
      tclosestdist#=dst# : tcloseste=e
      tlimbifany=checklist value b(1)
     endif
    endif
    `
   endif
  endif
 next e
 `
return

_entity_completerayhit:
 `
 if tcloseste>0
  `
  rem work on closest entity hit
  e=tcloseste
  gosub _entity_controlrecalcdist
  dst#=tclosestdist#
  `
  rem work out bullet force
  distx#=brayx2#-brayx1# : disty#=brayy2#-brayy1# : distz#=brayz2#-brayz1#
  fulldst#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
  x#=brayx1#+((distx#/fulldst#)*dst#)
  y#=brayy1#+((disty#/fulldst#)*dst#)
  z#=brayz1#+((distz#/fulldst#)*dst#)
  `
  rem X10 set entity to be damaged with a blast in direction of damage
  entitydamageblastaway=1+(bulletdamage*2)
  entitydamageblastawayx#=(distx#/fulldst#)
  entitydamageblastawayy#=(disty#/fulldst#)
  entitydamageblastawayz#=(distz#/fulldst#)
  `
  rem work out relative direction to throw entity from entity angle
  tdir=0
  distx#=entityelement(e).x-brayx1# : distz#=entityelement(e).z-brayz1#
  tentitya#=wrapvalue(atanfull(distx#,distz#))-wrapvalue(entityelement(e).ry)
  if tentitya#<0.0 then tentitya#=tentitya#+360.0
  if tentitya#>=360.0 then tentitya#=tentitya#-360.0
  if tentitya#>180-45 and tentitya#<180+45
   tdir=1
  else
   if tentitya#>315 or tentitya#<45
    tdir=2
   else
    if tentitya#>45 and tentitya#<180-45
     tdir=4
    else
     tdir=3
    endif
   endif
  endif
  `
  if tdir>0
   `
   rem Pierce
   if bulletraytype<>2
    `
    rem affect limb if hit
    if tlimbifany>0
     if entityelement(e).obj>0
      if object exist(entityelement(e).obj)=1
       tentid=entityelement(e).bankindex
       if entityprofile(tentid).headlimb=tlimbifany
        if limb exist(entityelement(e).obj,tlimbifany)=1
         if rnd(1)=1 then tr=6 else tr=-6
         entityelement(e).ai.headangle=tr
        endif
       endif
      endif
     endif
    endif
    `
   endif
   `
   rem if entity prone to damage deal damage to entity (based on distance)
   tentid=entityelement(e).bankindex
   tperc#=(gunrange#-dst#)/gunrange#
   if dst#<200 then tperc#=1.0
   tdamage=bulletdamage : dec tdamage,rnd(tdamage/5)
   tdamage=tdamage*tperc#
   tdamagesource=0 : timpacttype=bulletraytype
   tdamagex#=x# : tdamagey#=y# : tdamagez#=z#
   tuseentityowndecaldamage=1
   `
   rem arena game there are no knock-downs (multiplayer)
   if gmultiplayergame=1
    timpacttype=1
    tentid=entityelement(e).bankindex
    if entityprofile(tentid).ischaracter=1
     multiplayerdamagecollected=multiplayerdamagecollected+tdamage
     multiplayerdamagechar=e
    else
     gosub _entity_deducthealth
    endif
   else
    gosub _entity_deducthealth
   endif
   `
   rem report bullet hit entity
   bulletrayhitdist#=dst#
   bulletrayhit=e
   `
  endif
  `
 endif
 `
return

_entity_spherecollision:
 `
 rem go through entities
 spheree=-1
 for e=1 to entityelementlist
  if entityelement(e).active=1
   distx#=entityelement(e).x-spherex#
   disty#=entityelement(e).y-spherey#
   distz#=entityelement(e).z-spherez#
   dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
   obj=entityelement(e).obj
   if obj>0
    if dist#<object size(obj)*2
     idist#=intersect object(obj,spherex#,spherey#,spherez#,spherenx#,sphereny#,spherenz#)
     if idist#>0 and idist#<=dist#
      spheree=e : exit
     endif
    endif
   endif
  endif
 next e
 `
return

_entity_addforcesphere:
 `
 rem optimise : only entities with range of the sphere
 `
 rem X10 do a scan to find out how many characters in blast range
 rem so we can find out the lethal radius for the number of available ragdolls
 rem reset flags
 for tte=1 to entityelementlist : entityelement(tte).editorfixed=0 : next tte
 rem how many can we kill as ragdolls this blast
 tcandeallethalcount=5-ragdollcountingame
 if tcandeallethalcount<0 then tcandeallethalcount=0
 if tcandeallethalcount>5 then tcandeallethalcount=5   
 rem go through entities and flag cloest ones
 for tfindxclosest=1 to tcandeallethalcount
  tclosest#=99999 : tclosesttte=0
  for tte=1 to entityelementlist
   if entityelement(tte).editorfixed=0
    ttentid=entityelement(tte).bankindex
    distx#=entityelement(tte).x-spherex#
    disty#=entityelement(tte).y-spherey#
    distz#=entityelement(tte).z-spherez#
    dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
    tblastradius#=400.0*sphereforce#
    if dist#<tblastradius#
     tix#=distx#/dist# : tiy#=disty#/dist# : tiz#=distz#/dist#
     tforce#=(tblastradius#-dist#)/tblastradius#
     if tforce#>0.2
      if entityprofile(ttentid).ischaracter=1
       rem this character with within blast area
       if dist#<tclosest#
        rem find closest of characters still with editorfixed=0 flag 
        tclosest#=dist# : tclosesttte=tte
       endif       
      endif
     endif
    endif
   endif
  next tte
  if tclosesttte>0
   rem this character is closest of all characters to center of sphere
   entityelement(tclosesttte).editorfixed=1
  endif
 next tfindxclosest
 `
 rem go through entities
 for tteforce=1 to entityelementlist
  rem ensure we retain loop value
  tte=tteforce
  rem if entity prone to damage
  ttentid=entityelement(tte).bankindex
  rem work out if in range of force
  distx#=entityelement(tte).x-spherex#
  disty#=entityelement(tte).y-spherey#
  distz#=entityelement(tte).z-spherez#
  dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
  distfromcenter#=dist#
  tblastradius#=400.0*sphereforce#
  rem X10 if entity within sphere area, nudge the entity
  if sphereforce#=0.01
   rem special sphereforce# of 0.01 derived from force of 1/100.0
   if dist#<200.0
    if entityelement(tte).obj>0
     phyobjelenudged(entityelement(tte).obj)=2
     tblastradius#=0.0
    endif
   endif
  endif
  if dist#<tblastradius#
   rem calculate force
   tix#=distx#/dist# : tiy#=disty#/dist# : tiz#=distz#/dist#
   tforce#=(tblastradius#-dist#)/tblastradius#
   rem work out if direct or indirect damage (raycast)
   tdirectdamage=0
   if static raycast(spherex#,spherey#+5,spherez#,entityelement(tte).x,entityelement(tte).y+30,entityelement(tte).z)=0
    tdirectdamage=1
   endif
   if tdirectdamage=1
    rem add simple force to entity
    if entityelement(tte).eleprof.isimmobile=0
     rem X10 ALSO if a ragdoll, also apply force
     if entityelement(tte).eleprof.physics=1 or entityelementusingode(tte)>0
      rem apply force using physics
      todee=tte
      if disty#>-15.0
       `x9tdy#=(tiy#*todeforce#)+(0.25*todeforce#)
       todeforce#=tforce#*2000 : tdx#=tix#*todeforce# : tdz#=tiz#*todeforce#
       tdy#=(tiy#*todeforce#)+(2.5*todeforce#)
      else
       todeforce#=tforce#*1000 : tdx#=tix#*todeforce# : tdz#=tiz#*todeforce#
       tdy#=1.0 : rem no downward force (objects can get stuck)
       todeforce#=tforce#
      endif
      todefalloff#=0.0 : twithpointforce=0
      tpx#=spherex# : tpy#=spherey# : tpz#=spherez#
      gosub _physics_applyforce
     else
      rem apply regular force calc
      entityelement(tte).force.ix=entityelement(tte).force.ix+(tix#*tforce#)
      if abs(disty#)<10.0
       entityelement(tte).force.iy=entityelement(tte).force.iy+(tiy#*tforce#)+(1.5*tforce#)
      else
       entityelement(tte).force.iy=entityelement(tte).force.iy+(tiy#*tforce#)
      endif
      entityelement(tte).force.iz=entityelement(tte).force.iz+(tiz#*tforce#)
      `      
      rem for ragdoll account also for impactforce of blast
      rem impact force property is 75 is norma0 for mild blast
      `tforce#=tforce#+(0.01*(gun(gunid).settings.impactforce*gun(gunid).settings.impactforce))
      rem need true force yeild of explosion before when it is triggered (pass in..)
      `tforce#=tforce#*600 : rem force 0.0-1.0 multipled by impact force
      tforce#=tforce#*450 : rem 181007 - reduced by 50 percent to avoid stretched neck bug (rick report)
      `
      rem X10 in case this entity turns to ragdoll, store data
      entityelement(tte).force.active=1+tforce#
      entityelement(tte).force.originx=spherex#
      entityelement(tte).force.originy=spherey#
      entityelement(tte).force.originz=spherez# 
      `
     endif
     rem entity rotates to such large blast
     entityelement(tte).mover.da=atanfull(distx#*-1.0,distz#*-1.0)
    endif
   endif
   rem suggest damage to entity if strong enough force
   if tforce#>0.2
    rem indirect damage is a hugely reduced value
    if tdirectdamage=0 then tforce#=tforce#/50.0
    rem X10 direct damage is also reduced so reduce knock-on effect
    if tdirectdamage<>0 then tforce#=tforce#/10.0
    rem actual entity damage
    tdamagex#=entityelement(tte).x : tdamagey#=entityelement(tte).y : tdamagez#=entityelement(tte).z
    tdamage=tforce#*spheredamage
    tdamagesource=0 : timpacttype=3 : tdir=0
    ste=e : sttentid=tentid
    tentid=entityelement(tte).bankindex
    e=tte
    if entityprofile(tentid).ischaracter=1
     `
     rem X10 - 101207 - player explosions cannot damage allies and neutrals
     if bloodmode$="off"
      if spherecreatedby>0
       theowneroftheexplosion=spherecreatedby-10000
       if theowneroftheexplosion=0
        if entityelement(tte).eleprof.ex.alignment<>1
         tdamage=0
        endif
       endif
      endif
     endif
     `
     rem 200807 - if character a flak thrower, they can handle fringe damage
     if tdamage>0
      tgunid=entityelement(tte).currentweapon
      if gun(tgunid).settings.flakindex<>0 and distfromcenter#>entityelement(tte).eleprof.ex.attackrange/2 then tdamage=0
      if tdamage>0
       rem reapply force damage to lethal levelson bilogical lifeforms
       if gun(tgunid).settings.flakindex<>0
        rem except flak throwers who can withstand explosions better
        tdamage=tdamage*2
       else
        tdamage=tdamage*5
       endif
       rem characters can shrug off some explosion force
       if tdamage<30 then timpacttype=1
       rem only apply damage to characters if that have been flagged as killable
       if entityelement(e).editorfixed=1
        rem 210807 - this flag was set at top when we scanned character damage and number of available ragdolls
        gosub _entity_deducthealth
       endif
      endif
     endif
     `
    else
     rem 200807 - increased overall strength of all explosions
     tdamage=tdamage*2
     rem 200807 - damage can be immediate or slightly delayed (chain reaction randomness)
     if rnd(2)=0
      gosub _entity_delayeddeducthealth
     else
      gosub _entity_deducthealth
     endif
    endif
    e=ste : tentid=sttentid
    rem X10 also nudge these blasted entities
    tte=tteforce
    if tte<=array count(entityelement())
     if entityelement(tte).obj>0
      phyobjelenudged(entityelement(tte).obj)=2
     endif
    endif
   endif
  endif
 next tteforce
 `
 rem initial blast if player close
 distx#=camera position x(playercam)-spherex#
 disty#=camera position y(playercam)-spherey#
 distz#=camera position z(playercam)-spherez#
 dist#=sqrt(abs(distx#*distx#)+abs(disty#*disty#)+abs(distz#*distz#))
 tblastradius#=400.0*sphereforce#
 if dist#<tblastradius#
  rem damage power
  tpower#=(tblastradius#-dist#)/tblastradius#
  rem work out if direct damage or indirect
  tdirectdamage=0
  sphtx#=spherex#+((distx#/dist#)*20.0)
  sphtz#=spherez#+((distz#/dist#)*20.0)
  if static raycast(sphtx#,spherey#+2.5,sphtz#,camera position x(playercam),camera position y(playercam),camera position z(playercam))=0
   tdirectdamage=1
  endif
  if tdirectdamage=1
   rem force applied to player from blast (fly force is cumilative and bleeds into camforce)
   `X10 - 151007 - got stuck in scenery because of these values
   `camflyforcex#=camflyforcex#+((distx#/dist#)*(spheredamage*25)*tpower#)
   `camflyforcey#=camflyforcey#+((spheredamage*25)*tpower#)
   `camflyforcez#=camflyforcez#+((distz#/dist#)*(spheredamage*25)*tpower#)
   camshake#=camshake#+tdamage# : camshakedir=rnd(1)
   if abs(camshake#)>20
    if camshake#>20 then camshake#=20.0
    if camshake#<-20 then camshake#=-20.0
   endif
  endif
  if tpower#>0.2
   rem indirect damage is a hugely reduced value
   if tdirectdamage=0 then tpower#=tpower#/50.0
   rem damage to player (if strong enough force)
   tdamage#=spheredamage*tpower#
   tdamage=tdamage# : if tdamage>0 then gosub _player_takedamage
  endif
 endif
 `
return

_entity_resolveobjective:
 rem e assumed to be active=0, ie tse<>e
 tokay=0 : tleadere=entityelement(e).spawn.leaderid
 if tleadere=0
  rem instant complete - no spawn versions
  tleadere=e
  tokay=1
 else
  if entityelement(tleadere).spawn.upto=0
   tokay=1 : rem complete unless child still alive (active)
   for tse=1+tleadere to tleadere+entityelement(tleadere).spawn.max
    if tse<>e
     tsobj=entityelement(tse).obj
     if tsobj>0
      if object exist(tsobj)=1
       if entityelement(tse).active<>0
        rem entity alive
        tokay=0
       endif
      endif
     endif
    endif
   next tse
  endif
 endif
 if tokay=1
  rem handle objective
  if gamewarmupcount=0
   rem Only if game in ful swing
   mi=entityelement(tleadere).eleprof.isobjective : if mi>0 then playerobjective(mi)=1
  endif
 endif
return

_entity_delayeddeducthealth:
 `
 rem store damage to be dealt when delay runs out
 if entityelement(e).delaydamagecount=0
  entityelement(e).delaydamagecount=10
  entityelement(e).delaydamagesource=tdamagesource
  entityelement(e).delaydamage=tdamage
  entityelement(e).delayimpact=timpacttype
  entityelement(e).delaydamagex#=tdamagex#
  entityelement(e).delaydamagey#=tdamagey#
  entityelement(e).delaydamagez#=tdamagez#
  entityelement(e).delaydir=tdir
 endif
 `
return

_entity_controldelayeddamage:
 `
 rem count down to delayed damage (fuel exploding)
 if entityelement(e).delaydamagecount>0
  entityelement(e).delaydamagecount=entityelement(e).delaydamagecount-1
  if entityelement(e).delaydamagecount=0
   tdamagesource=entityelement(e).delaydamagesource
   tdamage=entityelement(e).delaydamage
   timpacttype=entityelement(e).delayimpact
   tdamagex#=entityelement(e).delaydamagex#
   tdamagey#=entityelement(e).delaydamagey#
   tdamagez#=entityelement(e).delaydamagez#
   tdir=entityelement(e).delaydir
   gosub _entity_deducthealth
  endif
 endif
 `
return

_entity_setbeenkilledflag:
 `
 rem only set this if entity strill alive (once)
 storetobj=tobj
 if entityelement(e).beenkilled=0
  `
  rem set the flag to say the entity is destroyed, frozen or ragdolled
  entityelement(e).beenkilled=1
  `
  rem X10 add score to players toll (single player)
  if gmultiplayergame=0
   `ttttentid=entityelement(e).bankindex
   `if entityprofile(ttttentid).ex.score>0
   ` player(1).score=player(1).score+entityprofile(ttttentid).ex.score
   `endif
   rem X10 - 101007 - use score value from eleprof, not original!
   if entityelement(e).eleprof.ex.score>0
    player(1).score=player(1).score+entityelement(e).eleprof.ex.score
   endif
  endif
  `
  rem X10 record time of kill so weapon can disappear later (and other things)
  entityelement(e).timekilled=timer()
  `
  rem also set the attachment to a physics object so it can fall to ground
  tdropobj=entityelement(e).attachmentobj
  if tdropobj>0
   tobj=tdropobj
   gosub _physics_applyphysicstoattachment
   gosub _physics_ensurephysicsobjvalid
   phyobjele(tobj)=-1 : rem means it will not disappear when out of screen view
  endif
  `
  rem X10 Destroy entity in AI
  gosub _aiss_destroyaientity
  `
  rem remove the shadow blob if have one
  if entityelement(e).attachmentblobobj>0
   if object exist(entityelement(e).attachmentblobobj)=1
    hide object entityelement(e).attachmentblobobj
   endif
   if object exist(entityelement(e).attachmentblobobj+1)=1
    for t=0 to 1
     hide object entityelement(e).attachmentblobobj+1+t
    next t
   endif
  endif  
  `
  rem X10 - 221007 - Stop any sound if looping while got killed
  if entityelement(e).firesoundloop>0
   if sound exist(entityelement(e).firesoundloop)=1
    stop sound entityelement(e).firesoundloop
   endif
   entityelement(e).firesoundloop=0
   entityelement(e).fireweapon=0
  endif
  `
 endif
 tobj=storetobj
 `
return

_entity_deducthealth:
 `
 rem takes TDAMAGE,TDIR and TIMPACTTYPE
 tresult=0 : tentid=entityelement(e).bankindex
 `
 rem spawn leaders take no effect whatsoever
 if entityelement(e).spawn.leader=0
 `
 rem entity damage makes a material sound
 tsoundtrigger=0 : tsoundmaterial=0
 if entityprofile(tentid).ischaracter=0 and tdamage>1
  tmatindex=entityprofile(tentid).materialindex-1
  if tmatindex>=0 and tmatindex<=gmaterialmax
   tsoundtrigger=material(tmatindex).impactid
   tsoundmaterial=1+tmatindex
   tspd#=(material(tmatindex).freq*2)+rnd(material(tmatindex).freq)
   tsx#=tdamagex# : tsy#=tdamagey# : tsz#=tdamagez#
  endif
 endif
 `
 rem work out effect on health and lives
 if entityelement(e).eleprof.strength>0
  if entityelement(e).health>0 or gmultiplayergame=1
   rem multiplayer arena deals damage via server, opposed to directly to entity in single player mode
   if gmultiplayergame=1
    rem actual damage sent to server to control
    gosub _multi_dealentityedamage
   else
    rem deduct the health points (non-multiplayer only)
    entityelement(e).health=entityelement(e).health-tdamage
    entityelement(e).shotdamage=entityelement(e).shotdamage+tdamage
    entityelement(e).shotdamagesource=tdamagesource
    rem if hit, and character, give a priority to deal with AI (and duration to last the action)
    if entityprofile(tentid).ischaracter=1
     gosub _entity_stealpriorityandgivetoe
     if entityelement(e).priorityai=1
      entityelement(e).priorityduration=60
      entityelement(e).logiccount=0
     endif
    endif
   endif
   rem X10 - 270807 - can prevent explodable if explosions maxed out
   if entityelement(e).health<=0
    if entityelement(e).eleprof.explodable<>0
     gosub _part_areexplosionsmaxedout
     if tmaxedoutyes=1 then entityelement(e).health=1
    endif
   endif
   rem work out if dead or alive
   if entityelement(e).health<=0
    rem entity killed
    entityelement(e).health=0
    entityelement(e).shotdamage=0
    entityelement(e).shotdamagesource=0
    entityelement(e).eleprof.lives=entityelement(e).eleprof.lives-1
    rem if entity has more lives
    if entityelement(e).eleprof.lives>0
     rem rejuvinate entity
     entityelement(e).health=entityelement(e).eleprof.strength
     tresult=2
    else
     rem set as killed
     gosub _entity_setbeenkilledflag
     rem mission objective counter
     gosub _entity_resolveobjective
     rem dead perminantly
     tresult=3
     rem get explodable flag (0-none/1-bang/2-scorch leftover)
     texplodable=entityelement(e).eleprof.explodable
     rem remove entity from physics world
     if entityelement(e).eleprof.physics<>0
      if entityprofile(tentid).ischaracter=1 and entityprofile(tentid).noragdoll=1
       rem X10 - V109 - 130309 - but not if NORAGDOLL character, allow DESTROY script..
      else
       tobj=entityelement(e).obj
       if texplodable<>2 then phyobjremove(tobj)=1
      endif
     endif
     rem entity destruction makes a material destroy sound
     if entityprofile(tentid).ischaracter=0
      rem non-character entities made from a material?
      tmatindex=entityprofile(tentid).materialindex-1
      `if tmatindex>=0 and tmatindex<gmaterialmax : rem FPSCV101 - fix
      if tmatindex>=0 and tmatindex<=gmaterialmax
       tsoundtrigger=material(tmatindex).destroyid
       tsoundmaterial=1+tmatindex
       tsx#=tdamagex# : tsy#=tdamagey# : tsz#=tdamagez#
      endif
      rem debris from total destruction (regular physics only objects?)
      debrisshapeindex=entityprofile(tentid).debrisshapeindex
      if entityelement(e).eleprof.physics=1
       rem May shed debris..
       tobj=entityelement(e).obj
       frox#=entityelement(e).x : froy#=entityelement(e).y : froz#=entityelement(e).z
       `froa#=object angle y(tobj)
       frocopyorientfrom=tobj
       if debrisshapeindex>0
        rem place debris to explode in place of real object
        debristextureused=entityelement(e).eleprof.texdid
        if entityprofile(tentid).usetexturearrayforentity>0
         rem 200807 - if texture array, cannot use texDid, must use scorch texture
         debristextureused=0 : rem instructs fragment to use only scorch!
        endif
        debrissizex#=object size x(tobj) : debrissizey#=object size y(tobj) : debrissizez#=object size z(tobj)
        debrisexplodable=texplodable
        rem X10 apply a possible force to physics fragments (if flagged)
        if entitydamageblastaway>0
         rem debrisexplodable (0-none/1-bang/2-scorch only)
         rem new mode 3 - blast away from player using entitydamageblastaway
         debrisexplodable=3 : debrisblastaway=entitydamageblastaway
         debrisblastawayx#=entitydamageblastawayx#
         debrisblastawayy#=entitydamageblastawayy#
         debrisblastawayz#=entitydamageblastawayz#
        endif
        gosub _part_createfragment
        rem Forces object invisible (replaced by fragments)
        tobj=entityelement(e).obj
        hide object tobj
       else
        if texplodable=2 and explosionscorch<>0
         rem not quite explode, just scorch (as though internally fried)
         tobj=entityelement(e).obj
         set blend mapping on tobj, 1, explosionscorch, 3, 6
         set object transparency tobj,0
        endif
       endif
       rem May trigger explosion if entity needs one..
       if texplodable=1
        rem the visual part
        gosub _part_triggerexplosion
        rem the force part
        spheredamage=entityelement(e).eleprof.explodedamage
        spherex#=frox# : spherey#=froy# : spherez#=froz#
        sphereforce#=1.0 : gosub _entity_addforcesphere
       endif
      else
       rem obj not hidden, as phyobjectremove used
      endif
      `
     else
      rem entity character grunts in death
      tplrid=entityelement(e).fakeplayerid : tsnd=15
      tplrid=changeplrforsound(tplrid,tsnd)
      if playersound(tplrid,tsnd)>0
       `x9playinternal3dsoundfactor(playersound(tplrid,tsnd),entityelement(e).x,entityelement(e).y,entityelement(e).z,10.0)
       playinternal3dsoundloudness(playersound(tplrid,tsnd),entityelement(e).x,entityelement(e).y,entityelement(e).z,10.0)
      endif
     endif
    endif
    rem killing blows makes character fall!
    timpacttype=2
   else
    rem entity can sometimes shrug off a fall-over-hit
    if timpacttype=3
     rem flak reactions always thrown
     timpacttype=2
    else
     if timpacttype=2
      if entityelement(e).health>entityelement(e).eleprof.strength/2
       timpacttype=1
      else
       if rnd(3)=1 then timpacttype=1
      endif
     endif
    endif
    rem entity hurt
    tresult=1
    if entityprofile(tentid).ischaracter=1
     rem entity character grunts in hurt
     tplrid=entityelement(e).fakeplayerid : tsnd=12+rnd(2)
     tplrid=changeplrforsound(tplrid,tsnd)
     if playersound(tplrid,tsnd)>0
      playinternal3dsoundloudness(playersound(tplrid,tsnd),entityelement(e).x,entityelement(e).y,entityelement(e).z,5.0)
     endif
     rem 020807 - characters must be alerted when they are hit for first time
     if entityelement(e).eleprof.aiss.beenhurt=0
      entityelement(e).eleprof.aiss.actionmode=1 : rem instant attack
      entityelement(e).eleprof.aiss.beenhurt=1
     endif
    endif
   endif
  endif
 else
  rem FLAK is always throwing
  if timpacttype=3 then timpacttype=2 : tresult=1
 endif
 `
 rem play and sounds that are due (entity hurt, damage, destroy)
 tvol#=100 : gosub _physics_triggermaterialsound
 `
 rem play decal only if requested (set in _entity_completerayhit)
 if tuseentityowndecaldamage=1 then tuseentityowndecaldamage=0 : gosub _decal_triggermaterialdebris
 `
 rem if character, result translates as reaction
 if tresult>0
  rem If exploded, straight to destroy script!
  if tresult=4
   aifile$=entityelement(e).eleprof.aidestroy$
   gosub _entity_setnewai
  else
   tentid=entityelement(e).bankindex
   if entityprofile(tentid).ischaracter=1 and entityprofile(tentid).animmax>0
    rem only if not already reacting
    if entityelement(e).ai.libindex=entityelement(e).ai.libmain or entityelement(e).ai.libindex=entityelement(e).ai.libshoot or tresult=3
     if entityprofile(tentid).noragdoll=1
      rem X9 'throw animation' to restore legacy behaviour    
      rem only if not already reacting
      if entityelement(e).ai.libindex=entityelement(e).ai.libmain or entityelement(e).ai.libindex=entityelement(e).ai.libshoot or tresult=3
       if timpacttype=2
        rem Blast
        aifile$="people\throwback.fpi"
        if tdir=1 then aifile$="people\throwback.fpi"
        if tdir=2 then aifile$="people\throwfore.fpi"
        if tdir=3 then aifile$="people\throwleft.fpi"
        if tdir=4 then aifile$="people\throwright.fpi"
        gosub _entity_setnewai
        rem any waypoint activity must stop right away
        entityelement(e).ai.waypoint.state=999
        entityelement(e).mover.moved=0
       endif
      endif     
     else
      rem X10 must destroy character
      if timpacttype=2
       entityelement(e).ai.waypoint.state=999
       entityelement(e).mover.moved=0
      endif
      if tresult=3
       aifile$=entityelement(e).eleprof.aidestroy$
       gosub _entity_setnewai
      endif
     endif
    endif
   else
    rem non-character reaction
    if tresult=3
     aifile$=entityelement(e).eleprof.aidestroy$
     gosub _entity_setnewai
    endif
   endif
  endif
 endif
 `
 rem spawn leaders take no effect whatsoever ENDIF
 endif
 `
 rem X10 this flag is either used, or reset after call
 entitydamageblastaway=0
 `
return

_entity_findplayerstartposition:

rem Scan present elements for player start markers
playerstartx#=0
playerstartlives=0
playerstartstrength=0
playerstarthasweapon=0
playerstarthasweaponqty=0
playerhurtfall=0
playerspeedratio#=1.25
playerscoregoal=0
playerjumpheight=-1
playerlungcapacity=-1

for e=1 to entityelementlist
 entid=entityelement(e).bankindex
 if entityprofile(entid).ismarker=1 and entityprofile(entid).lives>0
  rem Player Start Marker
  if playerstartx#=0 or rnd(2)=0
   playerstartx#=entityelement(e).x
   playerstarty#=entityelement(e).y
   playerstartz#=entityelement(e).z
   playerstartrx#=0
   playerstartry#=entityelement(e).ry
   playerstartlives=entityelement(e).eleprof.lives
   playerstartstrength=entityelement(e).eleprof.strength
   playerstarthasweapon=entityelement(e).eleprof.hasweapon
   playerstarthasweaponqty=entityelement(e).eleprof.quantity
   playerhurtfall=entityelement(e).eleprof.hurtfall
   playerspeedratio#=0.25+(entityelement(e).eleprof.speed/100.0)
   playerscoregoal=entityelement(e).eleprof.ex.score
   playerjumpheight=entityelement(e).eleprof.ex.jumpheight
   playerlungcapacity=entityelement(e).eleprof.ex.lungcapacity
  endif
  rem X10 - 231007 - if name changed to cam fly mode, set this flag
  if lower$(entityelement(e).eleprof.name$)="camera fly mode"
   gcameraflymode=1
  endif
 endif
next e

rem FPSCV104 - make playerspeed reasonable - RC2 - min is now zero
if playerspeedratio#<0.0 then playerspeedratio#=0.0
if playerspeedratio#>2.0 then playerspeedratio#=2.0

rem X10 - 270806 - defaults
if playerlungcapacity=-1 then playerlungcapacity=500
if playerjumpheight=-1 then playerjumpheight=50
if gmultiplayergame=1 then playerjumpheight=50

rem Minimum and Maximum jump heights
if playerjumpheight<0 then playerjumpheight=0
if playerjumpheight>100 then playerjumpheight=100

rem if checkpoint, override position
if checkpointentity<>-1
 e=checkpointentity
 rem X10 - 011007 - extra precaution against old checkpoints in new level
 if e<=array count(entityelement())
  playerstartx#=entityelement(e).x
  playerstarty#=entityelement(e).y
  playerstartz#=entityelement(e).z
  playerstartrx#=0
  playerstartry#=entityelement(e).ry
 else
  checkpointentity=-1
 endif
endif

rem Default settings
if playerstartlives=0 then playerstartlives=1
if playerstartstrength=0 then playerstartstrength=100
if playerhurtfall=0 then playerhurtfall=100
if playerspeedratio#=0.0 then playerspeedratio#=1.0

rem If from level 2 onwards, replace player start details with current-save-state
if level>1
 playerstartlives=saveplayerstate.lives
 weaponammoindex=saveplayerstate.weaponindexholding
 playerstarthasweapon=weaponslot(weaponammoindex).pref
endif

return

_entity_switchtostaticformultiplayer:
 `
 rem usually no physics as most dynamic entities are converted to static here for the construction process
 if gmultiplayergame=1
  for e=1 to entityelementlist
   if entityelement(e).staticflag=0
    entid=entityelement(e).bankindex
    if entityprofile(entid).isweapon=0 and entityprofile(entid).isammo=0 and entityprofile(entid).ischaracter=0 and entityprofile(entid).ishealth=0
     if entityelement(e).eleprof.isimmobile=1
      rem door or window
      entityelement(e).eleprof.physics=3
     else
      rem something else
      entityelement(e).staticflag=1
      entityelement(e).eleprof.physics=0
     endif
    else
     rem weapon, ammo or character, or health
     entityelement(e).eleprof.physics=0
    endif
   endif
  next e
 endif
 `
return


