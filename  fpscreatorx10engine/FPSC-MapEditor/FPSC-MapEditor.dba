rem
rem MAP EDITOR CODE - SUBROUTINES AND FUNCTIONS
rem

`
` TESTMAP PREVIEW
`

_editor_loadhelppage:
 undim helppage$()
 dim helppage$(32*3)
 tfile$="languagebank\"+language$+"\textfiles\helppage.txt"
 if file exist(tfile$)=1 then load array tfile$,helppage$()
return

_editor_showhelppage:
 ink rgb(255,255,0),0
 set text font strarr$(325)
 set text size 16
 theline=0
 for column=0 to 1
  for l=0 to 32
   text 20+(column*380),20+(l*16),helppage$(theline)
   inc theline
  next l
 next column
 set text font "Verdana"
return

_editor_previewmap:

rem Hide all objects
for obj=1 to universebuildobjstartoffset-1
 if object exist(obj)=1 then hide object obj
next obj

rem Hide camera while prepare test map
storecx#=camera position x()
storecy#=camera position y()
storecz#=camera position z()
gosub _editor_hideall3d

rem Use large prompt
statusbar$=strarr$(326) : popup_text(statusbar$)

rem Record entity and element max (as universe adds extras from segments)
storeentityelementlist=entityelementlist
storeentidmaster=entidmaster

rem Setup lighting for preview (force bright preview)
gosub _lighting_init
set ambient light 75

rem Construct universe from current data
segobjstart=universebuildobjstartoffset
gosub _universe_construct

rem Create dynamic entities as ghosts in preview
entobjpreview=segobj
for e=1 to entityelementlist
 obj=entobjpreview+e
 if obj>0
  rem add static entities to node tree now
  if entityelement(e).staticflag=0
   entid=entityelement(e).bankindex
   sourceobj=entitybankoffset+entid
   if object exist(obj)=1 then delete object obj
   if object exist(sourceobj)=1
    `
    rem Create a copy and set it up
    clone object obj,sourceobj,1
    gosub _entity_setupelementobject
    set object collision off obj
    show object obj
    `
   endif
  endif
 endif
next e
entobjpreviewlast=obj

rem Setup game view camera (overhead, so just drop down)
taty#=(gridlayer*100)+75
automatic camera collision 0,0,0
position camera storecx#,taty#,storecz#
point camera storecx#,taty#-100.0,storecz#
automatic camera collision 0,10,0
set camera range 1,4000
grav#=-5.0

rem Clear status text
statusbar$="" : popup_text_close()

rem mouselook mode on
open file map 1, "FPSEXCHANGE"
set file map dword 1, 44, 0
set file map dword 1, 48, 1
wait for file map event 1
close file map 1
change mouse 2

rem Preview loop
tescape=0
while tescape=0
 `
 rem Open filemap for input data
` sleep 3 : rem gives time to interface to get mouse deltas
 open file map 1, "FPSEXCHANGE"
 wait for file map event 1
 inputsys.xmousemove=get file map dword( 1, 8 )
 set file map dword 1, 8, 0
 inputsys.ymousemove=get file map dword( 1, 12 )
 set file map dword 1, 12, 0
 inputsys.mclick=get file map dword( 1, 20 )
 inputsys.kscancode=get file map dword( 1, 100 )
 if inputsys.kscancode=27 then tescape=1
 if inputsys.mclick<>0 then tescape=1
 `
 rem Close file map
 close file map 1
 `
 rem Control camera within test map
 gosub _universe_camera
 `
 rem Apply dynamic lighting to preview level
 gosub _lighting_managedynamiclights
 gosub _lighting_managegloballighting
 `
 rem Update screen
 sync
 `
endwhile

rem Restore lighting after preview
gosub _lighting_restore

rem Dim while delete universe
set ambient light 3
set text font "Verdana" : set text size 24 : ink rgb(255,255,255),0
for sss=0 to 1
 center text screen width()/2,screen height()/2,strarr$(327)
 sync
next sss

rem wait until all mouse activity over and escape key released
while tescape=1
 open file map 1, "FPSEXCHANGE"
 set file map dword 1, 44, 1
 set file map dword 1, 48, 0
 wait for file map event 1
 inputsys.mclick=get file map dword( 1, 20 )
 inputsys.kscancode=get file map dword( 1, 100 )
 if inputsys.mclick=0 and inputsys.kscancode=0 then tescape=0
 close file map 1
endwhile
change mouse 0

rem Restore camera
gosub _editor_restoreeditcamera
updatezoom=1

rem Free entity preview objects
for obj=entobjpreview to entobjpreviewlast
 if object exist(obj)=1 then delete object obj
next obj

rem Switch off ghosting in original entity objects
`100205 - never ghosted!
`for e=1 to entityelementlist
` if entityelement(e).staticflag=0
`  sourceobj=entitybankoffset+entityelement(e).bankindex
`  if object exist(sourceobj)=1
`   ghost object off sourceobj
`  endif
` endif
`next e

rem Destruct universe
gosub _universe_destruct

rem Restore ambience for editor when done
set text font "Verdana"
set ambient light 30
ink rgb(255,255,0),0
set text size 16

rem Restore entity and elements arrays for regular map editing
for entid=storeentidmaster+1 to entidmaster
 entobj=entitybankoffset+entid
 if object exist(entobj)=1 then delete object entobj
 entitybank$(entid)=""
next entid
entidmaster=storeentidmaster
entityelementlist=storeentityelementlist

rem restore object visibilities
gosub _editor_refresheditmarkers

return

`
` INPUT SYSTEM SUBROUTINES
`

_input_getdirectcontrols:

rem Direct input
inputsys.activemouse=1
inputsys.xmouse=mousex()
inputsys.ymouse=mousey()
inputsys.xmousemove=mousemovex()
inputsys.ymousemove=mousemovey()
inputsys.wheelmousemove=mousemovez()
inputsys.mclick=mouseclick()
inputsys.k$=lower$(inkey$())
inputsys.kscancode=scancode()

rem Control keys direct from keyboard
inputsys.keyreturn=returnkey()
inputsys.keyshift=shiftkey()
inputsys.keyleft=leftkey()
inputsys.keyright=rightkey()
inputsys.keyup=upkey()
inputsys.keydown=downkey()
inputsys.keycontrol=controlkey()
inputsys.keyspace=spacekey()

`rem debug display
`if debugcommreadoutactive=1
` if inputsys.kscancode<>88
`  set cursor 0,0
`  print "COMMS OUT"
`  print "DXSCANCODE : ";scancode()
`  print "DXCHAR : ";inkey$()
` endif
`endif

return

_input_checkarenaminspec:
 ttcount=0
 for tte=1 to entityelementlist
  ttentid=entityelement(tte).bankindex
  if entityprofile(ttentid).ischaracter=1
   inc ttcount
  endif
 next tte
 if ttcount>=2
  tokay=1
 else
  tokay=0
 endif
return

_input_getfilemapcontrols:

rem Update triggers and issue actions through filemapping system
open file map 1, "FPSEXCHANGE"
wait for file map event 1

rem If signal recieved of file map change
if 1
 `
 rem Obtain values (only if flagged)
 inputsys.xmouse=get file map dword( 1, 0 )
 inputsys.ymouse=get file map dword( 1, 4 )
 inputsys.xmousemove=get file map dword( 1, 8 )
 inputsys.ymousemove=get file map dword( 1, 12 )
 inputsys.wheelmousemove=get file map dword( 1, 16 )
 inputsys.mclick=get file map dword( 1, 20 )
 if get file map dword( 1, 28 )=1 then inputsys.mclick=2
 inputsys.kscancode=get file map dword( 1, 100 )
 `
 rem Control keys direct from keyboard
 inputsys.keyreturn=get file map dword( 1, 108 )
 inputsys.keyshift=get file map dword( 1, 112 )
 inputsys.keyup=get file map dword( 1, 120 )
 inputsys.keydown=get file map dword( 1, 124 )
 inputsys.keyleft=get file map dword( 1, 128 )
 inputsys.keyright=get file map dword( 1, 132 )
 inputsys.keycontrol=get file map dword( 1, 116 )
 if inputsys.kscancode=32 then inputsys.keyspace=1 else inputsys.keyspace=0
 `
 rem special trigger when click LIBRARY TAB, force into respective mode
 if get file map dword( 1, 546 )=1
  ttabindex=get file map dword( 1, 520 )
  if ttabindex=0 then inputsys.domodeselect=1 : inputsys.tseldelete=1
  if ttabindex=1 then inputsys.domodepaint=1
  if ttabindex=2 then inputsys.domodeentity=1
  if ttabindex=3 then inputsys.domodeentity=1
  set file map dword 1, 546, 0
 endif
 `
 rem recent file list
 trecentfilechoice=get file map dword( 1, 442 )
 if trecentfilechoice>0
  rem retain choice for action at end of subroutine
  trecentfilechoice$=get file map string$( 1, 1000 )
  set file map dword 1, 442, 0
 endif
 `
 rem termination trigger
 if get file map dword( 1, 908 )=1
  rem hrere we ask if changes should be saved, etc
  close file map 1
  gosub _gridedit_intercept_savefirst
  open file map 1,"FPSEXCHANGE"
  if editorcanceltask=0
   rem go ahead, confirmed, end interface program
   set file map dword 1, 912, 1
   wait for file map event 1
   rem end editor program
   if 1 then timestampactivity(5,"Terminated because 908=1")
   end
  else
   rem carry on with interface
   set file map dword 1, 908, 0
   wait for file map event 1
   close file map 1
  endif
 endif
 `
 rem EDIT MENU
 if get file map dword( 1, 446 )=1 then inputsys.doundo=1 : set file map dword 1, 446, 0
 if get file map dword( 1, 450 )=1 then inputsys.doredo=1 : set file map dword 1, 450, 0
 if get file map dword( 1, 454 )=1 then inputsys.tselcontrol=1 : inputsys.tselcut=1 : inputsys.tselcopy=1 : set file map dword 1, 454, 0
 if get file map dword( 1, 458 )=1 then inputsys.tselcontrol=1 : inputsys.tselcopy=1 : set file map dword 1, 458, 0
 if get file map dword( 1, 462 )=1 then inputsys.tseldelete=1 : set file map dword 1, 462, 0
 `
 rem Get toolbar triggers
 inputsys.doartresize=0
 toolbarset=get file map dword( 1, 200 )
 toolbarindex=get file map dword( 1, 204 )
 if toolbarindex>0
  if toolbarset=2
   rem map view
   select toolbarindex
    case 1 : inputsys.kscancode=188 : endcase
    case 2 : inputsys.kscancode=190 : endcase
    case 3 : inputsys.doshroudincrease=1 : endcase
    case 4 : inputsys.doshrouddecrease=1 : endcase
    case 5 : inputsys.kscancode=9 : endcase
    case 6 : inputsys.dolayerchange=gridlayer+1 : endcase
    case 7 : inputsys.dolayerchange=gridlayer-1 : endcase
    case 8 : inputsys.kscancode=86 : endcase
    case 9 : inputsys.kscancode=90 : endcase
   endselect
  endif
  if toolbarset=4
   rem segment mode and selection
   inputsys.domodepaint=1
   select toolbarindex
    case 1 : inputsys.kscancode=asc("A") : endcase
    case 2 : inputsys.kscancode=asc("X") : endcase
    case 3 : inputsys.kscancode=asc("M") : endcase
    case 4 : inputsys.kscancode=asc("F") : endcase
    case 5 : inputsys.kscancode=asc("K") : endcase
    case 6 : inputsys.kscancode=asc("E") : endcase
    case 7 : inputsys.kscancode=asc("N") : endcase
    case 8 : inputsys.kscancode=asc("P") : endcase
   endselect
  endif
  if toolbarset=5
   rem clipboard
   inputsys.domodeselect=1
   select toolbarindex
    case 1 : inputsys.kscancode=88 : inputsys.keycontrol=1 : endcase
    case 2 : inputsys.kscancode=67 : inputsys.keycontrol=1 : endcase
    case 3 : inputsys.kscancode=86 : inputsys.keycontrol=1 : endcase
    case 4 : inputsys.kscancode=66 : inputsys.keycontrol=1 : endcase
    case 5 : inputsys.kscancode=78 : inputsys.keycontrol=1 : endcase
    case 6 : inputsys.kscancode=46 : endcase
   endselect
  endif
  inputsys.domodeart=0
  if toolbarset=6
   rem art
   select toolbarindex
    case 1 : inputsys.domodeart=1 : endcase
    case 2 : inputsys.domodeart=2 : endcase
    case 3 : inputsys.domodeart=3 : endcase
    case 4 : inputsys.domodeart=4 : endcase
    case 5 : inputsys.doartresize=2 : endcase
    case 6 : inputsys.doartresize=1 : endcase
   endselect
  endif
  if toolbarset=8
   rem wayppoint
   inputsys.domodewaypoint=1
   select toolbarindex
    case 1 : inputsys.kscancode=115 : endcase
   endselect
  endif
  if toolbarset=9
   rem test panel
   select toolbarindex
    case 1 : rem TEST GAME
     tokay=0
     if gmultiplayergame=0
      tokay=1
     else
      rem only if arena mode elements ready (2 players or more)
      tokay=0 : gosub _input_checkarenaminspec
      if tokay=0
       rem Report need 2+ players for arena test
       set file map dword 1, 900, 1
       set file map string$ 1, 1256, strarr$(602)
       set file map string$ 1, 1000, strarr$(603)
       wait for file map event 1
       while get file map dword(1, 900)=1
        wait for file map event 1
       endwhile
       tokay=get file map dword(1, 904)
       close file map 1
      endif
     endif
     if tokay=1
     while ( 1 )
      rem wait for instruction to quit the editor
      wait for file map event 1
      if get file map dword( 1, 916 ) = 1
       `
       rem Save map data
       gosub _gridedit_save_test_map

       rem Save contents of testmap to TEMP (for later restoraion - ie buildexe style thing might overwrite testmap files)
       projectfilename$="editors\gridedit\temp.fpm"
       gosub _mapfile_saveproject_fpm

       rem Also save(resave) prefs (as multiplayer arena mode may have changed, ie NEW ARENA clicked)
       savesetupfile$="setup.ini" : gosub _interface_savesetupfile

       rem Launch Test Game Dialog
       open file map 4, "FPSEXCHANGE"
       set file map dword 4, 970, 1
       wait for file map event 4
       close file map 4
       rem Wait For Test Game Filemap Creation
       tquit=0
       while tquit=0
        open file map 4, "FPSTESTGAMEDIALOG"
        wait for file map event 4
        if get file map dword( 4, 0 ) = 1 then tquit=1
        close file map 4
       endwhile
       `
       rem Add Text To Test Game Dialog
       open file map 4, "FPSTESTGAMEDIALOG"
       set file map string$ 4, 1000, strarr$(328)
       set file map dword 4, 20, 1
       wait for file map event 4
       while get file map dword( 4, 20 ) = 1
        wait for file map event 4
       endwhile
       set file map string$ 4, 1000, strarr$(329)
       set file map dword 4, 24, 1
       wait for file map event 4
       while get file map dword( 4, 24 ) = 1
        wait for file map event 4
       endwhile
       set file map string$ 4, 1000, strarr$(331)
       set file map dword 4, 4, 1
       wait for file map event 4
       while get file map dword( 4, 4 ) = 1
        wait for file map event 4
       endwhile
       close file map 4
       `
       rem Version Control - launch game for test game mode
       gosub _version_permittestgame
       `
       rem Nowhere to go from here (terminated externally)
       if 1 then timestampactivity(4,"FPSC-MapEditor.exe Infinite Loop (wait for GAME.EXE to terminate)")
       do : sync : loop
       `
      endif
     endwhile
     endif
    endcase
    case 2 : inputsys.kscancode=220 : endcase
   endselect
  endif
  if toolbarset=10
   rem mode selector
   select toolbarindex
    case 1 : inputsys.kscancode=80 : endcase
    case 2 : inputsys.kscancode=69 : endcase
    case 3 : inputsys.kscancode=78 : endcase
    case 4 : inputsys.kscancode=79 : endcase
   endselect
  endif
 endif
 `
 rem Clear toolbar index
 set file map dword 1, 200, 0
 set file map dword 1, 204, 0
 `
 rem Clear deltas
 set file map dword 1, 8, 0
 set file map dword 1, 12, 0
 set file map dword 1, 16, 0
 `
 rem Deactivate mouse if leave 3d area
 inputsys.activemouse=1
 if inputsys.xmouse=-1 and inputsys.ymouse=-1
  inputsys.xmouse=screen width()/2
  inputsys.ymouse=screen height()/2
  inputsys.xmousemove=0
  inputsys.ymousemove=0
  inputsys.activemouse=0
  inputsys.mclick=0
  syncthreetimes=2
 endif
 `
 rem handle edit marker fades
 if inputsys.activemouse=0 and grideditselect<>4
  if shroudsize<10
   editmarkerfade#=-1.0
  endif
 else
  if editmarkerfade#=0.0
   editmarkerfade#=1.0
  endif
 endif
 `
 rem Convert FILE MAP COMM VALUES to DX INPUT CODES
 t$="" : tt=0
 select inputsys.kscancode
  case 9 : tt=15 : endcase
  case 32 : tt=57 : t$=" " : endcase
  case 33 : tt=201 : endcase
  case 34 : tt=209 : endcase
  case 37 : tt=203 : endcase
  case 38 : tt=200 : endcase
  case 39 : tt=205 : endcase
  case 40 : tt=208 : endcase
  case 42 : tt=16 : endcase
  case 46 : tt=211 : endcase
  case 54 : tt=16 : endcase
  case 112 : tt=59 : endcase
  case 113 : tt=60 : endcase
  case 114 : tt=61 : endcase
  case 115 : tt=62 : endcase
  case 123 : tt=88 : endcase
  case 187 : t$="=" : endcase
  case 188 : t$="," : endcase
  case 189 : t$="-" : endcase
  case 190 : t$="." : endcase
  case 192 : t$="'" : endcase
  case 219 : t$="[" : endcase
  case 220 : t$="\" : endcase
  case 221 : t$="]" : endcase
  case 222 : t$="#" : endcase
 endselect
 if inputsys.kscancode>=asc("A") and inputsys.kscancode<=asc("Z") then t$=lower$(chr$(inputsys.kscancode))
 if inputsys.kscancode>=asc("0") and inputsys.kscancode<=asc("9") then t$=lower$(chr$(inputsys.kscancode))
 if t$<>"" then tt=1
 `
 rem Get menu triggers
 inputsys.dosave=0 : inputsys.doopen=0 : inputsys.donew=0 : inputsys.donewarena=0 : inputsys.dosaveas=0
 if get file map dword( 1, 400 )=1 then inputsys.doopen=1 : set file map dword 1, 400, 0
 if get file map dword( 1, 404 )=1 then inputsys.dosave=1 : set file map dword 1, 404, 0
 if get file map dword( 1, 408 )=1 then inputsys.donew=1 : set file map dword 1, 408, 0
 if get file map dword( 1, 408 )=2 then inputsys.donewarena=1 : set file map dword 1, 408, 0
 if get file map dword( 1, 434 )=1 then inputsys.dosaveas=1 : set file map dword 1, 434, 0
 `
 rem select items from editing and segment menu to see values
 wait for file map event 1
 tindex1=get file map dword( 1, 712 )
 if tindex1>0
  tt=1 : t$=""
  tindex2=get file map dword( 1, 716 )
  if tindex1=2
   select tindex2
    case 1 : t$="a" : endcase
    case 2 : t$="m" : endcase
    case 3 : t$="f" : endcase
    case 4 : t$="k" : endcase
    case 5 : t$="x" : endcase
    case 6 : t$="a" : endcase
   endselect
  endif
  if tindex1=1
   select tindex2
    case 1 : t$="p" : endcase
    case 2 : t$="n" : endcase
    case 3 : t$="e" : endcase
    case 4 : t$="," : endcase
    case 5 : t$="." : endcase
    case 6 : t$="=" : endcase
    case 7 : t$="-" : endcase
    case 8 : t$="v" : endcase
   endselect
  endif
  set file map dword 1, 712, 0
  set file map dword 1, 716, 0
  wait for file map event 1
 endif
 `
 rem Record final translated key values
 inputsys.k$=t$ : inputsys.kscancode=tt
 `
 rem debug display
 if debugcommreadoutactive=1
  if inputsys.kscancode<>88
   print "COMMS OUT"
   print "MCLICK : ";inputsys.mclick
  endif
 endif
 `
 rem Determine if Library Selection Made
 if get file map dword( 1, 516 )>0
  set file map dword 1, 516, 0
  clickedonworkspace = get file map dword( 1, 520 )
  clickeditemonworkspace = get file map dword( 1, 524 )
  if clickeditemonworkspace<>-1
   `
   if clickedonworkspace=3
    `
    rem Selected Marker (playerstart,light,trigger,emission)
    addentityfile$=markerentitybank$(1+clickeditemonworkspace)
    if addentityfile$<>""
     gosub _entity_adduniqueentity
     tasset=entid
     if talreadyloaded=0 then gosub _editor_filllibrary
    endif
    inputsys.constructselection=tasset
    `
   else
    `
    if clickeditemonworkspace=0
     tnewadd=0
     if clickedonworkspace=0
      rem [new prefab]
      gosub _prefab_addtoselection
      tnewadd=prenewloaded
      tasset=preid
     endif
     if clickedonworkspace=1
      rem [new segment]
      gosub _segment_addtoselection
      tnewadd=segnewloaded
      tasset=segid
     endif
     if clickedonworkspace=2
      rem [new entity]
      gosub _entity_addtoselection
      tnewadd=entnewloaded
      tasset=entid
      if gmultiplayergame=1
       rem some entities cannot be used dynamically in arena mode
       if entityprofile(entid).isflak=1
        rem comment on restriction
        open file map 4,"FPSEXCHANGE"
        set file map dword 4, 900, 1
        set file map string$ 4, 1256, strarr$(604)
        if entityprofile(entid).ischaracter=1
         set file map string$ 4, 1000, strarr$(605)
        else
         set file map string$ 4, 1000, strarr$(606)
        endif
        wait for file map event 4
        while get file map dword(4, 900)=1
         wait for file map event 4
        endwhile
        tokay=get file map dword(4, 904)
        wait for file map event 4
        close file map 4
        if tokay=1
         rem wipe out weapon details (not functional in arena mode)
         entityprofile(entid).hasweapon$=""
         entityprofile(entid).hasweapon=0
         entityprofile(entid).isweapon=0
         entityprofile(entid).isammo=0
        else
         rem delete entity just loaded
         gosub _entity_delete : tnewadd=0 : tasset=0
        endif
       endif
      endif
     endif
     `
     rem add asset to library
     if tnewadd=1 then gosub _editor_filllibrary
     `
     rem use as current asset
     inputsys.constructselection=tasset
     `
    else
     `
     rem select existing asset
     if clickedonworkspace=2
      rem entity uses array to indicate the real entity index (to exclude markers - see above)
      inputsys.constructselection=locallibraryent(clickeditemonworkspace)
     else
      rem direct relationship between list index and choice
      inputsys.constructselection=clickeditemonworkspace
     endif
     `
    endif
    `
   endif
   `
   rem Workspace index determines editing mode
   if clickedonworkspace=0 then inputsys.domodeselect=1 : grideditselect=1
   if clickedonworkspace=1 then inputsys.domodepaint=1 : grideditselect=0
   if clickedonworkspace=2 then inputsys.domodeentity=1 : grideditselect=5
   if clickedonworkspace=3 then inputsys.domodeentity=1 : grideditselect=5
   gosub _editor_refresheditmarkers
   `
  endif
 endif
 `
endif

rem Ensure status bar is constantly updated
inc interfacestatusbarupdate
if interfacestatusbarupdate>30
 rem cursor position
 set file map string$ 1, 4256, strarr$(403)+str$(gridlayer)
 set file map string$ 1, 4512, "X:"+str$(inputsys.mmx)+"  "+"Z:"+str$(inputsys.mmy)
 set file map string$ 1, 4768, ""
 wait for file map event 1
 rem editing mode
 if grideditselect=0
  statusbar$=strarr$(332)
  if nogridsmart=-1
   if gridground=0
    statusbar$=statusbar$+strarr$(404)
   else
    statusbar$=statusbar$+strarr$(405)
   endif
  else
   if nogridsmart=0
    statusbar$=statusbar$+strarr$(333)
   else
    statusbar$=statusbar$+strarr$(334)
   endif
  endif
  statusbar$=statusbar$+strarr$(335)
 endif
 if grideditselect=1 then statusbar$=strarr$(336)
 if grideditselect=2
  statusbar$=strarr$(337)
  if grideditartmode=1 then statusbar$=statusbar$+strarr$(338)
  if grideditartmode=2 then statusbar$=statusbar$+strarr$(339)
  if grideditartmode=3 then statusbar$=statusbar$+strarr$(340)
  if grideditartmode=4 then statusbar$=statusbar$+strarr$(341)
 endif
 if grideditselect=3 then statusbar$=strarr$(342)
 if grideditselect=4 then statusbar$=strarr$(343)
 if grideditselect=5 then statusbar$=strarr$(344)
 rem only update infrequently
 interfacestatusbarupdate=0
endif

rem Close communicaion with filmapping system
close file map 1

rem Update status bar out of action subroutines
gosub _gridedit_updatestatusbar

rem Action after filemap activity
if trecentfilechoice>0
 rem save first
 gosub _gridedit_intercept_savefirst
 if editorcanceltask=0
  rem go ahead, load direct (skip the open dialog)
  projectfilename$=trecentfilechoice$
  gosub _gridedit_load_map
 endif
 trecentfilechoice=0
endif

return

_input_getcontrols:

rem Some actions are directly triggered by input subroutine
inputsys.doload=0
inputsys.domodepaint=0
inputsys.domodeselect=0
inputsys.domodeentity=0
inputsys.domodewaypoint=0
inputsys.dolayerchange=-1
inputsys.doundo=0
inputsys.doredo=0
inputsys.tselcontrol=0
inputsys.tselcut=0
inputsys.tselcopy=0
inputsys.tseldelete=0

rem Obtain input data
if gindieditorstate=1
 gosub _input_getdirectcontrols
else
 gosub _input_getfilemapcontrols
endif

rem Flag reset
inputsys.dorotation=0
inputsys.domirror=0
inputsys.doflip=0
inputsys.doentityrotate=0
inputsys.dozoomin=0
inputsys.dozoomout=0
inputsys.doscrollleft=0
inputsys.doscrollright=0
inputsys.doscrollup=0
inputsys.doscrolldown=0
inputsys.domapresize=0
inputsys.dogroundmode=-1
inputsys.domapview=0
inputsys.dozoomview=0
inputsys.dozoomviewmovex=0
inputsys.dozoomviewmovey=0
inputsys.dozoomviewmovez=0
inputsys.dozoomviewrotatex=0
inputsys.dozoomviewrotatey=0
inputsys.dozoomviewrotatez=0
inputsys.dosinglelayer=0
inputsys.tselfloor=0
inputsys.tselpaste=0
inputsys.tselwipe=0
inputsys.tselsaveselection=0
inputsys.dosaveandrun=0

rem Input conditional flags
if inputsys.kscancode=0 then inputsys.keypress=0

rem Construction Keys
if inputsys.keycontrol=0
 `
 if inputsys.k$="p" then inputsys.domodepaint=1
 if inputsys.k$="e" then inputsys.domodeselect=1 : inputsys.tseldelete=1
 if inputsys.k$="t" then inputsys.domodeart=1
 if grideditselect=2
  if inputsys.k$="i" then inputsys.domodeart=1
  if inputsys.k$="b" then inputsys.domodeart=2
  if inputsys.k$="c" then inputsys.domodeart=3
  if inputsys.k$="y" then inputsys.domodeart=4
  if inputsys.k$="[" and inputsys.keypress=0 then inputsys.doartresize=1 : inputsys.keypress=1
  if inputsys.k$="]" and inputsys.keypress=0 then inputsys.doartresize=2 : inputsys.keypress=1
 endif
 if (grideditselect=4 and gridentityinzoomview>0) or grideditselect=5
  if inputsys.k$="b" and inputsys.keypress=0
   inputsys.keypress=1 : gridentitygridlock=gridentitygridlock+1
   if gridentitygridlock>2 then gridentitygridlock=0
  endif
  if inputsys.k$="y" and inputsys.keypress=0 then inputsys.keypress=1 : gridentitystaticmode=1-gridentitystaticmode
  if inputsys.k$="u" and inputsys.keypress=0 then inputsys.keypress=1 : gridentitydroptoground=1
  if inputsys.k$="i" and inputsys.keypress=0 then inputsys.keypress=1 : gridentitydroptoground=2
  if inputsys.k$="[" and inputsys.keypress=0 then gridentitymodifyelement=1 : inputsys.keypress=1
  if inputsys.k$="]" and inputsys.keypress=0 then gridentitymodifyelement=2 : inputsys.keypress=1
 endif
 if inputsys.k$="n" then inputsys.domodeentity=1 : inputsys.dowaypointview=0
 if inputsys.k$="w" then inputsys.domodewaypoint=1 : inputsys.dowaypointview=0
 if inputsys.keyspace=1 and inputsys.keypress=0 then inputsys.dowaypointview=1-inputsys.dowaypointview : inputsys.keypress=1 : lastgrideditselect=-1 : gosub _editor_refresheditmarkers
 if inputsys.k$="m" and inputsys.keypress=0 then inputsys.domirror=1 : inputsys.keypress=1
 if inputsys.k$="f" and inputsys.keypress=0 then inputsys.doflip=1 : inputsys.keypress=1
 if inputsys.k$="a" then inputsys.dogroundmode=0
 if inputsys.k$="f" then inputsys.dogroundmode=1
 if inputsys.k$="x" then inputsys.dogroundmode=2
 if inputsys.k$="m" then inputsys.dogroundmode=3
 if inputsys.k$="v" and inputsys.keypress=0 then inputsys.domapview=1 : inputsys.keypress=1
 if inputsys.k$="k" then inputsys.domodepaint=1 : inputsys.dopickmapid=1 : gosub _editor_refresheditmarkers
 rem NUM-ROTATE CONTROLS
 if inputsys.k$="r" and inputsys.keypress=0 then inputsys.dorotation=1 : inputsys.keypress=1
 if gridentityinzoomview=0
  if inputsys.k$="z" and inputsys.keypress=0 then inputsys.dozoomview=1 : inputsys.keypress=1
 endif
 if grideditselect<>4
  if inputsys.k$="1" and inputsys.keypress=0 then inputsys.doentityrotate=1 : inputsys.keypress=1
  if inputsys.k$="2" and inputsys.keypress=0 then inputsys.doentityrotate=2 : inputsys.keypress=1
  if inputsys.k$="3" and inputsys.keypress=0 then inputsys.doentityrotate=3 : inputsys.keypress=1
  if inputsys.k$="4" and inputsys.keypress=0 then inputsys.doentityrotate=4 : inputsys.keypress=1
  if inputsys.k$="5" and inputsys.keypress=0 then inputsys.doentityrotate=5 : inputsys.keypress=1
  if inputsys.k$="6" and inputsys.keypress=0 then inputsys.doentityrotate=6 : inputsys.keypress=1
 endif
 `
 rem TEST Game
 if inputsys.k$="\" then inputsys.dosaveandrun=1
 `
 rem Editing of Map
 if inputsys.k$="," then inputsys.dozoomin=1
 if inputsys.k$="." then inputsys.dozoomout=1
 if inputsys.k$="'" then inputsys.doshrouddecrease=1
 if inputsys.k$="#" then inputsys.doshroudincrease=1
 `
 rem TAB Key causes layer edit view control
 if inputsys.kscancode=15 and inputsys.keypress=0 then inputsys.dosinglelayer=1 : inputsys.keypress=1
 `
 rem F1 for help page
 if inputsys.kscancode=59 then gosub _editor_showhelppage
 `
else
 `
 rem keys that also use CTRL
 if inputsys.k$="r" then inputsys.dorotation=1
 `
endif

rem Key Map Scroll and Resize
if inputsys.keyshift=0
 if inputsys.keycontrol=0
  if inputsys.keyleft=1 then inputsys.doscrollleft=1
  if inputsys.keyright=1 then inputsys.doscrollright=1
  if inputsys.keyup=1 then inputsys.doscrollup=1
  if inputsys.keydown=1 then inputsys.doscrolldown=1
 else
  if inputsys.keyleft=1 then inputsys.doscrollleft=100
  if inputsys.keyright=1 then inputsys.doscrollright=100
  if inputsys.keyup=1 then inputsys.doscrollup=100
  if inputsys.keydown=1 then inputsys.doscrolldown=100
 endif
else
 if inputsys.keyleft=1 then inputsys.doscrollleft=10
 if inputsys.keyright=1 then inputsys.doscrollright=10
 if inputsys.keyup=1 then inputsys.doscrollup=10
 if inputsys.keydown=1 then inputsys.doscrolldown=10
endif

rem Change Edit Layer
if inputsys.k$="-" and inputsys.keypress=0 then inputsys.dolayerchange=gridlayer-1 : inputsys.keypress=1
if inputsys.k$="=" and inputsys.keypress=0 then inputsys.dolayerchange=gridlayer+1 : inputsys.keypress=1

rem Mouse Wheel control
if grideditselect=4
 rem Zoomed in View
 dec zoomviewcamerarange#,(inputsys.wheelmousemove/10.0)
else
 rem Non-Zoomed in View
 if inputsys.keyshift=1
  if inputsys.wheelmousemove<0 then inputsys.dolayerchange=gridlayer+1
  if inputsys.wheelmousemove>0 then inputsys.dolayerchange=gridlayer-1
 else
  if inputsys.keycontrol=1
   if inputsys.wheelmousemove<0 then inputsys.doshrouddecrease=1
   if inputsys.wheelmousemove>0 then inputsys.doshroudincrease=1
  else
   if inputsys.wheelmousemove<0 then inputsys.dozoomout=1
   if inputsys.wheelmousemove>0 then inputsys.dozoomin=1
  endif
 endif
endif

rem CTRL Cut/Copy/Paste Keys
if inputsys.keycontrol=1
 inputsys.tselcontrol=1
 if inputsys.k$="x" then inputsys.tselcut=1 : inputsys.tselcopy=1
 if inputsys.k$="c" then inputsys.tselcopy=1
 if inputsys.k$="b" then inputsys.tselfloor=1
 if inputsys.k$="n" then inputsys.tselfloor=2
 if inputsys.k$="j" then inputsys.tselsaveselection=1
 if inputsys.k$="k" then gridlayershowall=1-gridlayershowall
endif
if inputsys.kscancode=211 then inputsys.tseldelete=1

rem UndoRedo Keys
if inputsys.keycontrol=1
 if inputsys.k$="" then inputsys.undokeypress=0
 if inputsys.k$="z" and inputsys.undokeypress=0 then inputsys.doundo=1 : inputsys.undokeypress=1
 if inputsys.k$="y" and inputsys.undokeypress=0 then inputsys.doredo=1 : inputsys.undokeypress=1
endif

rem Seperate undo events with nulls
if inputsys.undoredoevent<>0
 `
 rem Conditions for terminating event set
 tokay=0
 select inputsys.undoredoevent
  case 1
   if inputsys.mclick=0 then tokay=1
  endcase
 endselect
 `
 rem End event set
 if tokay=1
  gridevent=0 : gosub _editor_undoredoadd
  inputsys.undoredoevent=0
 endif
 `
endif

rem Controls only when in zoomview
if grideditselect=4
 rem orient arrowkey movement to camera angle
 tca#=wrapvalue(camera angle y())
 if tca#>=360-45 or tca#<=45
  txa=1 : txb=2 : txc=0 : txd=0
  tza=0 : tzb=0 : tzc=2 : tzd=1
 else
  if tca#>=180-45 and tca#<=180+45
   txa=2 : txb=1 : txc=0 : txd=0
   tza=0 : tzb=0 : tzc=1 : tzd=2
  else
   if tca#<=180
    txa=0 : txb=0 : txc=2 : txd=1
    tza=2 : tzb=1 : tzc=0 : tzd=0
   else
    txa=0 : txb=0 : txc=1 : txd=2
    tza=1 : tzb=2 : tzc=0 : tzd=0
   endif
  endif
 endif
 inputsys.dozoomviewmovex=0 : inputsys.dozoomviewmovez=0
 if inputsys.keyleft=1 then inc inputsys.dozoomviewmovex,txa : inc inputsys.dozoomviewmovez,tza
 if inputsys.keyright=1 then inc inputsys.dozoomviewmovex,txb : inc inputsys.dozoomviewmovez,tzb
 if inputsys.keyup=1 then inc inputsys.dozoomviewmovex,txc : inc inputsys.dozoomviewmovez,tzc
 if inputsys.keydown=1 then inc inputsys.dozoomviewmovex,txd : inc inputsys.dozoomviewmovez,tzd
 rem control rotation
 if inputsys.k$="1" and inputsys.keypress=0 then inputsys.dozoomviewrotatex=1 : inputsys.keypress=1
 if inputsys.k$="2" and inputsys.keypress=0 then inputsys.dozoomviewrotatex=2 : inputsys.keypress=1
 if inputsys.k$="3" and inputsys.keypress=0 then inputsys.dozoomviewrotatey=1 : inputsys.keypress=1
 if inputsys.k$="4" and inputsys.keypress=0 then inputsys.dozoomviewrotatey=2 : inputsys.keypress=1
 if inputsys.k$="5" and inputsys.keypress=0 then inputsys.dozoomviewrotatez=1 : inputsys.keypress=1
 if inputsys.k$="6" and inputsys.keypress=0 then inputsys.dozoomviewrotatez=2 : inputsys.keypress=1
endif
if grideditselect=4 or grideditselect=5
 rem control finder
 if inputsys.keyreturn=1 and gridentity>0
  gridentitydroptoground=1+entityprofile(gridentity).forwardfacing
 endif
 rem control height
 if grideditselect=4
  if inputsys.kscancode=201 then inputsys.dozoomviewmovey=2
  if inputsys.kscancode=209 then inputsys.dozoomviewmovey=1
 else
  if inputsys.kscancode=201 then inc gridentityposy#,1.0
  if inputsys.kscancode=209 then dec gridentityposy#,1.0
 endif
endif

rem Create a waypoint when instructed to
if inputsys.kscancode=62 and inputsys.keypress=0 then inputsys.keypress=1 : inputsys.domodewaypoint=1 : grideditselect=6 : mx#=inputsys.localx# : mz#=inputsys.localy# : gosub _waypoint_createnew

return

_input_calculatelocalcursor:

rem Layer height based on mode
if grideditselect=6
 layerheight#=curvevalue((gridlayer*100.0)+15.0,layerheight#,5.0)
else
 layerheight#=curvevalue(gridlayer*100.0,layerheight#,5.0)
endif

rem Local cursor calculation
if grideditselect<>4
 rem do not change these values if in zoom mode (unnecessary recalc of shroud)
 tx#=(inputsys.xmouse-(workareax/2))/gridscale#
 ty#=(inputsys.ymouse-(workareay/2))/gridscale#
 tilex#=tx#
 tiley#=ty#
else
 tx#=tilex#
 ty#=tiley#
endif
tx=tx#+(cx#/100.0)
ty=ty#+(cy#/100.0)
if tx<0 then tx=0
if ty<0 then ty=0
if tx>maxx-1 then tx=maxx-1
if ty>maxy-1 then ty=maxy-1
inputsys.mmx=tx : inputsys.mmy=ty

rem World cursor position
otx#=tx#+(cx#/100.0)
oty#=ty#+(cy#/100.0)
dec otx#,(tx+0.5)
dec oty#,(ty+0.5)
otx#=otx#*100
oty#=oty#*100
inputsys.localx#=((tx*100)+50)+otx#
inputsys.localy#=((ty*-100)-50)-oty#

return

_editor_disableforzoom:
 `
 open file map 2, "FPSEXCHANGE"
 set file map dword 2, 850, 1
 wait for file map event 2
 close file map 2
 `
return

_editor_enableafterzoom:
 `
 open file map 2, "FPSEXCHANGE"
 set file map dword 2, 850, 0
 wait for file map event 2
 close file map 2
 gosub _editor_cutcopyclearstate
 `
return

_editor_init:

rem Prepare grid edit meshes
gosub _gridedit_createmeshes

rem Load editor images for blueprint mesh sets
load image "editors\gfx\1.bmp",editorimagesoffset+0
load image "editors\gfx\7.bmp",editorimagesoffset+1

rem Load editor images
`load image "editors\gfx\3.bmp",editorimagesoffset+2 now 14,15,16,17
load image "editors\gfx\0B.bmp",editorimagesoffset+2
load image "editors\gfx\4.bmp",editorimagesoffset+3
load image "editors\gfx\5.bmp",editorimagesoffset+4
load image "editors\gfx\6.bmp",editorimagesoffset+5
load image "editors\gfx\0.bmp",editorimagesoffset+6

rem Cursor for segment highlighting
load image "editors\gfx\14.bmp",editorimagesoffset+14
load image "editors\gfx\15.bmp",editorimagesoffset+15
load image "editors\gfx\16.bmp",editorimagesoffset+16
load image "editors\gfx\17.bmp",editorimagesoffset+17
load image "editors\gfx\19.bmp",editorimagesoffset+19
load image "editors\gfx\25.bmp",editorimagesoffset+25

rem Additional segment cursors (KINDOF icons)
load image "editors\gfx\20.bmp",editorimagesoffset+20
load image "editors\gfx\21.bmp",editorimagesoffset+21
load image "editors\gfx\22.bmp",editorimagesoffset+22
load image "editors\gfx\23.bmp",editorimagesoffset+23
load image "editors\gfx\24.bmp",editorimagesoffset+24
rem RESERVE FOR +32 ie editorimagesoffset+20+(32-1)
load image "editors\gfx\24.bmp",editorimagesoffset+20+(32-1)

rem Cursor for entity highlighting
load image "editors\gfx\9.bmp",editorimagesoffset+7
load image "editors\gfx\18.bmp",editorimagesoffset+18
load image "editors\gfx\26.bmp",editorimagesoffset+26

rem Load last-to-draw images for editor
if file exist("editors\gfx\8.dds")=1
 load image "editors\gfx\8.dds",editorimagesoffset+8
else
 load image "editors\gfx\8.tga",editorimagesoffset+8
 save image "editors\gfx\8.dds",editorimagesoffset+8
endif

rem Load texture used by waypoint to draw-over-realview polys
load image "editors\gfx\13.bmp",editorimagesoffset+13

rem Work area paint cursor
make object box 2,100,100,100
position object 2,1*50,50,1*-50
texture object 2,editorimagesoffset+15 : ghost object on 2
set object collision off 2
disable object zdepth 2
set object light 2,0

rem Work area boundbox cursor
make object box 3,102,102,102
texture object 3,editorimagesoffset+3 : ghost object on 3 : set object light 3,0
set object collision off 3
disable object zdepth 3
make object box 4,102,102,102 : set object cull 4,0
texture object 4,editorimagesoffset+4 : ghost object on 4 : set object light 4,0
hide object 3 : hide object 4
set object collision off 4
disable object zdepth 4

rem Work area entity cursor
make object plain 5,150,150 : xrotate object 5,90
texture object 5,editorimagesoffset+7
ghost object on 5
modifyplaneimagestrip(5,8,1)
set object collision off 5
disable object zdepth 5
set object light 5,0
hide object 5

rem Work arrow for direction indicator (i.e. clipboard prefab orientation)
make object plain 6,150,150 : xrotate object 6,90
texture object 6,editorimagesoffset+15
ghost object on 6
set object collision off 6
disable object zdepth 6
set object light 6,0
hide object 6

rem Work area art highlighters
obj=editormarkeroffset
make object box obj,100,102,100 : texture object obj,editorimagesoffset+3
ghost object on obj : set object light obj,0
scale object texture obj,5,5
set object collision off obj
disable object zdepth obj
hide object obj
for o=obj+1 to editormarkeroffsetmax
 instance object o,obj
 set object collision off o
 disable object zdepth o
 hide object o
next o

rem Setup camera
color backdrop rgb(32,32,32)
set camera range 10,10000
set light range 0,10000
set ambient light 30
set camera fov 90
autocam off

rem Position camera
cx#=800*gridzoom# : cy#=600*gridzoom#
gridscale#=((800/2)/8)/gridzoom#
workareax=screen width()
workareay=screen height()
gosub _editor_restoreeditcamera

rem Reset statu bar text
statusbar$="" : laststatusbar$=""

return

_editor_hideall3d:
 position camera 199999,99999,99999
 point camera 199999,100999,99999
 sync : sync
return

_editor_restoreeditcamera:
 position camera cx#,600*gridzoom#,cy#
 point camera cx#,0,cy#
return

_editor_clearlibrary:

rem Delete all library
for tabs=0 to 3
 set file map dword 1, 534, tabs
 set file map dword 1, 542, 1
 wait for file map event 1
 while get file map dword(1, 542)=1
  wait for file map event 1
 endwhile
next tabs

rem And create default NEW icons
for tadd=1 to 3
 if tadd=1 then t1$=strarr$(345) : t2$="files\editors\host\res\newpre.bmp"
 if tadd=2 then t1$=strarr$(346) : t2$="files\editors\host\res\newseg.bmp"
 if tadd=3 then t1$=strarr$(347) : t2$="files\editors\host\res\newent.bmp"
 if tadd=4 then t1$=strarr$(348) : t2$="files\editors\host\res\newent.bmp"
 set file map dword 1, 508, tadd-1
 set file map string$ 1, 1000, t2$
 set file map string$ 1, 1256, t1$
 set file map dword 1, 500, 1
 wait for file map event 1
 while get file map dword(1, 500)=1
  wait for file map event 1
 endwhile
next tadd

rem Default markers
tadd=4
for tt=0 to 14
 if tt=0 then t1$=strarr$(349) : t2$="files\entitybank\_markers\player start.bmp"
 if tt=1 then t1$=strarr$(350) : t2$="files\entitybank\_markers\player checkpoint.bmp"
 if tt=2 then t1$=strarr$(351) : t2$="files\entitybank\_markers\white light.bmp"
 if tt=3 then t1$=strarr$(352) : t2$="files\entitybank\_markers\red light.bmp"
 if tt=4 then t1$=strarr$(353) : t2$="files\entitybank\_markers\green light.bmp"
 if tt=5 then t1$=strarr$(354) : t2$="files\entitybank\_markers\blue light.bmp"
 if tt=6 then t1$=strarr$(355) : t2$="files\entitybank\_markers\yellow light.bmp"
 if tt=7 then t1$=strarr$(356) : t2$="files\entitybank\_markers\purple light.bmp"
 if tt=8 then t1$=strarr$(357) : t2$="files\entitybank\_markers\cyan light.bmp"
 if tt=9 then t1$=strarr$(358) : t2$="files\entitybank\_markers\heal zone.bmp"
 if tt=10 then t1$=strarr$(359) : t2$="files\entitybank\_markers\hurt zone.bmp"
 if tt=11 then t1$=strarr$(360) : t2$="files\entitybank\_markers\win zone.bmp"
 if tt=12 then t1$=strarr$(361) : t2$="files\entitybank\_markers\trigger zone.bmp"
 if tt=13 then t1$=strarr$(362) : t2$="files\entitybank\_markers\sound zone.bmp"
 if tt=14 then t1$=strarr$(607) : t2$="files\entitybank\_markers\story zone.bmp"
 set file map dword 1, 508, tadd-1
 set file map string$ 1, 1000, t2$
 set file map string$ 1, 1256, t1$
 set file map dword 1, 500, 1
 wait for file map event 1
 while get file map dword(1, 500)=1
  wait for file map event 1
 endwhile
next tt
`
rem actual entity names of the markers
dim markerentitybank$(15)
markerentitybank$(1)="_markers\player start.fpe"
markerentitybank$(2)="_markers\player checkpoint.fpe"
markerentitybank$(3)="_markers\white light.fpe"
markerentitybank$(4)="_markers\red light.fpe"
markerentitybank$(5)="_markers\green light.fpe"
markerentitybank$(6)="_markers\blue light.fpe"
markerentitybank$(7)="_markers\yellow light.fpe"
markerentitybank$(8)="_markers\purple light.fpe"
markerentitybank$(9)="_markers\cyan light.fpe"
markerentitybank$(10)="_markers\heal zone.fpe"
markerentitybank$(11)="_markers\hurt zone.fpe"
markerentitybank$(12)="_markers\win zone.fpe"
markerentitybank$(13)="_markers\trigger zone.fpe"
markerentitybank$(14)="_markers\sound zone.fpe"
markerentitybank$(15)="_markers\story zone.fpe"

rem clear counters
locallibrarypreidmaster=0
locallibrarysegidmaster=0
locallibraryentidmaster=0
locallibraryentindex=0
preidmaster=0

return

_editor_filllibrary:

rem Store place before adds
wait for file map event 1
tstoredtabindex=get file map dword( 1, 520 )

rem Ensure prefab list is up to date in library
while locallibrarypreidmaster<preidmaster
 inc locallibrarypreidmaster
 if prefabbanklocal$(locallibrarypreidmaster)=""
  t2$=getfile(prefabbank$(locallibrarypreidmaster))
 else
  t2$=prefabbanklocal$(locallibrarypreidmaster)
 endif
 ttext$=prefabbank$(locallibrarypreidmaster)
 tbitmap$="files\prefabs\"+ttext$
 t1$=left$(tbitmap$,len(tbitmap$)-4)+".bmp"
 if file exist("..\"+t1$)=0 then t1$="files\editors\host\res\newpre.bmp"
 set file map dword 1, 508, 0
 set file map string$ 1, 1000, left$(t1$,254)
 set file map string$ 1, 1256, left$(t2$,254)
 set file map dword 1, 500, 1
 wait for file map event 1
 while get file map dword(1, 500)=1
  wait for file map event 1
 endwhile
endwhile

rem Ensure segment list is up to date in library (ignore first one)
while locallibrarysegidmaster<segidmaster
 inc locallibrarysegidmaster
 if selectionbanklocal$(locallibrarysegidmaster)=""
  rem Localization for segment local name
  tflocalfilename$="languagebank\"+language$+"\textfiles\library\segments\"+selectionbank$(locallibrarysegidmaster)
  tflocalfilename$=left$(tflocalfilename$,len(tflocalfilename$)-4)+".loc"
  if file exist(tflocalfilename$)=1
   dim tflocal$(1)
   load array tflocalfilename$,tflocal$()
   selectionbanklocal$(locallibrarysegidmaster)=tflocal$(0)
   undim tflocal$()
  endif
 endif
 t2$=selectionbanklocal$(locallibrarysegidmaster)
 ttext$=selectionbank$(locallibrarysegidmaster)
 tbitmap$="files\segments\"+ttext$
 t1$=left$(tbitmap$,len(tbitmap$)-4)+".bmp"
 if file exist("..\"+t1$)=0 then t1$="files\editors\host\res\newseg.bmp"
 set file map dword 1, 508, 1
 set file map string$ 1, 1000, left$(t1$,254)
 set file map string$ 1, 1256, left$(t2$,254)
 set file map dword 1, 500, 1
 wait for file map event 1
 while get file map dword(1, 500)=1
  wait for file map event 1
 endwhile
endwhile

rem Ensure entity list is up to date in library
while locallibraryentidmaster<entidmaster
 inc locallibraryentidmaster
 rem only if not marker
 if entityprofile(locallibraryentidmaster).ismarker=0 or entityprofile(locallibraryentidmaster).ismarker=4

  rem add to actual list
  t2$=entityprofileheader(locallibraryentidmaster).desc$
  ttext$=entitybank$(locallibraryentidmaster)
  tbitmap$="files\entitybank\"+ttext$
  t1$=left$(tbitmap$,len(tbitmap$)-4)+".bmp"
  if file exist("..\"+t1$)=0 then t1$="files\editors\host\res\newent.bmp"
  set file map dword 1, 508, 2
  set file map string$ 1, 1000, left$(t1$,254)
  set file map string$ 1, 1256, left$(t2$,254)
  set file map dword 1, 500, 1
  wait for file map event 1
  while get file map dword(1, 500)=1
   wait for file map event 1
  endwhile
  rem add to internal list array
  inc locallibraryentindex
  dim locallibraryent(locallibraryentindex)
  locallibraryent(locallibraryentindex)=locallibraryentidmaster
 endif
endwhile

rem Restore place after adds
set file map dword 1, 534, 1+tstoredtabindex
wait for file map event 1

return

_editor_filemapdefaultinitfornew:

rem Open for some Defaults for Editor
open file map 1, "FPSEXCHANGE"

rem Marker Defaults
entidmaster=0

rem filllibrary with segments and entities from default prefabs (temp as is above)
gosub _editor_filllibrary

rem Default is prefabs
set file map dword 1, 534, 1
wait for file map event 1

rem Close when set all defaults
close file map 1

return

_editor_filemapinit:

rem Open for some Defaults for Editor
open file map 1, "FPSEXCHANGE"

rem Set default mouse position and visibility
set file map dword 1, 0, 400
set file map dword 1, 4, 300
wait for file map event 1

rem Each selection tab needs a NEW icon
gosub _editor_clearlibrary
gosub _editor_filllibrary

rem Default is prefabs
set file map dword 1, 534, 1
wait for file map event 1

rem Close when set all defaults
close file map 1

return

_editor_loadcfg:

rem Load existing config file
if file exist("editors\gridedit\cfg.cfg")=1
 open to read 1,"editors\gridedit\cfg.cfg"
  `
  rem Current Camera Position
  if skipfpmloading=1
   read float 1,cx#
   read float 1,cy#
   read float 1,gridzoom#
   read file 1,gridlayer
  else
   read float 1,a#
   read float 1,a#
   read float 1,a#
   read file 1,a
  endif
  `
  rem Edit Vars
  if skipfpmloading=1
   read file 1,nogridsmart
   read file 1,grideditartmode
   read file 1,grideditselect
  else
   read file 1,a
   read file 1,a
   read file 1,a
  endif
  `
  rem Project (only need project name if skipping FPM=using temp.fpm)
  read string 1,temp$ : if skipfpmloading=1 then projectfilename$=temp$
  read string 1,currentFPG$
  `
  rem Shroud Settings
  if skipfpmloading=1
   read file 1,shroudsize
   read file 1,gridlayershowsingle
  else
   read file 1,a
   read file 1,a
  endif
  `
 close file 1
endif

rem If projectname has changed, this config will not match the new level
if projectfilename$<>currentprojectfilename$
 rem first reset config
 gosub _gridedit_clear_configsettings
 rem then find the left-top-lowest most segment to focus on
 for tlayer=0 to layermax
  for ty=0 to maxy
   for tx=0 to maxx
    tmapid=map(tlayer,tx,ty)
    if tmapid<>0
     cx#=tx*100 : cy#=ty*100 : gridlayer=tlayer
     tx=maxx : ty=maxy
     tlayer=layermax
     exit
    endif
   next tx
  next ty
 next tlayer
 shroudrefresh=1 : gosub _gridedit_updatelayershades
endif

rem Update editor settings
gosub _editor_refresheditmarkers
shroudrefresh=1
updatezoom=1

rem Current project name stored for next time
currentprojectfilename$=projectfilename$

return

_editor_savecfg:

rem Delete config file
if file exist("editors\gridedit\cfg.cfg")=1 then delete file "editors\gridedit\cfg.cfg"

rem Save config file
open to write 1,"editors\gridedit\cfg.cfg"
 `
 rem Current Camera Position
 write float 1,cx#
 write float 1,cy#
 write float 1,gridzoom#
 write file 1,gridlayer
 `
 rem Edit Vars
 write file 1,nogridsmart
 write file 1,grideditartmode
 write file 1,grideditselect
 `
 rem Project
 write string 1,projectfilename$
 write string 1,currentFPG$
 `
 rem Shroud Settings
 write file 1,shroudsize
 write file 1,gridlayershowsingle
 `
close file 1

return

_editor_saveselectionasprefab:

rem if segments and selection exists
if segidmaster>0 and bufferlayer<>-1
 `
 rem get filename
 open file map 1, "FPSEXCHANGE"
 set file map string$ 1, 1000, rootdir$+"prefabs\"
 set file map string$ 1, 1256, "FPP (*.fpp)"
 set file map string$ 1, 1512, strarr$(363)
 set file map dword 1, 428, 1
 wait for file map event 1
 while get file map dword(1,428)=1
  wait for file map event 1
 endwhile
 tfile$=get file map string$(1,1000)
 close file map 1
 if tfile$<>""
  `
  pfile$=right$(tfile$,len(tfile$)-len(rootdir$))
  pfile$=left$(pfile$,len(pfile$)-4)
  prefab$=pfile$+".fpmb"
  prefabbmp$=pfile$+".bmp"
  prefabolay$=pfile$+".fpmo"
  prefabsegs$=pfile$+".fpp"
  prefaboverlaylist$=pfile$+".fpol"
  `
  rem delete if exists
  if file exist(prefab$)=1 then delete file prefab$
  if file exist(prefabbmp$)=1 then delete file prefabbmp$
  if file exist(prefabolay$)=1 then delete file prefabolay$
  if file exist(prefabsegs$)=1 then delete file prefabsegs$
  if file exist(prefaboverlaylist$)=1 then delete file prefaboverlaylist$
  `
  rem ensure buffer arrays match buffersizevars
  undim storebuffermap()
  undim storebuffermapolay()
  dim storebuffermap(bufferlayer+1,buffermaxx+1,buffermaxy+1)
  dim storebuffermapolay(bufferlayer+1,buffermaxx+1,buffermaxy+1)
  for layer=0 to bufferlayer
   for my=0 to buffermaxy
    for mx=0 to buffermaxx
     storebuffermap(layer,mx,my)=buffermap(layer,mx,my)
     storebuffermapolay(layer,mx,my)=buffermapolay(layer,mx,my)
    next mx
   next my
  next layer
  rem save array data for this prefab
  save array prefab$,storebuffermap()
  save array prefabolay$,storebuffermapolay()
  save array prefaboverlaylist$,olaylist()
  rem free usages
  undim storebuffermap()
  undim storebuffermapolay()
  `
  rem save out header to describe prefab
  open to write 1,prefabsegs$
   write file 1,bufferlayer
   write file 1,buffermaxx
   write file 1,buffermaxy
   write file 1,segidmaster
   write file 1,olaylistmax
   if segidmaster>0
    for segid=1 to segidmaster
     write string 1,selectionbank$(segid)
    next segid
   endif
  close file 1
  `
  rem do not need any more
  gosub _gridedit_deleteclipboard
  `
  rem prepare screen for screenshot
  color backdrop rgb(255,255,255)
  for obj=1 to 6
   if object exist(obj)=1 then hide object obj
  next obj
  if object exist(realviewobjectoffset)=1 then hide object realviewobjectoffset
  gosub _editor_hideblueprint
  `
  rem mouselook mode on
  open file map 1, "FPSEXCHANGE"
  set file map dword 1, 48, 1
  wait for file map event 1
  close file map 1
  `
  rem show preview
  position camera 0,(gridlayer*100)+200,0
  point camera 150,gridlayer*100,-150
  set camera aspect 1.0
  rem adjust camera to suit good shot
  snapshotloop=1
  while snapshotloop=1
   rem input data
   open file map 1, "FPSEXCHANGE"
   wait for file map event 1
   inputsys.xmousemove=get file map dword( 1, 8 )
   set file map dword 1, 8, 0
   inputsys.ymousemove=get file map dword( 1, 12 )
   set file map dword 1, 12, 0
   inputsys.mclick=get file map dword( 1, 20 )
   inputsys.kscancode=get file map dword( 1, 100 )
   close file map 1
   rem move around
   rotate camera camera angle x()+inputsys.ymousemove/2.0,camera angle y()+inputsys.xmousemove/2.0,0
   if inputsys.kscancode=asc("W") then move camera 4.0
   if inputsys.kscancode=asc("S") then move camera -4.0
   pcx#=camera angle x() : pcz#=camera angle z()
   if inputsys.kscancode=asc("A") then rotate camera 0,camera angle y()-90,0 : move camera 4.0 : yrotate camera camera angle y()+90
   if inputsys.kscancode=asc("D") then rotate camera 0,camera angle y()-90,0 : move camera -4.0 : yrotate camera camera angle y()+90
   rotate camera pcx#,camera angle y(),pcz#
   if inputsys.mclick=1 then snapshotloop=0
   rem update screen
   sync
  endwhile
  tclicking=1
  while tclicking=1
   open file map 1, "FPSEXCHANGE"
   set file map dword 1, 48, 0
   wait for file map event 1
   inputsys.mclick=get file map dword( 1, 20 )
   close file map 1
   if inputsys.mclick=0 then tclicking=0
  endwhile
  if snapshotloop=0
   rem take the shot
   set camera view 0,0,64,64 : sync : sync
   get image editorimagesoffset-1,0,0,64,64
   save image prefabbmp$,editorimagesoffset-1
   delete image editorimagesoffset-1
  endif
  `
  rem restore
  set camera view 0,0,screen width(),screen height()
  set camera aspect 640.0/480.0
  color backdrop rgb(32,32,32)
  gosub _editor_refresheditmarkers
  if object exist(realviewobjectoffset)=1 then show object realviewobjectoffset
  `
 endif
endif

return

_editor_constructionselection:

if inputsys.constructselection>0
 `
 rem SINGLE SEGMENT
 if grideditselect=0
  if inputsys.constructselection<=segidmaster
   gridselection=inputsys.constructselection
   gridsymbol=segmentprofile(gridselection).blueprint.symbol
   gridground=segmentprofile(gridselection).properties.groundmode
   gridkindof=segmentprofile(gridselection).properties.kindof
   nogridsmart=-1 : rem AUTO BY DEFAULT FROM SELECTION
   gosub _editor_refresheditmarkers
  endif
 endif
 `
 rem PRE-FAB SEGMENTS
 if grideditselect=1
  `
  rem Loading and making prefab
  statusbar$=strarr$(364) : gosub _gridedit_updatestatusbar
  `
  rem if prefab in range
  if inputsys.constructselection<=preidmaster
  `
  rem load in local segs list for prefab
  prefab$="prefabs\"+prefabbank$(inputsys.constructselection)
  prefab$=left$(prefab$,len(prefab$)-4)
  prefabsegs$=prefab$+".fpp"
  open to read 1,prefabsegs$
   read file 1,bufferlayer
   read file 1,buffermaxx
   read file 1,buffermaxy
   read file 1,locasegslistmaster
   read file 1,localolaylistmax
   dim localsegslist$(locasegslistmaster)
   if locasegslistmaster>0
    for tsegid=1 to locasegslistmaster
     read string 1,localsegslist$(tsegid)
    next tsegid
   endif
  close file 1
  `
  rem load prefab mapdata
  undim buffermap(0)
  undim bufferrefmap(0)
  undim buffermapolay(0)
  dim buffermap(1+bufferlayer,1+buffermaxx,1+buffermaxy)
  dim bufferrefmap(1+bufferlayer,1+buffermaxx,1+buffermaxy)
  dim buffermapolay(1+bufferlayer,1+buffermaxx,1+buffermaxy)
  gosub _gridedit_deletebuffermesh
  prefabmap$=prefab$+".fpmb"
  load array prefabmap$,buffermap()
  prefabolay$=prefab$+".fpmo"
  load array prefabolay$,buffermapolay()
  dim localolaylist(localolaylistmax,50) as DWORD
  prefaboverlaylist$=prefab$+".fpol"
  load array prefaboverlaylist$,localolaylist()
  `
  rem orient ciipboard for zero rotation to begin with
  bufferrotationcount=0 : gridorient=0
  `
  rem reorder mapdata to layout of current segment list
  segdir$="segments\"
  for tlayer=0 to bufferlayer
   for ty=0 to buffermaxy
    for tx=0 to buffermaxx
     mapid=buffermap(tlayer,tx,ty)
     if mapid<>0
      rem get map tile, determine what segment it used, and find/load into current
      gosub _gridedit_getmapvalues
      rem re-map to new segment index
      seg$=localsegslist$(mapselection)
      segcategory$=getfirstdir(seg$)
      segpath$=getseconddir(seg$)
      gosub _segment_addtoworkspace
      mapselection=segid
      rem put new segment index back
      writebuffermap(tlayer,tx,ty,mapselection,mapscaler,mapground,maprotate,maporient,mapsymbol,maptile)
     endif
    next tx
   next ty
  next tlayer
  `
  rem reorder map overlay data to layout of current segment list
  for tlayer=0 to bufferlayer
   for ty=0 to buffermaxy
    for tx=0 to buffermaxx
     `
     rem get local olayindex, find a real free one and update buffermapolay
     tolayindex=buffermapolay(tlayer,tx,ty)
     if tolayindex>0
      rem find new overlay index
      gosub _gridedit_addolay_findfree
      rem place overlay in buffer map
      buffermapolay(tlayer,tx,ty)=olayindex
     endif
     `
     rem go through local olaylist, adding to new list as we go
     if tolayindex>0
      for ti=0 to 50
       mapid=localolaylist(tolayindex,ti)
       if mapid<>0
        rem get map tile, determine what segment it used, and find/load into current
        gosub _gridedit_getmapvalues
        rem re-map to new segment index
        seg$=localsegslist$(mapselection)
        segcategory$=getfirstdir(seg$)
        segpath$=getseconddir(seg$)
        gosub _segment_addtoworkspace
        mapselection=segid
        rem put new mapid in the new olaylist
        mapid=getmapid(mapselection,mapscaler,mapground,maprotate,maporient,mapsymbol,maptile)
        olaylist(olayindex,ti)=mapid
        rem place any related entities in buffer ref
        storetlayer=tlayer : storetx=tx : storety=ty
        layer=tlayer : mx=tx : my=ty : gridorient=maporient
        seg=mapselection : gridaddtobufferref=1 : gosub _gridedit_addsegmententities
        tlayer=storetlayer : tx=storetx : ty=storety
       endif
      next ti
     endif
     `
    next tx
   next ty
  next tlayer
  `
  rem free usages
  undim localsegslist$()
  undim localolaylist()
  `
  rem flag the entities we used here to hold entity data are removed when done!
  bufferholdscutdata=1
  `
  rem may have added segments/entities so update library
  open file map 1,"FPSEXCHANGE"
  gosub _editor_filllibrary
  close file map 1
  `
  rem build clipboard from buffer data
  gosub _gridedit_createbuffermesh
  shroudrefresh=1
  `
  rem Prefab uses automatic segment connections
  nogridsmart=-2 : rem DIRECT PASTE NO MODIFICATION OF WALLS
  gosub _editor_refresheditmarkers
  `
  rem Clear status text
  statusbar$="" : gosub _gridedit_updatestatusbar
  `
  endif
  `
 endif
 `
 rem SINGLE ENTITY
 if grideditselect=5
  if inputsys.constructselection<=entidmaster
   rem select entity profile and start orientation
   gridentity=inputsys.constructselection
   gridentityeditorfixed=0
   gridentityrotatex#=entityprofile(gridentity).rotx
   gridentityrotatey#=entityprofile(gridentity).roty
   gridentityrotatez#=entityprofile(gridentity).rotz
   gridentityposy#=(gridlayer*100.0)+2.5
   inc gridentityposy#,entityprofile(gridentity).defaultheight
   inc gridentityposx#,entityprofile(gridentity).offx
   inc gridentityposy#,entityprofile(gridentity).offy
   inc gridentityposz#,entityprofile(gridentity).offz
   gridentitystaticmode=entityprofile(gridentity).defaultstatic
   if entityprofile(gridentity).ismarker=2 then gridentityrotatex#=180
   rem fill new selection with defaults
   sentid=entid : entid=gridentity : gosub _entity_fillgrideleproffromprofile : entid=sentid
   grideleproflastname$=grideleprof.name$
  endif
 endif
 `
 rem Construction complete
 inputsys.constructselection=0
 `
endif

rem AUTO/FLAT/DIRECT DRAW MODE
if inputsys.dogroundmode<>-1
 `
 rem new system uses AUTO, WALL amd FLOOR modes (internal and external)
 if inputsys.dogroundmode=0
  nogridsmart=-1 : rem AUTO
  gridground=0 : rem INTERNAL
 endif
 if inputsys.dogroundmode=2
  nogridsmart=-1 : rem AUTO
  gridground=2 : rem EXTERNAL
 endif
 if inputsys.dogroundmode=1
  nogridsmart=1 : rem FLOOR
 endif
 if inputsys.dogroundmode=3
  nogridsmart=0 : rem WALL
 endif
 `
 rem update cursor
 gosub _editor_refresheditmarkers
 `
endif

return

_editor_overallfunctionality:

rem show state of edit mode by work grid colour
if object exist(1)=1
 if gmultiplayergame=0
  texture object 1,editorimagesoffset+6
 else
  texture object 1,editorimagesoffset+2
 endif
endif

rem Restore current grid view
if inputsys.doautozoomview=1 then inputsys.doautozoomview=0 : inputsys.dozoomview=1
if inputsys.domapview=1 or inputsys.dozoomview=1
 if cameraviewmode=1
  cx#=stcx# : cy#=stcy# : gridzoom#=stgridzoom#
  grideditselect=stgrideditselect : gosub _editor_refresheditmarkers
  inputsys.domapview=0
  cameraviewmode=0
  updatezoom=1
 endif
 if cameraviewmode=2
  rem mouselook mode off
  open file map 1, "FPSEXCHANGE"
  set file map dword 1, 48, 0
  wait for file map event 1
  close file map 1
  rem re-enable icons
  gosub _editor_enableafterzoom
  rem end zoom mode
  grideditselect=stgrideditselect : gosub _editor_refresheditmarkers
  inputsys.dozoomview=0
  cameraviewmode=0
 endif
endif

rem Switch to map view
if inputsys.domapview=1
 if cameraviewmode=0
  `
  rem Store current grid view
  stcx#=cx# : stcy#=cy# : stgridzoom#=gridzoom#
  stgrideditselect=grideditselect
  `
  rem Set camera view for entire map
  borderx#=(maxx*100.0) : cx#=borderx#/2.0
  bordery#=(maxy*100.0) : cy#=bordery#/2.0
  tsize=maxx : if tsize<maxy then tsize=maxy
  gridzoom#=tsize/10.0
  cameraviewmode=1
  updatezoom=1
  `
  rem Mode - Map View
  grideditselect=3 : gosub _editor_refresheditmarkers
  `
 endif
endif

rem Switch to zoom view
if inputsys.dozoomview=1
 if cameraviewmode=0
  `
  rem Set camera to track with close-up
  stgrideditselect=grideditselect
  cameraviewmode=2
  `
  rem reset some variables
  zoomviewcameraangle#=0
  zoomviewcameraheight#=75.0
  `
  rem Fix shroud position for realview
  shroudmmx=cx#/100.0 : shroudmmy=cy#/100.0
  `
  rem Mode - ZoomIn View
  grideditselect=4 : gosub _editor_refresheditmarkers
  updatezoom=1
  `
 endif
endif

rem Recalculate zoom scale for editing
if updatezoom=1
 `
 rem grid scale for camera cursor location and zoom
 gridscale#=((800/2)/8)/gridzoom#
 inputsys.keypress=1
 updatezoom=0
 `
 rem single layer edit clips the camera near plane
 if gridlayershowsingle=2 and grideditselect<>4
  gridnearcameraclip=(600.0*gridzoom#)-50
 else
  gridnearcameraclip=0
 endif
 `
 rem adjust clipping range of camera to match
 set camera range 1+gridnearcameraclip,((600.0*gridzoom#)+1000)
 `
endif

rem use intersect test to find ground/wall and drop entity onto it
if gridentitydroptoground>=1 and gridentitydroptoground<=2
 gosub _editor_findentityground
 gridentitydroptoground=0
endif

rem Change editing layer
if inputsys.dolayerchange<>-1
 tokay=1
 if inputsys.dolayerchange<0 or inputsys.dolayerchange>layermax-1 then tokay=0
 if gridentity>0 and tokay=1
  gridentityposy#=gridentityposy#+((inputsys.dolayerchange-gridlayer)*100.0)
 endif
 gridlayer=inputsys.dolayerchange
 if gridlayer<0 then gridlayer=0
 if gridlayer>layermax-1 then gridlayer=layermax-1
 shroudrefresh=1 : gosub _gridedit_updatelayershades
endif

rem Change layer show mode
if inputsys.dosinglelayer=1
 gridlayershowsingle=gridlayershowsingle+1
 if gridlayershowsingle>2 then gridlayershowsingle=0
 shroudrefresh=1 : gosub _gridedit_updatelayershades
 updatezoom=1
endif

rem If editing trigger marker, shift allows selection of area
if grideditselect=5
 if gridentity>0
  if entityprofile(gridentity).ismarker=3
   if inputsys.keyshift=1
    gridentitytriggerareaselect=1
   endif
  endif
 endif
endif

return

_editor_gridfunctionality:

rem Rotation of segment or buffer
if grideditselect=0
 if inputsys.dorotation=1
  inc gridorient
  if gridorient>3
   gridorient=0
  endif
  inputsys.keypress=1
  yrotate object 2,wrapvalue(gridorient*90)
 endif
endif
if grideditselect=1
 if inputsys.dorotation=1 or inputsys.domirror=1 or inputsys.doflip=1
  gosub _gridedit_deletebuffermesh
  if inputsys.dorotation=1 then gosub _gridedit_rotatebuffermap
  gosub _gridedit_createbuffermesh
  shroudrefresh=1
 endif
endif

rem Rotation of entity
if grideditselect=5
 rem do not rotate light or trigger entity
 if entityprofile(gridentity).ismarker<>2 and entityprofile(gridentity).ismarker<>3
  if inputsys.keyshift=1
   tspeedofrot#=1.0 : inputsys.keypress=0
  else
   if inputsys.keycontrol=1
    tspeedofrot#=10.0
   else
    tspeedofrot#=45.0
   endif
  endif
  if inputsys.dorotation=1 then inc gridentityrotatey#,tspeedofrot#
  if inputsys.doentityrotate=1 then dec gridentityrotatex#,tspeedofrot#
  if inputsys.doentityrotate=2 then inc gridentityrotatex#,tspeedofrot#
  if inputsys.doentityrotate=3 then dec gridentityrotatey#,tspeedofrot#
  if inputsys.doentityrotate=4 then inc gridentityrotatey#,tspeedofrot#
  if inputsys.doentityrotate=5 then dec gridentityrotatez#,tspeedofrot#
  if inputsys.doentityrotate=6 then inc gridentityrotatez#,tspeedofrot#
  gridentityrotatex#=wrapvalue(gridentityrotatex#)
  gridentityrotatey#=wrapvalue(gridentityrotatey#)
  gridentityrotatez#=wrapvalue(gridentityrotatez#)
 endif
endif

rem Load and Save
if inputsys.doload=1 then gosub _gridedit_load_map
if inputsys.dosave=1 then gosub _gridedit_save_map_ask
if inputsys.doopen=1 then gosub _gridedit_open_map_ask
if inputsys.donew=1 or inputsys.donewarena=1 then gosub _gridedit_new_map_ask
if inputsys.dosaveas=1 then gosub _gridedit_saveas_map
if inputsys.dosaveandrun=1 then inputsys.dosaveandrun=0 : gosub _editor_previewmap

rem Undo \ Redo
if inputsys.doundo=1 then gosub _editor_undoredobackwards
if inputsys.doredo=1 then gosub _editor_undoredoforwards

rem Paint Select or Art Mode
if inputsys.domodepaint=1 then grideditselect=0 : gosub _editor_refresheditmarkers
if inputsys.domodeselect=1 then grideditselect=1 : gosub _editor_refresheditmarkers
if inputsys.tselsaveselection=1 then inputsys.tselsaveselection=0 : gosub _editor_saveselectionasprefab
if inputsys.domodeart>0 then grideditselect=2 : grideditartmode=inputsys.domodeart : inputsys.domodeart=0 : gosub _editor_refresheditmarkers
if inputsys.domodeentity=1 then grideditselect=5 : gosub _editor_refresheditmarkers
if inputsys.domodewaypoint=1 then grideditselect=6 : gosub _editor_refresheditmarkers
if inputsys.doartresize>0
 if inputsys.doartresize=1 and grideditartwidth>1 then dec grideditartwidth : inputsys.domodeart=0
 if inputsys.doartresize=2 and grideditartwidth<6 then inc grideditartwidth : inputsys.domodeart=0
 if grideditartwidth=1 then grideditartwidthx=1 : grideditartwidthy=1
 if grideditartwidth=2 then grideditartwidthx=2 : grideditartwidthy=1
 if grideditartwidth=3 then grideditartwidthx=1 : grideditartwidthy=2
 if grideditartwidth=4 then grideditartwidthx=2 : grideditartwidthy=2
 if grideditartwidth=5 then grideditartwidthx=3 : grideditartwidthy=3
 if grideditartwidth=6 then grideditartwidthx=4 : grideditartwidthy=4
endif

rem Manage waypoints on map
if grideditselect=6
 mx#=inputsys.localx# : mz#=inputsys.localy# : mclick=inputsys.mclick
 waypointeditheight#=(gridlayer*100.0)+5
 gosub _waypoint_mousemanage
endif

rem Zoom factor
if inputsys.dozoomin=1 and gridzoom#>0.3 and inputsys.keypress=0 then updatezoom=1 : dec gridzoom#,0.1
if inputsys.dozoomout=1 and gridzoom#<5.0 and inputsys.keypress=0 then updatezoom=1 : inc gridzoom#,0.1

rem Shroud Resize
if inputsys.doshroudfull=1 then shroudsize=10 : inputsys.doshroudfull=0 : editmarkerfade#=1.0 : shroudrefresh=1
if inputsys.doshroudfull=2 then shroudsize=5 : inputsys.doshroudfull=0 : editmarkerfade#=1.0 : shroudrefresh=1
if inputsys.doshroudincrease=1 and shroudsize<10 then inc shroudsize : inputsys.doshroudincrease=0 : shroudrefresh=1
if inputsys.doshrouddecrease=1 and shroudsize>2 then dec shroudsize : inputsys.doshrouddecrease=0 : shroudrefresh=1

rem Scroll Map
borderx#=(maxx*100.0)
bordery#=(maxy*100.0)
if inputsys.doscrollleft<>0
 if inputsys.doscrollleft=1 then dec cx#,gridzoom#*20
 if inputsys.doscrollleft=10 then dec cx#,gridzoom#*200
 if inputsys.doscrollleft=100 then cx#=0
endif
if inputsys.doscrollright<>0
 if inputsys.doscrollright=1 then inc cx#,gridzoom#*20
 if inputsys.doscrollright=10 then inc cx#,gridzoom#*200
 if inputsys.doscrollright=100 then cx#=borderx#
endif
if inputsys.doscrollup<>0
 if inputsys.doscrollup=1 then dec cy#,gridzoom#*20
 if inputsys.doscrollup=10 then dec cy#,gridzoom#*200
 if inputsys.doscrollup=100 then cy#=0
endif
if inputsys.doscrolldown<>0
 if inputsys.doscrolldown=1 then inc cy#,gridzoom#*20
 if inputsys.doscrolldown=10 then inc cy#,gridzoom#*200
 if inputsys.doscrolldown=100 then cy#=bordery#
endif


rem Scroll boundaries
if cx#<0 then cx#=0
if cy#<0 then cy#=0
if cx#>borderx# then cx#=borderx#
if cy#>bordery# then cy#=bordery#

`rem Resize Map
`if inputsys.domapresize>0
` mapresize=inputsys.domapresize
` gosub _gridedit_resize_map
` if object exist(1)=1 then delete object 1
` inputsys.domapresize=-1
`endif

return

_editor_viewfunctionality:

rem map view controls
if grideditselect=3
 if inputsys.mclick=1
  stcx#=inputsys.mmx*100.0
  stcy#=inputsys.mmy*100.0
  cx#=stcx# : cy#=stcy# : gridzoom#=stgridzoom#
  grideditselect=stgrideditselect : gosub _editor_refresheditmarkers
  while inputsys.mclick=1 : gosub _input_getcontrols : sync : endwhile
  cameraviewmode=0
  updatezoom=1
 endif
endif

rem zoom view controls
if grideditselect=4
 `
 rem can repos and rotate non-editor-entities
 if entityelement(gridentityinzoomview).editorfixed=0
  `
  rem position adjustment
  if inputsys.dozoomviewmovex=1 then dec zoomviewtargetx#,1.0
  if inputsys.dozoomviewmovex=2 then inc zoomviewtargetx#,1.0
  if inputsys.dozoomviewmovey=1 then dec zoomviewtargety#,1.0
  if inputsys.dozoomviewmovey=2 then inc zoomviewtargety#,1.0
  if inputsys.dozoomviewmovez=1 then dec zoomviewtargetz#,1.0
  if inputsys.dozoomviewmovez=2 then inc zoomviewtargetz#,1.0
  `
  rem rotation adjustment
  if entityprofile(gridentity).ismarker<>2 and entityprofile(gridentity).ismarker<>3
   if inputsys.keyshift=1
    tspeedofrot#=1.0 : inputsys.keypress=0
   else
    if inputsys.keycontrol=1
     tspeedofrot#=10.0
    else
     tspeedofrot#=45.0
    endif
   endif
   if inputsys.dorotation=1 then inc zoomviewtargetry#,tspeedofrot#
   if inputsys.dozoomviewrotatex=1 then dec zoomviewtargetrx#,tspeedofrot#
   if inputsys.dozoomviewrotatex=2 then inc zoomviewtargetrx#,tspeedofrot#
   if inputsys.dozoomviewrotatey=1 then dec zoomviewtargetry#,tspeedofrot#
   if inputsys.dozoomviewrotatey=2 then inc zoomviewtargetry#,tspeedofrot#
   if inputsys.dozoomviewrotatez=1 then dec zoomviewtargetrz#,tspeedofrot#
   if inputsys.dozoomviewrotatez=2 then inc zoomviewtargetrz#,tspeedofrot#
  endif
  `
  rem update gridentity vars for visual
  gridentityposx#=zoomviewtargetx#
  gridentityposy#=zoomviewtargety#
  gridentityposz#=zoomviewtargetz#
  gridentityrotatex#=zoomviewtargetrx#
  gridentityrotatey#=zoomviewtargetry#
  gridentityrotatez#=zoomviewtargetrz#
  `
  rem aply grid if 5x5
  if gridentitygridlock=1
   gridentityposx#=(int(gridentityposx#/5)*5)
   gridentityposz#=(int(gridentityposz#/5)*5)
  endif
  `
 endif
 `
 rem mouselook mode on/off RMB
 open file map 1, "FPSEXCHANGE"
 if inputsys.mclick=2
  rem center mouse
  set file map dword 1, 48, 1
  rem camera position
  inc zoomviewcameraangle#,inputsys.xmousemove/4.0
  dec zoomviewcameraheight#,inputsys.ymousemove/3.0
 else
  set file map dword 1, 48, 0
 endif
 wait for file map event 1
 close file map 1
 `
 rem exit zoom view
 if inputsys.mclick=1 then tpressedtoleavezoommode=1
 if inputsys.mclick=0 and tpressedtoleavezoommode=1 then tpressedtoleavezoommode=2
 if (tpressedtoleavezoommode=2 or inputsys.kscancode=211) or editorinterfaceleave=1
  `
  rem leave zoomview
  inputsys.doautozoomview=1
  `
  rem reset mouse click (must release LMB before zoom mode ends)
  tpressedtoleavezoommode=0
  `
  rem close any property window
  gosub _interface_closepropertywindow
  editorinterfaceleave=0
  `
  rem place entity on the map
  if gridentityinzoomview>0
   `
   rem DELETE key deletes entity no matter what (for fixed entities too)
   if gridentity<>0 and inputsys.kscancode=211
    if gridentityobj=0
     delete object gridentityobj
     gridentityobj=0
    endif
   else
    gosub _gridedit_addentitytomap
    gridentityinzoomview=0
   endif
   shroudrefresh=1
   gridentity=0
   `
  endif
  `
 endif
 `
endif

return

_editor_findentityground:
 `
 rem for entities that can be moved
 if entityelement(gridentityinzoomview).editorfixed=0
  `
  rem finds ground
  if gridentitydroptoground=1
   tbestdist#=99999 : tbesty#=0
   tto#=gridentityposy#-200.0
   if inputsys.keyshift=0
    tfrom#=gridentityposy#+200.0
   else
    tfrom#=gridentityposy#+1.0
   endif
   for obj=realviewobjectoffset+1 to realviewobjectoffsetend
    if obj<>gridentityobj
     if object exist(obj)=1
      if intersect object(obj,gridentityposx#,tfrom#,gridentityposz#,gridentityposx#,tto#,gridentityposz#)<>0
       tdist#=abs(checklist fvalue b(6)-tfrom#)
       if tdist#<tbestdist#
        tbesty#=checklist fvalue b(6)
        tbestdist#=tdist#
       endif
      endif
     endif
    endif
   next obj
   if tbestdist#<99999
    rem found point where our entity will rest vertically, now need entities own thickness from object 0,0,0 to base
    rem grid of ray casts for good base detect resolution
    ttentsizex#=object size x(gridentityobj)/2.0
    ttentsizez#=object size z(gridentityobj)/2.0
    if ttentsizex#<1.0 and ttentsizex#<ttentsizez# then ttentsizex#=ttentsizez#
    if ttentsizez#<1.0 and ttentsizez#<ttentsizex# then ttentsizez#=ttentsizex#
    stepvaluex#=object size x(gridentityobj)/10.0
    stepvaluez#=object size z(gridentityobj)/10.0
    if object exist(entityworkobjectoffset)=1 then delete object entityworkobjectoffset
    make object box entityworkobjectoffset,object size x(gridentityobj),object size y(gridentityobj),object size z(gridentityobj)
    position object entityworkobjectoffset,object position x(gridentityobj)+object collision center z(gridentityobj),object position y(gridentityobj)+object collision center y(gridentityobj),object position z(gridentityobj)+object collision center z(gridentityobj)
    rotate object entityworkobjectoffset,object angle x(gridentityobj),object angle y(gridentityobj),object angle z(gridentityobj)
    hide object entityworkobjectoffset
    tsmallest#=99999
    tscbase#=object position y(entityworkobjectoffset)-(object size y(entityworkobjectoffset)*2)
    for tentscanx#=ttentsizex#*-1 to ttentsizex# step stepvaluex#
     for tentscanz#=ttentsizez#*-1 to ttentsizez# step stepvaluez#
      tgap#=intersect object(entityworkobjectoffset,gridentityposx#+tentscanx#,tscbase#,gridentityposz#+tentscanz#,gridentityposx#+tentscanx#,tscbase#+200.0,gridentityposz#+tentscanz#)
      if tgap#<>0.0
       if tgap#<tsmallest# then tsmallest#=tgap#
      endif
     next tentscanz#
    next tentscanx#
    if tsmallest#<99999
     tthickness#=object position y(gridentityobj)-(tscbase#+tsmallest#)
    else
     tthickness#=0
    endif
    if object exist(entityworkobjectoffset)=1 then delete object entityworkobjectoffset
    gridentityposy#=tbesty#+tthickness# : zoomviewtargety#=tbesty#+tthickness#
    `
    rem FPSCV104RC7 - step up to next layer if crosses threshold
    if gridentityposy# > (gridlayer*100)+100
     inputsys.dolayerchange=gridlayer+1
    endif
    `
   endif
  endif
  `
  rem finds wall
  if gridentitydroptoground=2
   tbestdist#=99999 : tbestx#=0 : tbestz#=0
   tbesty#=gridentityposy#+object collision center y(gridentityobj)
   a=gridentityrotatey#
   tfromx=newxvalue(gridentityposx#,a,-5.0) : ttox=newxvalue(gridentityposx#,a,75.0)
   tfromz=newzvalue(gridentityposz#,a,-5.0) : ttoz=newzvalue(gridentityposz#,a,75.0)
   for obj=realviewobjectoffset+1 to realviewobjectoffsetend
    if obj<>gridentityobj
     if object exist(obj)=1
      tdist#=intersect object(obj,tfromx,tbesty#,tfromz,ttox,tbesty#,ttoz)
      if tdist#<>0
       if tdist#<tbestdist#
        tbestx#=checklist fvalue a(6)
        tbestz#=checklist fvalue c(6)
        tbestdist#=tdist#
       endif
      endif
     endif
    endif
   next obj
   if tbestdist#<99999
    rem found point where our entity will rest on wall
    rem now need entities own thickness from object 0,0,0 to wall-contact
    tbestx#=newxvalue(tbestx#,a+180,-5.0)
    tbestz#=newzvalue(tbestz#,a+180,-5.0)
    ttox=newxvalue(tbestx#,a+180,100.0)
    ttoz=newzvalue(tbestz#,a+180,100.0)
    if object exist(entityworkobjectoffset)=1 then delete object entityworkobjectoffset
    make object box entityworkobjectoffset,object size x(gridentityobj),object size y(gridentityobj),object size z(gridentityobj)
    position object entityworkobjectoffset,object position x(gridentityobj)+object collision center z(gridentityobj),object position y(gridentityobj)+object collision center y(gridentityobj),object position z(gridentityobj)+object collision center z(gridentityobj)
    rotate object entityworkobjectoffset,object angle x(gridentityobj),object angle y(gridentityobj),object angle z(gridentityobj)
    hide object entityworkobjectoffset
    tgap#=intersect object(entityworkobjectoffset,tbestx#,tbesty#,tbestz#,ttox,tbesty#,ttoz)
    if tgap#>=4.9
     tgapx#=checklist fvalue a(6)
     tgapz#=checklist fvalue c(6)
     ttddx#=tgapx#-object position x(gridentityobj)
     ttddz#=tgapz#-object position z(gridentityobj)
     tthickness#=5.0+sqrt(abs(ttddx#*ttddx#)+abs(ttddz#*ttddz#))
    else
     tthickness#=5.0
    endif
    tbestx#=newxvalue(tbestx#,a+180,tthickness#+0.5)
    tbestz#=newzvalue(tbestz#,a+180,tthickness#+0.5)
    gridentityposx#=tbestx# : zoomviewtargetx#=tbestx#
    gridentityposz#=tbestz# : zoomviewtargetz#=tbestz#
    if object exist(entityworkobjectoffset)=1 then delete object entityworkobjectoffset
   endif
  endif
  `
 endif
 `
return

_editor_hideblueprint:

rem Completely hide blueprint objects
for o=firstmeshobject to currentmeshobject
 if object exist(o)=1
  hide object o
 endif
next o

return

_editor_refresheditmarkers:

rem Edit Modes use different edit visual markers
if grideditselect=0
 if object exist(1)=1 then show object 1
 hide object 3 : hide object 4 : show object 2
 rem change cursor image based on segment edit mode (base/overlay/directional/whole)
 if inputsys.dopickmapid=1
  timg=editorimagesoffset+19
 else
  if gridkindof>0
   timg=editorimagesoffset+20+(gridkindof-1)
  else
   if segmentprofile(gridselection).vis.overlay=0
    if nogridsmart<>0
     if nogridsmart=1
      timg=editorimagesoffset+25
     else
      timg=editorimagesoffset+14
     endif
    else
     timg=editorimagesoffset+15
    endif
   else
    if segmentprofile(gridselection).vis.overlay=1
     timg=editorimagesoffset+17
    else
     timg=editorimagesoffset+16
    endif
   endif
  endif
 endif
 texture object 2,timg
 yrotate object 2,wrapvalue(gridorient*90)
endif
if grideditselect=1
 if object exist(1)=1 then show object 1
 hide object 2
 if showselectboundbox=0
  hide object 3 : hide object 4
 endif
endif
if grideditselect=2 then hide object 2 : hide object 3 : hide object 4
if grideditselect=3 then hide object 2 : hide object 3 : hide object 4
if grideditselect=4 then hide object 2 : hide object 3 : hide object 4
if grideditselect=5 then hide object 2 : hide object 3 : hide object 4
if grideditselect=6 then hide object 2 : hide object 3 : hide object 4
if grideditselect=4
 if object exist(1)=1 then hide object 1
else
 if object exist(1)=1 then show object 1
endif

rem Deactivate floating selection of entity
if grideditselect<>5 and grideditselect<>4
 if grideditselect<>5 then hide object 5
 gridentity=0
endif

rem Art Markers for art only
for obj=editormarkeroffset to editormarkeroffsetmax
 if grideditselect=2
  if editormarkeroffsethidefrom>0 and obj<editormarkeroffsethidefrom
   show object obj
  endif
 else
  hide object obj
 endif
next o

rem Hide blueprint objects in zoom mode (and blanking shroud)
if object exist(realviewobjectoffset)=1
 if grideditselect=4 then hide object realviewobjectoffset else show object realviewobjectoffset
endif
if grideditselect=4
 for o=firstmeshobject to currentmeshobject
  if object exist(o)=1 then hide object o
 next o
else
 gosub _gridedit_updatelayershades
endif

rem Activate/Deactivate shroud in some modes
if grideditselect=0 then shroudstatic=0
if grideditselect=1 then shroudstatic=0
if grideditselect=2 then shroudstatic=0
if grideditselect=3 then shroudstatic=2
if grideditselect=4 then shroudstatic=1
if grideditselect=5 then shroudstatic=0
if grideditselect=6 then shroudstatic=0
shroudrefresh=1

rem Update clipboard items based on mode
gosub _editor_cutcopyclearstate

rem Waypoint visibility
if grideditselect<>lastgrideditselect
 lastgrideditselect=grideditselect
 if grideditselect=6
  gosub _waypoint_showall
 else
  if inputsys.dowaypointview=0
   gosub _waypoint_showall
  else
   gosub _waypoint_hideall
  endif
 endif
endif

return

_editor_fadeeditmarkers:

rem Used for fading in and out all cursor objects (when mouse leaves/enters edit area)
if editmarkerfade#<0.0
 o=2 : if object exist(o)=1 then hide object o
 o=5 : if object exist(o)=1 then hide object o
 gosub _gridedit_deleterealviewoldshroud
 editmarkerfade#=0
endif
if editmarkerfade#>0.0 and editmarkerfade#<100.0
 editmarkerfade#=editmarkerfade#+10.0
 if editmarkerfade#>=100.0
  gosub _editor_refresheditmarkers
  editmarkerfade#=100.0
 endif
 if object exist(realviewobjectoffset)=1
  set alpha mapping on realviewobjectoffset,editmarkerfade#
 endif
endif

return

_editor_visuals:

rem 3D Clipboard objects
gosub _gridedit_updatebufferobjects

rem Real View Shroud
if oldtx<>inputsys.mmx or oldty<>inputsys.mmy then oldtx=inputsys.mmx : oldty=inputsys.mmy : shroudrefresh=1
if shroudsize<>oldshroudsize or shroudrefresh=1
 gosub _gridedit_deleterealviewoldshroud
 gosub _gridedit_recreaterealviewshroud
 oldshroudsize=shroudsize
 shroudrefresh=0
endif

rem Real View Shroud - alpha and visibilities
gosub _gridedit_displayrealviewshroud

rem Work Grid
if object exist(1)=0
 make object box 1,100,10,100
 set object collision off 1
 scale object 1,maxx*100,100,maxy*100
 position object 1,maxx*50,-5,maxy*-50
 scale object texture 1,maxx,maxy
 texture object 1,editorimagesoffset+6
 ghost object on 1
endif

rem Work Cursor
if object exist(1)=1
 position object 1,maxx*50,-5+layerheight#,maxy*-50
 if grideditselect=0
  if inputsys.activemouse=0 then hide object 2 else show object 2
 endif
 if map(gridlayer,tx,ty)=0
  position object 2,(tx*100)+50,2+layerheight#,(ty*-100)-50
  scale object 2,100,2,100
 else
  if gridlayershowsingle=2
   position object 2,(tx*100)+50,5+layerheight#,(ty*-100)-50
   scale object 2,100,5,100
  else
   position object 2,(tx*100)+50,50+layerheight#,(ty*-100)-50
   scale object 2,100,100,100
  endif
 endif
endif

rem Update Camera
gosub _editor_camera

return

_editor_camera:

rem Camera Mode
select cameraviewmode
 case 0 : rem Standard grid view
  position camera cx#,(600.0*gridzoom#)+layerheight#,0-cy#
  point camera cx#,0,0-cy#
 endcase
 case 1 : rem Overall map view
  position camera cx#,(600.0*gridzoom#)+layerheight#,0-cy#
  point camera cx#,0,0-cy#
 endcase
 case 2 : rem Tracking zoom view
  `
  rem update camera XZ with entity if editing position
  if gridentityinzoomview>0
   cx#=zoomviewtargetx# : cy#=0-zoomviewtargetz#
  endif
  `
  rem calculate view from position
  daa#=wrapvalue(zoomviewcameraangle#)
  dcx#=cx#+(sin(daa#)*zoomviewcamerarange#)
  dcy#=layerheight#+zoomviewcameraheight#
  dcz#=(0-(cy#+(cos(daa#)*zoomviewcamerarange#)))
  tcx#=curvevalue(dcx#,camera position x(),30.0)
  tcy#=curvevalue(dcy#,camera position y(),5.0)
  tcz#=curvevalue(dcz#,camera position z(),30.0)
  `
  rem if target was entity, view center of it
  if gridentityinzoomview>0
   tobj=entityelement(gridentityinzoomview).profileobj
   if tobj>0
    viewatx#=cx# : viewaty#=zoomviewtargety#+object size y(tobj)/2.0 : viewatz#=0-cy#
   else
    viewatx#=cx# : viewaty#=zoomviewtargety#+5 : viewatz#=0-cy#
   endif
  else
   viewatx#=cx# : viewaty#=zoomviewtargety#+5 : viewatz#=0-cy#
  endif
  `
  rem set smoothed camera view
  position camera tcx#,tcy#,tcz#
  point camera viewatx#,viewaty#,viewatz#
  `
 endcase
endselect

return

_editor_undoredoprojectstate:

rem set as modified
projectmodified=1 : gosub _gridedit_changemodifiedflag

rem control enabling of UNDO REDO menu items
open file map 1, "FPSEXCHANGE"
if currentundoredomarker>0
 set file map dword 1, 466, 1
else
 set file map dword 1, 466, 0
endif
if currentundoredomarker<array count(undoredolist())
 set file map dword 1, 470, 1
else
 set file map dword 1, 470, 0
endif
wait for file map event 1
close file map 1

return

_editor_cutcopyclearstate:

rem control enabling of UNDO REDO menu items
open file map 1, "FPSEXCHANGE"
if grideditselect=1
 if bufferlayer=-1 and showselectboundbox=1
  set file map dword 1, 474, 1
  set file map dword 1, 478, 1
 else
  set file map dword 1, 474, 0
  set file map dword 1, 478, 0
 endif
 if bufferlayer<>-1
  set file map dword 1, 482, 1
 else
  set file map dword 1, 482, 0
 endif
else
 set file map dword 1, 474, 0
 set file map dword 1, 478, 0
 set file map dword 1, 482, 0
endif
wait for file map event 1
close file map 1

return

_editor_undoredoadd:

rem When we add, we destroy all after the currentundoredomarker
tarraycount=array count(undoredolist())
if currentundoredomarker+1<tarraycount
 for e=currentundoredomarker+1 to tarraycount
  array delete element undoredolist(),currentundoredomarker+1
 next e
endif

rem Add undoredo item to list
array insert at bottom undoredolist()
array index to bottom undoredolist()

rem Fill item with event data
undoredolist().event=gridevent
select gridevent
 case 1 : rem add grid tile
  undoredolist().x=tx
  undoredolist().y=tlayer
  undoredolist().z=ty
  undoredolist().a=wasmapid
  undoredolist().b=tmapid
 endcase
endselect

rem Mark new current list index
currentundoredomarker=array count(undoredolist())

rem If this is called, means we have changed something
gosub _editor_undoredoprojectstate

return

_editor_undoredobackwards:

rem Only if not already at start of the list
if currentundoredomarker>0

 rem Go back through events and reverse
 array index to bottom undoredolist()
 arrayindex=array count(undoredolist())
 while array index valid(undoredolist())
  if arrayindex<currentundoredomarker
   select undoredolist().event
    case 0
     exit
    endcase
    case 1
     `
     rem Undo tile edit
     mx=undoredolist().x : layer=undoredolist().y : my=undoredolist().z
     wasmapid=map(layer,mx,my) : map(layer,mx,my)=undoredolist().a
     gosub _gridedit_refreshtile
     `
     rem Update tile area
     upx=mx : upy=my : uplayer=layer : gosub _gridedit_updatetile
     `
    endcase
   endselect
  endif
  previous array index undoredolist()
  dec arrayindex
 endwhile

 rem Store undoredo list index
 currentundoredomarker=arrayindex
 shroudrefresh=1
 `
 rem If this is called, means we have changed something
 gosub _editor_undoredoprojectstate
 `
endif

return

_editor_undoredoforwards:

rem Only if not already at the end of list
if currentundoredomarker<array count(undoredolist())

 rem Go forward through events and reverse
 for e=currentundoredomarker+1 to array count(undoredolist())
  select undoredolist(e).event
   case 0
    exit
   endcase
   case 1
    `
    rem Redo tile edit
    mx=undoredolist(e).x : layer=undoredolist(e).y : my=undoredolist(e).z
    wasmapid=map(layer,mx,my) : map(layer,mx,my)=undoredolist(e).b
    gosub _gridedit_refreshtile
    `
    rem Update tile area
    upx=mx : upy=my : uplayer=layer : gosub _gridedit_updatetile
    `
   endcase
  endselect
 next e
 `
 rem Store undoredo list index
 currentundoredomarker=e
 shroudrefresh=1
 `
 rem If this is called, means we have changed something
 gosub _editor_undoredoprojectstate
 `
endif

return

_gridedit_addsegmententities:

rem add any entities belonging to this placed segment
for tp=0 to segmentprofileheader(seg).partmax
  if segmentprofile(seg,tp).partmode=3
    `
    rem get entity details
    addentityfile$=segmentprofile(seg,tp).meshname$
    lgx#=segmentprofile(seg,tp).offx
    lgz#=segmentprofile(seg,tp).offz
    if gridorient>0
     for brot=0 to gridorient-1
      lgss#=lgx# : lgx#=lgz# : lgz#=lgss#*-1
     next brot
    endif
    lgx#=lgx#+(50+(mx*100))
    lgz#=lgz#+((my*-100)-50)
    lgy#=segmentprofile(seg,tp).offy+(50+(layer*100))
    if segmentprofile(seg).vis.overlay=1
     if gridorient=0 then lgz#=lgz#-1.0
     if gridorient=1 then lgx#=lgx#-1.0
     if gridorient=2 then lgz#=lgz#+1.0
     if gridorient=3 then lgx#=lgx#+1.0
    endif
    addentityx=lgx# : addentityy=lgy# : addentityz=lgz#
    addentityrx=0 : addentityry=segmentprofile(seg,tp).roty : addentityrz=0
    addentityry=addentityry+(gridorient*90)
    `
    rem if not already place entity here
    tokay=0
    if gridaddtobufferref=1
     rem if creating for bufferref, always create
    else
     if entityelementlist>0
      for te=1 to entityelementlist
       if entityelement(te).maintype>0
        tentid=entityelement(te).bankindex
        if abs((entityelement(te).x)-addentityx)<=2
         if abs((entityelement(te).y)-addentityy)<=2
          if abs((entityelement(te).z)-addentityz)<=2
           tokay=1 : exit
          endif
         endif
        endif
       endif
      next te
     endif
    endif
    if tokay=0
     `
     rem load/add entity profile
     gosub _entity_loadextra
     `
     rem Add entity reference into map
     addtobufferref=gridaddtobufferref : gosub _gridedit_addentityreftomap
     `
     rem special editor flag - cannot move these
     entityelement(e).editorfixed=1
     `
     rem also always dynamic (no point having static entity attachments in segment-selection)
     entityelement(e).staticflag=0
     `
    endif
    `
  endif
next tp

return

_gridedit_drawsingletile:

rem takes in layer,mx,my
addgridselection=gridselection
addgridscaler=0
addgridground=gridground
addgridorient=gridorient
addgridsymbol=gridsymbol

rem depending on kind of segment
if segmentprofile(gridselection).vis.overlay=0
 rem Add new seg and remove old overlays from this tile
 tfreshgridadd=1 : gosub _gridedit_addtogridmap : tfreshgridadd=0
 rem Only affect overlays if FULL mode, not WALL or FLOOR modify
` if nogridsmart=-1 then gosub _gridedit_removeallolays
 if nogridsmart=-1 then deleteolaymode=1 : gosub _gridedit_deleteolay_map
else
 gosub _gridedit_addolay_map
endif

rem Stamp paint into undoredo buffer
tmapid=map(layer,mx,my)
tx=mx : ty=my : tlayer=layer
inputsys.undoredoevent=1 : gridevent=inputsys.undoredoevent : gosub _editor_undoredoadd

rem update neighbor tiles if in auto-mode
if segmentprofile(gridselection).vis.overlay=0
 upx=mx : upy=my : uplayer=layer : gosub _gridedit_updatetile
endif

rem add any entities belonging to this placed segment
seg=gridselection : gridaddtobufferref=0
gosub _gridedit_addsegmententities

rem refresh shroud
shroudrefresh=1

return

_gridedit_erasesingletile:

rem remove tile from map
if segmentprofile(gridselection).vis.overlay=0
 gosub _gridedit_deletefromgridmap
 rem Only affect overlays if FULL mode, not WALL or FLOOR modify
` if nogridsmart=-1 then gosub _gridedit_removeallolays
 if nogridsmart=-1 then deleteolaymode=1 : gosub _gridedit_deleteolay_map
else
 deleteolaymode=0 : gosub _gridedit_deleteolay_map
endif

rem Stamp delete into undoredo buffer
tx=mx : ty=my : tlayer=layer
tmapid=0 : inputsys.undoredoevent=1 : gridevent=inputsys.undoredoevent : gosub _editor_undoredoadd

rem update neighbor tiles if in auto-mode
if segmentprofile(gridselection).vis.overlay=0
 addremovenotadd=1
 upx=mx : upy=my : uplayer=gridlayer : gosub _gridedit_updatetile
 addremovenotadd=0
endif

rem refresh shroud
shroudrefresh=1

return

_gridedit_deleteclipboard:
 `
 rem delete buffer (clipboard)
 if bufferlayer<>-1
  if bufferholdscutdata=1
   for layer=0 to bufferlayer
    for my=0 to buffermaxy
     for mx=0 to buffermaxx
      rem if holds original ref data, must delete entities associated with it
      ptrbase=bufferrefmap(layer,mx,my)
      gosub _gridedit_deleteallentitiesontile
      rem also delete overlays perminantly (from buffer)
      olayindex=buffermapolay(layer,mx,my)
      gosub _gridedit_removeallolays_olayindex
     next mx
    next my
   next layer
  endif
  gosub _gridedit_deletebuffermesh
  bufferlayer=-1
 endif
 `
return

_gridedit_hideclipboard:
 if bufferlayer<>-1
  if mastermeshmax>0
   for m=1 to mastermeshmax
    for s=0 to mastermeshsets
     if mastermesh(m,s).buffer=1
      obj=mastermesh(m,s).obj
      mastermesh(m,s).buffer=-1
      if object exist(obj)=1 then hide object obj
     endif
    next s
   next m
  endif
 endif
return

_gridedit_showclipboard:
 if bufferlayer<>-1
  if mastermeshmax>0
   for m=1 to mastermeshmax
    for s=0 to mastermeshsets
     if mastermesh(m,s).buffer=1
      obj=mastermesh(m,s).obj
      mastermesh(m,s).buffer=-1
      if object exist(obj)=1 then show object obj
     endif
    next s
   next m
  endif
 endif
return

_gridedit_showtobjlegend:
 if tobj>0
  if object exist(tobj)>0
   if taddstaticlegend=1
    if gmultiplayergame=1 and entityprofile(ttentid).ismarker=1
     rem multiplayer arena mode - start marker
     tname$=tname$+" "+strarr$(621)
    else
     rem static
     tname$=tname$+" "+strarr$(608)
    endif
   else
    rem dynamic
    if gmultiplayergame=1
     rem multiplayer arena mode
     if entityprofile(ttentid).ischaracter=1
      rem any character
      tname$=tname$+" "+strarr$(620)
     else
      tname$=tname$+" "+strarr$(609)
     endif
    else
     tname$=tname$+" "+strarr$(609)
    endif
   endif
   dwbkcol as dword : dwbkcol=128<<24 : ink dwbkcol,dwbkcol
   box object screen x(tobj)-text width(tname$)/1.8,object screen y(tobj)+16,object screen x(tobj)+text width(tname$)/1.8,object screen y(tobj)+26+8,dwbkcol,dwbkcol,dwbkcol,dwbkcol
   ink rgb(255,255,0),0
   center text object screen x(tobj),object screen y(tobj)+16,tname$
  endif
 endif
return

_gridedit_mapediting:

rem Only if within map
if inputsys.mmx>=0 and inputsys.mmy>=0 and inputsys.mmx<maxx and inputsys.mmy<maxy
 `
 rem Any click inside 3D area constitues some sort of edit
 if inputsys.mclick<>0 then projectmodified=1 : gosub _gridedit_changemodifiedflag
 `
 rem PAINT MAP Handling
 if grideditselect=0 and segidmaster>0
  if inputsys.dopickmapid>0
   `
   rem pick tile from map
   if inputsys.mclick=1 and inputsys.dopickmapid=1
    layer=gridlayer : mx=inputsys.mmx : my=inputsys.mmy
    mapid=map(layer,mx,my)
    if mapid<>0
     gosub _gridedit_getmapvalues
     gridselection=mapselection
     gridscaler=mapscaler
     gridground=mapground
     gridorient=maporient
     gridkindof=segmentprofile(mapselection).properties.kindof
    endif
    rem set cursor and deactivate pick
    inputsys.dopickmapid=2 : gosub _editor_refresheditmarkers
   endif
   if inputsys.mclick<>1 and inputsys.dopickmapid=2 then inputsys.dopickmapid=0
   `
  else
   if inputsys.mclick=1
    `
    rem Version Control - stop high resource use
    resourceused=1 : gosub _version_resourcewarning
    `
    rem paint tile to map
    layer=gridlayer : mx=inputsys.mmx : my=inputsys.mmy
    gosub _gridedit_drawsingletile
    `
   endif
   if inputsys.mclick=2
    `
    rem remove tile from map
    layer=gridlayer : mx=inputsys.mmx : my=inputsys.mmy
    gosub _gridedit_erasesingletile
    `
   endif
  endif
 endif
 `
 rem Functionality to select an area of the map
 tselectareaofmap=0
 if grideditselect=1 and bufferlayer=-1 then tselectareaofmap=1
 if gridentitytriggerareaselect=1 then tselectareaofmap=2
 `
 rem Select an area of the map
 if tselectareaofmap>0
  if inputsys.mclick=1
   if selstage=0
    sel1mmx=inputsys.mmx : sel1mmy=inputsys.mmy : sel1layer=gridlayer
    show object 3 : show object 4
    showselectboundbox=1
    selstage=1
   endif
   if selstage=1
    sel2mmx=inputsys.mmx : sel2mmy=inputsys.mmy : sel2layer=gridlayer
   endif
   if sel2mmx<sel1mmx then sel1mmx=sel2mmx
   if sel2mmy<sel1mmy then sel1mmy=sel2mmy
   if sel2layer<sel1layer then sel1layer=sel2layer
  endif
  if inputsys.mclick=0
   selstage=0 : gosub _editor_cutcopyclearstate
  endif
 endif
 `
 rem CUT/COPY/PASTE/FLOORONOFF MAP Handling
 if grideditselect=1
  if bufferlayer=-1
   `
   rem cut/copy function
   if inputsys.tselcontrol=1 and selstage<2
    `
    rem copy into buffer
    if inputsys.tselcopy=1
     gosub _gridedit_deletebuffermesh
     bufferholdscutdata=0
     bufferrotationcount=0
     bufferlayer=(sel2layer-sel1layer)
     buffermaxx=(sel2mmx-sel1mmx)
     buffermaxy=(sel2mmy-sel1mmy)
     dim buffermap(bufferlayer+1,buffermaxx+1,buffermaxy+1)
     dim bufferrefmap(bufferlayer+1,buffermaxx+1,buffermaxy+1)
     dim buffermapolay(bufferlayer+1,buffermaxx+1,buffermaxy+1)
     for layer=0 to bufferlayer
      for my=0 to buffermaxy
       for mx=0 to buffermaxx
        buffermap(layer,mx,my)=map(sel1layer+layer,sel1mmx+mx,sel1mmy+my)
        bufferrefmap(layer,mx,my)=refmap(sel1layer+layer,sel1mmx+mx,sel1mmy+my)
        buffermapolay(layer,mx,my)=mapolay(sel1layer+layer,sel1mmx+mx,sel1mmy+my)
       next mx
      next my
     next layer
     `
     rem done
     selstage=2
     `
     rem update menu items
     gosub _editor_cutcopyclearstate
     `
    endif
    `
    rem cut from map
    if inputsys.tselcut=1
     `
     rem flag that cut has been used (entity copy control)
     bufferholdscutdata=1
     `
     rem blank out map data
     for layer=0 to bufferlayer
      for my=0 to buffermaxy
       for mx=0 to buffermaxx
        `
        rem Remove tile
        tbuffer=0 : tlayer=sel1layer+layer  : tx=sel1mmx+mx : ty=sel1mmy+my
        wasmapid=map(tlayer,tx,ty)
        gosub _gridedit_removetile
        map(tlayer,tx,ty)=0
        `
        rem Remove entity
        if refmap(tlayer,tx,ty)>0
         gosub _gridedit_removeentity
         refmap(tlayer,tx,ty)=0
        endif
        `
        rem Blank overlays (original data stored in buffer now - deleted later via bufferholdscutdata)
        if mapolay(tlayer,tx,ty)>0
         mapolay(tlayer,tx,ty)=0
        endif
        `
        rem Stamp delete into undoredo buffer
        tmapid=0 : inputsys.undoredoevent=1 : gridevent=inputsys.undoredoevent : gosub _editor_undoredoadd
        `
       next mx
      next my
     next layer
     `
     rem Update map area
     for ulayer=0 to bufferlayer
      for umy=0 to buffermaxy
       for umx=0 to buffermaxx
        upx=sel1mmx+umx : upy=sel1mmy+umy : uplayer=sel1layer+ulayer : gosub _gridedit_updatetile
       next umx
      next umy
     next ulayer
     `
     rem done
     selstage=2
     `
    endif
    `
    rem end selection and refresh
    if selstage=2
     `
     rem create mesh from buffer data
     gosub _gridedit_createbuffermesh
     shroudrefresh=1
     `
     rem switch to starting layer (for editing convenience)
     if sel1layer<>sel2layer then gridlayer=sel1layer
     `
    endif
    `
   rem cut/copy function endif
   endif
   `
   rem selection control
   if selstage=2
    hide object 3 : hide object 4
    showselectboundbox=0
    selstage=0
   endif
   `
  endif
  if bufferlayer<>-1
   if inputsys.mmx>=0 and inputsys.mmy>=0 and inputsys.mmx+buffermaxx<maxx and inputsys.mmy+buffermaxy<maxy
    `
    rem mouse can also paste and delete
    if inputsys.mclick=1 then inputsys.tselpaste=1
    if inputsys.mclick=2 then inputsys.tselwipe=1
    `
    rem paste clipboard
    if inputsys.tselpaste=1
     `
     rem Copy buffer to map
     tbuffer=0
     for layer=0 to bufferlayer
      for my=0 to buffermaxy
       for mx=0 to buffermaxx
        rem TILE
        tmapid=buffermap(layer,mx,my)
        if tmapid<>0
         tlayer=gridlayer+layer  : tx=inputsys.mmx+mx : ty=inputsys.mmy+my
         if tlayer<=layermax
          `
          rem Add tile to blue-mesh
          wasmapid=map(tlayer,tx,ty)
          map(tlayer,tx,ty)=tmapid
          gosub _gridedit_removetile
          if tmapid<>0 then gosub _gridedit_addtile
          `
          rem Stamp add into undoredo buffer
          inputsys.undoredoevent=1 : gridevent=inputsys.undoredoevent : gosub _editor_undoredoadd
          `
         endif
        endif
        rem ENTITIY REFS
        refptrbase=bufferrefmap(layer,mx,my)
        if refptrbase<>0
         tlayer=gridlayer+layer  : tx=inputsys.mmx+mx : ty=inputsys.mmy+my
         if tlayer<=layermax
          `
          rem Add entity (first removing old entities on the tile)
          ptrbase=refmap(tlayer,tx,ty)
          if ptrbase>0
           `
           rem must delete any entity that are on this tile
           gosub _gridedit_deleteallentitiesontile
           gosub _gridedit_removeentity
           refmap(tlayer,tx,ty)=0
           `
          endif
          refptrbase=bufferrefmap(layer,mx,my)
          if refptrbase>0
           `
           rem go through each entity in mapref
           reftmax=*refptrbase : refptr=refptrbase+4
           for reftp=1 to reftmax
            `
            rem for each tile
            tlayer=gridlayer+layer  : tx=inputsys.mmx+mx : ty=inputsys.mmy+my
            `
            rem get original entity data
            e=*refptr
            adjx#=entityelement(e).x-(int(entityelement(e).x/100.0)*100)
            adjy#=entityelement(e).y-(int(entityelement(e).y/100.0)*100)
            adjz#=entityelement(e).z-(int(entityelement(e).z/100.0)*100)
            adjrx#=0.0
            adjry#=bufferrotationcount*90.0
            adjrz#=0.0
            `
            rem adjust offsets based on rotation
            if bufferrotationcount=1
             stadjx#=adjx# : adjx#=100.0-(adjz#*-1.0) : adjz#=stadjx#*-1.0
            endif
            if bufferrotationcount=2
             adjx#=100.0-adjx# : adjz#=-100.0-adjz#
            endif
            if bufferrotationcount=3
             stadjx#=adjx# : adjx#=adjz#*-1.0 : adjz#=-100.0+stadjx#
            endif
            `
            rem copied selection must be duplicate entity data
            gridentityeditorfixed=entityelement(e).editorfixed
            gridentity=entityelement(e).bankindex
            gridentityposx#=(tx*100)+adjx#
            gridentityposz#=(ty*-100)+adjz#
            gridentityposy#=(tlayer*100)+adjy#
            gridentityrotatex#=entityelement(e).rx+adjrx#
            gridentityrotatey#=entityelement(e).ry+adjry#
            gridentityrotatez#=entityelement(e).rz+adjrz#
            grideleprof=entityelement(e).eleprof
            `
            rem uses layer,mx,my so store values
            storelayer=layer : storemx=mx : storemy=my
            layer=tlayer : mx=tx : my=ty
            gosub _gridedit_addentitytomap
            layer=storelayer : mx=storemx : my=storemy
            gridentity=0
            `
            inc refptr,4
            `
           next reftp
           `
          endif
          `
         endif
        endif
        rem MAP OVERLAYS (add to map as new overlays)
        tolayindex=buffermapolay(layer,mx,my)
        if tolayindex>0
         rem go through overlays and add same to this area of map
         for ti=0 to 50
          buffermapid=olaylist(tolayindex,ti)
          if buffermapid>0
           storelayer=layer : storemx=mx : storemy=my
           tlayer=gridlayer+layer  : tx=inputsys.mmx+mx : ty=inputsys.mmy+my
           layer=tlayer : mx=tx : my=ty
           gosub _gridedit_addolay_map
           layer=storelayer : mx=storemx : my=storemy
           buffermapid=0
          else
           exit
          endif
         next ti
        endif
       next mx
      next my
     next layer
     `
     rem Update shroud after paste
     shroudrefresh=1 : gosub _gridedit_updatelayershades
     `
    endif
    `
    rem wipe out map covered by clipbboard selection
    if inputsys.tselwipe=1
     `
     rem Wipe map of selection-area size
     tbuffer=0
     for layer=0 to bufferlayer
      for my=0 to buffermaxy
       for mx=0 to buffermaxx
        tmapid=buffermap(layer,mx,my)
        if tmapid<>0
         tlayer=gridlayer+layer  : tx=inputsys.mmx+mx : ty=inputsys.mmy+my
         if tlayer<=layermax
          rem remove tile
          wasmapid=map(tlayer,tx,ty)
          map(tlayer,tx,ty)=0
          gosub _gridedit_removetile
          rem remove overlays perminantly
          storelayer=layer : storemx=mx : storemy=my
          layer=tlayer : mx=tx : my=ty
`          gosub _gridedit_removeallolays `this was done before remove-no-touch-ents
          rem in all direction ( ie deleteolaymode=1 )
          deleteolaymode=1 : gosub _gridedit_deleteolay_map
          layer=storelayer : mx=storemx : my=storemy
          rem Stamp add into undoredo buffer
          inputsys.undoredoevent=1 : gridevent=inputsys.undoredoevent : gosub _editor_undoredoadd
         endif
        endif
       next mx
      next my
     next layer
     `
     rem Update map area
     for ulayer=0 to bufferlayer
      for umy=0 to buffermaxy
       for umx=0 to buffermaxx
        uplayer=gridlayer+ulayer
        if uplayer<=layermax
         upx=inputsys.mmx+umx : upy=inputsys.mmy+umy : gosub _gridedit_updatetile
        endif
       next umx
      next umy
     next ulayer
     `
     rem Update shroud after paste
     shroudrefresh=1 : gosub _gridedit_updatelayershades
     `
    endif
    `
   endif
  endif
 endif
 `
 rem must be able to remove clipboard contents (if switch modes)
 if grideditselect<>1 and bufferlayer<>-1 then inputsys.tseldelete=1
 if inputsys.tseldelete=1
  rem delete clipboard
  gosub _gridedit_deleteclipboard
  rem update menu items
  gosub _editor_cutcopyclearstate
 endif
 `
 rem ART SHAPE Handling
 if grideditselect=2
  `
  rem select area for shape
  if inputsys.mclick>0
   if selstage=0
    if inputsys.mclick=1 then selstagemode=1
    if inputsys.mclick=2 then selstagemode=2
    sel1mmx=inputsys.mmx : sel1mmy=inputsys.mmy : sel1layer=gridlayer
    selstage=1
   endif
   if selstage=1
    sel2mmx=inputsys.mmx : sel2mmy=inputsys.mmy : sel2layer=gridlayer
    if inputsys.kscancode=42 or inputsys.kscancode=54
     sel2mmy=sel1mmy+(inputsys.mmx-sel1mmx)
    endif
   endif
  endif
  if inputsys.mclick=0 and selstage=1 and (sel1mmx<>sel2mmx or sel1mmy<>sel2mmy)
   selstage=2
  endif
  `
  rem show shape area
  tobj=editormarkeroffset
  `
  rem init art shape
  if grideditartmode=1
   rem line
   dx#=sel2mmx-sel1mmx : dy#=sel2mmy-sel1mmy
   if abs(dx#)>abs(dy#)
    l1=sel1mmx : l2=sel2mmx : ll#=sel1mmy
   else
    l1=sel1mmy : l2=sel2mmy : ll#=sel1mmx
   endif
   ll=l1
  endif
  if grideditartmode=2
   rem box
   llx=sel1mmx-1 : lly=sel1mmy
  endif
  if grideditartmode=3
   rem circle
   dx#=sel2mmx-sel1mmx : dy#=sel2mmy-sel1mmy
   ll=0 : l1=2 : l2=-1
  endif
  if grideditartmode=4
   rem spray
   ll=2 : selstage=2 : rem autorelease
  endif
  `
  rem range from width
  if grideditartmode=4
   tgrideditartwidthx=1 : tgrideditartwidthy=1
  else
   tgrideditartwidthx=grideditartwidthx : tgrideditartwidthy=grideditartwidthy
  endif
  `
  rem art preview/draw loop
  llokay=1
  while llokay=1
   `
   rem validatehighlight ensures outline, not complete fill
   tvalidatehighlight=1
   `
   rem calculate coords
   if grideditartmode=1
    rem line
    if abs(dx#)>abs(dy#)
     llx=ll : lly=ll# : if l1<l2 then ll#=ll#+(dy#/dx#) else ll#=ll#-(dy#/dx#)
    else
     llx=ll# : lly=ll : if l1<l2 then ll#=ll#+(dx#/dy#) else ll#=ll#-(dx#/dy#)
    endif
    if l1<l2
     ll=ll+1 : if ll>l2+1 then llokay=0
    else
     ll=ll-1 : if ll<l2-1 then llokay=0
    endif
   endif
   if grideditartmode=2
    rem box
    inc llx
    if llx>sel2mmx
     llx=sel1mmx : inc lly
     if lly>sel2mmy then llokay=0
    endif
    rem validate for outline
    if llx>sel1mmx and llx<sel2mmx and lly>sel1mmy and lly<sel2mmy
     tvalidatehighlight=0
    endif
   endif
   if grideditartmode=3
    rem validate for outline
    tvalidatehighlight=0
    rem circle
    if l1=2
     llx=sel1mmx+(((cos(ll-1)*dx#))+0.5) : l1=0
    endif
    if l1=0
     oldllx=llx
     repeat
      llx=sel1mmx+(((cos(ll)*dx#))+0.5) : lly=sel1mmy+(((sin(ll)*dy#))+0.5)
      inc ll,1
     until oldllx<>llx or ll>180
     if ll>180 then llokay=0
     llx=sel1mmx+(((cos(ll-1)*dx#))+0.5) : l1=1
     tvalidatehighlight=1
    else
     if l1=1
      dec lly
      if lly<=sel1mmy-(((sin(ll)*dy#))+0.5)
       l1=2
       tvalidatehighlight=1
      endif
     endif
    endif
   endif
   if grideditartmode=4
    rem spray
    dd#=rnd(100)/100.0 : rr=rnd(359)
    llx=(sel1mmx+(cos(rr)*(grideditartwidth*dd#)))+0.5
    lly=(sel1mmy+(sin(rr)*(grideditartwidth*dd#)))+0.5
    dec ll : if ll<=0 then llokay=0
   endif
   `
   rem place art object(s)
   if llokay=1
    `
    rem control width of art draw
    for twidthy=0 to tgrideditartwidthy-1
     for twidthx=0 to tgrideditartwidthx-1
      `
      if tvalidatehighlight=1
       if selstage>0 and grideditartmode<>4
        if tobj<=editormarkeroffsetmax
         position object tobj,((llx+twidthx)*100)+50,(sel1layer*100)+50,((lly+twidthy)*-100)-50
         scroll object texture tobj,0.03,0.0 : show object tobj
         inc tobj
        endif
       endif
      endif
      `
      rem draw at location if flagged
      if selstage=2
       if selstagemode=1
        rem paint tile to map
        layer=gridlayer : mx=llx+twidthx : my=lly+twidthy
        if mx>=0 and my>=0 and mx<maxx and my<maxy
         gosub _gridedit_drawsingletile
        endif
       endif
       if selstagemode=2
        rem remove tile from map
        layer=gridlayer : mx=llx+twidthx : my=lly+twidthy
        if mx>=0 and my>=0 and mx<maxx and my<maxy
         gosub _gridedit_erasesingletile
        endif
       endif
      endif
      `
     next twidthx
    next twidthy
    `
   endif
   `
  endwhile
  `
  rem Hide unused art objects
  editormarkeroffsethidefrom=tobj
  while tobj<=editormarkeroffsetmax
   hide object tobj : inc tobj
  endwhile
  `
  rem end draw phase
  if selstage=2
   selstage=0 : selstagemode=0
  endif
  `
 endif
 `
 rem ENTITY EDIT Handling (can use select area objects 3&4)
 sustainselectareafortrigger=0
 if grideditselect=5
  layer=gridlayer : mx=inputsys.mmx : my=inputsys.mmy
  if selstage=0
   `
   rem single entity highlight
   tshow=0 : showentityid=0 : tforcegrid=0 : tforcedynamic=0 : tentitytoselect=0
   if gridentity=0
    tentitytoselect=findentitycursorobj()
    if tentitytoselect>0
     position object 5,entityelement(tentitytoselect).x,entityelement(tentitytoselect).y,entityelement(tentitytoselect).z
     showentityid=entityelement(tentitytoselect).bankindex
     if entityprofile(showentityid).ismarker=3
      if gridentitytriggerareaselect=0
       rem Update area coords when not selecting new coords
       sel1mmx=entityelement(tentitytoselect).x/100
       sel1mmy=entityelement(tentitytoselect).z/-100
       sel1layer=entityelement(tentitytoselect).y/100
       sel2mmx=sel1mmx+entityelement(tentitytoselect).eleprof.trigger.areax2
       sel2layer=sel1layer+entityelement(tentitytoselect).eleprof.trigger.areay2
       sel2mmy=sel1mmy+entityelement(tentitytoselect).eleprof.trigger.areaz2
       sel1mmx=sel1mmx+entityelement(tentitytoselect).eleprof.trigger.areax1
       sel1layer=sel1layer+entityelement(tentitytoselect).eleprof.trigger.areay1
       sel1mmy=sel1mmy+entityelement(tentitytoselect).eleprof.trigger.areaz1
      endif
      tscale#=100
     else
      if entityprofile(showentityid).ismarker=2
       tscale#=(100/3.0)*2*(entityelement(tentitytoselect).eleprof.light.range/50.0)
      else
       tscale#=object size(entityelement(tentitytoselect).obj)*3.0
      endif
     endif
     scale object 5,tscale#,tscale#,tscale#
     tshow=1+entityelement(tentitytoselect).staticflag
    endif
   else
    position object 5,gridentityposx#,gridentityposy#,gridentityposz#
    if object exist(entitybankoffset+gridentity)=1
     if entityprofile(gridentity).ismarker=3
      if gridentitytriggerareaselect=0
       rem Update area coords when not selecting new coords
       sel1mmx=gridentityposx#/100
       sel1mmy=gridentityposz#/-100
       sel1layer=gridentityposy#/100
       sel2mmx=sel1mmx+grideleprof.trigger.areax2
       sel2layer=sel1layer+grideleprof.trigger.areay2
       sel2mmy=sel1mmy+grideleprof.trigger.areaz2
       sel1mmx=sel1mmx+grideleprof.trigger.areax1
       sel1layer=sel1layer+grideleprof.trigger.areay1
       sel1mmy=sel1mmy+grideleprof.trigger.areaz1
      endif
      tscale#=100
     else
      if entityprofile(gridentity).ismarker=2
       tscale#=(100/3.0)*2*(grideleprof.light.range/50.0)
      else
       tscale#=object size(entitybankoffset+gridentity)*3.0
      endif
     endif
     scale object 5,tscale#,tscale#,tscale#
    endif
    tshow=1+gridentitystaticmode
    showentityid=gridentity
   endif
   if tshow>0 and inputsys.activemouse=1
    if entityprofile(showentityid).ismarker=1 then tforcedynamic=1
    if entityprofile(showentityid).ismarker=4 then tforcedynamic=1
    if entityprofile(showentityid).ismarker=3
     rem trigger area
     show object 3 : show object 4 : hide object 5
     sustainselectareafortrigger=1
     showselectboundbox=1
     tforcegrid=1
     tforcedynamic=1
    else
     hide object 3 : hide object 4 : show object 5
     if entityprofile(showentityid).ismarker=2
      rem light range visual
      texture object 5,editorimagesoffset+18
      yrotate object 5,0
      if tshow=2
       modifyplaneimagestrip(5,2,0)
      else
       modifyplaneimagestrip(5,2,1)
      endif
     else
      if entityprofile(showentityid).forwardfacing=1
       rem coloured circle blob with arrow
       texture object 5,editorimagesoffset+26
       yrotate object 5,gridentityrotatey#
      else
       rem coloured circle blob
       texture object 5,editorimagesoffset+7
       yrotate object 5,0
      endif
      if tshow=2
       modifyplaneimagestrip(5,8,1)
      else
       if gmultiplayergame=0
        modifyplaneimagestrip(5,8,3)
       else
        if entityprofile(showentityid).isammo<>0 or entityprofile(showentityid).isweapon<>0 or entityprofile(showentityid).ischaracter<>0 or entityprofile(showentityid).ishealth<>0
         modifyplaneimagestrip(5,8,3)
        else
         modifyplaneimagestrip(5,8,1)
        endif
       endif
      endif
     endif
     show object 5
    endif
    rem show legend of entity hovering over (and static legend)
    taddstaticlegend=0
    if tentitytoselect>0
     tstatic=entityelement(tentitytoselect).staticflag
     tentid=entityelement(tentitytoselect).bankindex
    else
     tstatic=gridentitystaticmode
     tentid=gridentity
    endif
    if gmultiplayergame=0
     if tstatic=1
      taddstaticlegend=1
     else
      taddstaticlegend=0
     endif
    else
     if tstatic=1
      taddstaticlegend=1
     else
      if entityprofile(tentid).isammo<>0 or entityprofile(tentid).isweapon<>0 or entityprofile(tentid).ischaracter<>0 or entityprofile(tentid).ishealth<>0
       taddstaticlegend=0
      else
       taddstaticlegend=1
      endif
     endif
    endif
    if tentitytoselect>0
     tobj=entityelement(tentitytoselect).obj
     tname$=entityelement(tentitytoselect).eleprof.name$
     ttentid=entityelement(tentitytoselect).bankindex
     gosub _gridedit_showtobjlegend
    else
     tobj=gridentityobj : tname$=grideleprof.name$
     ttentid=gridentity
     gosub _gridedit_showtobjlegend
    endif
   else
    hide object 5
   endif
   `
   rem Special Entity Edit Mode
   if gridentitytriggerareaselect=1
    `
    rem When placing trigger, SHIFT will allow the area to be specified
    rem SEL1Xetc are set elswhere (shared with segment area selection)
    selXmmx=gridentityposx#/100
    selXlayer=gridentityposy#/100
    selXmmy=gridentityposz#/-100
    grideleprof.trigger.areax1=sel1mmx-selXmmx
    grideleprof.trigger.areay1=sel1layer-selXlayer
    grideleprof.trigger.areaz1=sel1mmy-selXmmy
    grideleprof.trigger.areax2=sel2mmx-selXmmx
    grideleprof.trigger.areay2=sel2layer-selXlayer
    grideleprof.trigger.areaz2=sel2mmy-selXmmy
    `
   else
    `
    rem entity placement update
    gridentityposx#=inputsys.localx#
    gridentityposz#=inputsys.localy#
    `
    rem grid system for entities
    if gridentitygridlock=1
     gridentityposx#=(int(gridentityposx#/5)*5)
     gridentityposz#=(int(gridentityposz#/5)*5)
    endif
    if gridentitygridlock=2 or tforcegrid=1
     gridentityposx#=50+(int(gridentityposx#/100)*100)
     gridentityposz#=(int(gridentityposz#/100)*100)-50
    endif
    if tforcedynamic=1
     gridentitystaticmode=0
    endif
    `
    rem control modification of entity element details
    if gridentitymodifyelement=1
     if grideleprof.light.range>50 then grideleprof.light.range=grideleprof.light.range-50
     gridentitymodifyelement=0
    endif
    if gridentitymodifyelement=2
     if grideleprof.light.range<1000 then grideleprof.light.range=grideleprof.light.range+50
     gridentitymodifyelement=0
    endif
    `
    rem single entity select/deselect
    if inputsys.mclick=1
     if gridentity<>0
      `
      rem Version Control - stop high resource use
      resourceused=2 : gosub _version_resourcewarning
      `
      rem only if in editing area
      if gridentityposx#>=0 and gridentityposy#>=0 and gridentityposz#<=0 and gridentityposx#<(maxx*100.0) and gridentityposy#<(20*100.0) and gridentityposz#>(maxy*-100.0)
       `
       rem after add, adjust so it auto-finds a floor or wall (convenience)
       gridentitydroptoground=1+entityprofile(gridentity).forwardfacing
       if gridentitydroptoground=2
        rem not too convenient for floors, but wall furniture look okay!!
        gosub _editor_findentityground
       endif
       gridentitydroptoground=0
       `
       rem find unique name for this selection (if flagged)
       if guseuniquelynamedentities=0
        rem use same name as original entity
        tbase$=grideleprof.name$
       else
        tokay=0 : tindex=1
        if lower$(left$(grideleprof.name$,len(grideleproflastname$)))=lower$(grideleproflastname$)
         tbase$=grideleproflastname$
        else
         tbase$=grideleprof.name$
        endif
        while tokay=0
         tokay=1 : grideleprof.name$=tbase$ : grideleproflastname$=tbase$
         if tindex>1 then grideleprof.name$=grideleprof.name$+" "+str$(tindex)
         for e=1 to entityelementlist
          if entityelement(e).bankindex>0
           if lower$(entityelement(e).eleprof.name$)=lower$(grideleprof.name$)
            rem this name exists already, try another
            tokay=0 : exit
           endif
          endif
         next e
         inc tindex
        endwhile
       endif
       rem player start markers have exclusivity
       if entityprofile(gridentity).ismarker=1 and entityprofile(gridentity).lives>0
        for e=1 to entityelementlist
         if entityelement(e).bankindex>0
          if entityprofile(entityelement(e).bankindex).ismarker=1 and entityprofile(entityelement(e).bankindex).lives>0
           tentitytoselect=e
           gosub _gridedit_deleteentityfrommap
          endif
         endif
        next e
       endif
       rem copy entity to map (keep selection for repeat process)
       gosub _gridedit_addentitytomap
       rem update for refresh
       shroudrefresh=1
       selstage=1
      endif
      `
     else
      rem extract entity from the map
      if tentitytoselect>0
       if entityelement(tentitytoselect).editorfixed=0
        gridentitystaticmode=entityelement(tentitytoselect).staticflag
        gridentityeditorfixed=entityelement(tentitytoselect).editorfixed
        gridentity=entityelement(tentitytoselect).bankindex
        gridentityposx#=entityelement(tentitytoselect).x
        gridentityposy#=entityelement(tentitytoselect).y
        gridentityposz#=entityelement(tentitytoselect).z
        gridentityrotatex#=entityelement(tentitytoselect).rx
        gridentityrotatey#=entityelement(tentitytoselect).ry
        gridentityrotatez#=entityelement(tentitytoselect).rz
        grideleprof=entityelement(tentitytoselect).eleprof
        grideleproflastname$=grideleprof.name$
        gosub _gridedit_deleteentityfrommap
        shroudrefresh=1
        `
        rem if entity fom other layer, change relative position of entity Y
        rem and we have a buffer of 25 units above and belo the current edit layer
        if gridentityposy#>(gridlayer*100)-25.0 and gridentityposy#<(gridlayer*100)+125.0
         rem leave entity Y position alone!
        else
         rem change the entity Y position
         tmp=gridentityposy#/100 : tmpy#=gridentityposy#-(tmp*100)
         gridentityposy#=(gridlayer*100)+tmpy#
        endif
        `
       endif
      endif
     endif
     selstage=1
    endif
    `
   endif
   `
   rem zoom into entity properties
   if inputsys.mclick=2 or inputsys.kscancode=211
    if gridentity<>0
     rem delete specified entity if RMB
     gridentitydelete=1
     selstage=1
    else
     if tentitytoselect>0
       `
       rem prepare zoom-in adjustment vars
       e=tentitytoselect
       gridentityinzoomview=e
       zoomviewtargetx#=entityelement(e).x
       zoomviewtargety#=entityelement(e).y
       zoomviewtargetz#=entityelement(e).z
       zoomviewtargetrx#=entityelement(e).rx
       zoomviewtargetry#=entityelement(e).ry
       zoomviewtargetrz#=entityelement(e).rz
       zoomviewcameraangle#=inputsys.xmousemove : zoomviewcameraangle#=0.0
       zoomviewcameraheight#=inputsys.ymousemove : zoomviewcameraheight#=125.0
       zoomviewcamerarange#=75.0
       `
       rem extract entity from the map
       gridentityeditorfixed=entityelement(e).editorfixed
       gridentitystaticmode=entityelement(e).staticflag
       gridentity=entityelement(e).bankindex
       gridentityposx#=entityelement(e).x
       gridentityposy#=entityelement(e).y
       gridentityposz#=entityelement(e).z
       gridentityrotatex#=entityelement(e).rx
       gridentityrotatey#=entityelement(e).ry
       gridentityrotatez#=entityelement(e).rz
       grideleprof=entityelement(e).eleprof
       gosub _gridedit_deleteentityfrommap
       shroudrefresh=1
       `
       rem zoom in to entity for fine detail
       cx#=entityelement(e).x
       cy#=entityelement(e).z*-1.0
       inputsys.doautozoomview=1
       hide object 5
       selstage=1
       `
       rem disable icons that interfere with zoom mode
       gosub _editor_disableforzoom
       `
       rem prepare entity property handler
       gosub _interface_openpropertywindow
       `
     endif
    endif
   endif
   `
   rem gridentity delete
   if gridentitydelete=1
    gridentitydelete=0
    if gridentityobj=0
     delete object gridentityobj
     gridentityobj=0
    endif
    shroudrefresh=1
    gridentity=0
   endif
   `
  endif
  if inputsys.mclick=0 and selstage=1
   selstage=0
  endif
 endif
 if sustainselectareafortrigger=0 and grideditselect<>1
  if showselectboundbox=1 and gridentitytriggerareaselect=0
   hide object 3 : hide object 4
   showselectboundbox=0
  endif
 endif
 `
 rem Select Bound Box 'Stripy Block Highlighter'
 if showselectboundbox=1
  if twid>0 then scale object texture 3,1.0/(twid/25),1.0/(tdep/25)
  twid=((sel2mmx-sel1mmx)+1)*100
  thig=((sel2layer-sel1layer)+1)*100
  tdep=((sel2mmy-sel1mmy)+1)*100
  scale object 3,twid,thig,tdep
  position object 3,(sel1mmx*100)+(twid/2),(thig/2)+(sel1layer*100),(sel1mmy*-100)-(tdep/2)
  scale object texture 3,twid/25,tdep/25
  scroll object texture 3,0.03,0.0
  scale object 4,twid,thig,tdep
  position object 4,(sel1mmx*100)+(twid/2),(thig/2)+(sel1layer*100),(sel1mmy*-100)-(tdep/2)
 endif
 `
 rem end areaslect after range established and mouse released
 if gridentitytriggerareaselect=1
  if inputsys.mclick=0
   gridentitytriggerareaselect=0
  endif
 endif
 `
endif

return

_gridedit_save_test_map:

rem V104RC6 new to remove un-used segments
gosub _segment_shufflebank

rem Save map data locally only (not to FPM)
gosub _mapfile_savemap

rem Save segment bank
gosub _segment_savebank

rem Save entity elements
gosub _entity_savebank
gosub _entity_saveelementsdata

rem Save waypoints
gosub _waypoint_savedata

rem Save editor configuration
gosub _editor_savecfg

rem Set modification flag
projectmodified=0 : gosub _gridedit_changemodifiedflag

return

_gridedit_save_map:

rem Proper saving message to user
if recoverdonotuseany3dreferences=0
 gosub _editor_hideall3d
endif

rem Use large prompt
statusbar$=strarr$(365) : popup_text(statusbar$)

rem Save only to TESTMAP area (for map testing)
gosub _gridedit_save_test_map

rem Now store all part-files into main FPM project
gosub _mapfile_saveproject_fpm

rem Add Latest project To Recent List
gosub _gridedit_updateprojectname

rem Clear status text
statusbar$="" : popup_text_close()

rem FPSXV104RC6 - refresh as SAVE can remove entities and segments
if entityorsegmententrieschanged=1
 entityorsegmententrieschanged=0
 gosub _gridedit_load_map
endif

return

_gridedit_updatemapbeforeedit:

rem Completely reset filemap (and interface parts ie library)
gosub _editor_filemapinit

rem Clear refmap
undim refmap()
dim refmap(layermax,maxx,maxy)

rem Recreate arrays
mastermeshmax=0
mastermeshsize=1
mastermeshsets=1
currentmeshobject=101
dim mapentries(mastermeshsize,mastermeshsets,40,40) as mapentriestype
dim mastermesh(mastermeshsize,mastermeshsets) as mastermeshtype

rem Add all entity element to map
if entityelementlist>0
 for e=1 to entityelementlist
  if entityelement(e).bankindex>0
   addtobufferref=0 : gosub _gridedit_addentityreftomap
  endif
 next e
endif

rem Delete any segments that no longer exist(segment file moved/deleted)
for layer=0 to layermax
 for my=0 to maxy
  for mx=0 to maxx
   rem Delete any base segments
   mapid=map(layer,mx,my)
   gosub _gridedit_getmapvalues
   sourceobj=selectionbankoffset+mapselection
   if sourceobj>0
    if object exist(sourceobj)=0
     map(layer,mx,my)=0
    endif
   endif
   rem Delete any overlay segments
   olayindex=mapolay(layer,mx,my)
   if olayindex>0
    tiwrite=0
    for tiread=0 to 50
     mapid=olaylist(olayindex,tiread)
     if mapid<>0
      gosub _gridedit_getmapvalues
      sourceobj=selectionbankoffset+mapselection
      if sourceobj>0
       if object exist(sourceobj)=0 then mapid=0
      endif
     endif
     olaylist(olayindex,tiwrite)=mapid
     if mapid>0
      inc tiwrite
     else
      exit
     endif
    next tiread
   endif
   rem Also remove link if eaten ALL list
   if olaylist(olayindex,0)=0
    mapolay(layer,mx,my)=0
   endif
  next mx
 next my
next layer

rem Recreate new map
for layer=0 to layermax
 for my=0 to maxy
  for mx=0 to maxx
   rem setup current tile
   tbuffer=0 : tlayer=layer  : tx=mx : ty=my
   rem add any tile
   tmapid=map(layer,mx,my)
   if tmapid<>0 then gosub _gridedit_addtile
  next mx
 next my
next layer

rem Remove grid (so it is recreated larger if required)
if object exist(1)=1 then delete object 1

rem Newly loaded map starts at layer one
gridlayer=5 : shroudrefresh=1
gosub _gridedit_updatelayershades

return

_gridedit_clear_settings:

rem Default settings
gosub _gridedit_clear_configsettings
gridscale#=((800/2)/8)/gridzoom#
currentprojectfilename$=""
gridground=0
gridselection=1
bufferlayer=-1
gridlayershowsingle=0
grideditartwidth=1
grideditartwidthx=1
grideditartwidthy=1
locallibrarysegidmaster=0
locallibraryentidmaster=0

return

_gridedit_clear_configsettings:
 cx#=800*gridzoom# : cy#=600*gridzoom#
 gridzoom#=1.0
 nogridsmart=-1
 gridlayer=5
 shroudsize=5
 grideditartmode=1
 grideditselect=0
return

_gridedit_clear_map:

rem Destroy old objects
if mastermeshmax>0
 for m=1 to mastermeshmax
  for s=0 to mastermeshsets
   obj=mastermesh(m,s).obj
   if object exist(obj)=1 then delete object obj
  next s
 next m
endif

rem Destroy old data
undim mapentries()
undim mastermesh()

rem Set modification flag
projectmodified=0 : gosub _gridedit_changemodifiedflag

return

_gridedit_new_map:

rem No project - new map
projectfilename$="" : projectmodified=0 : lastprojectmodified=0
gosub _gridedit_updateprojectname

rem Load map data
gosub _editor_hideall3d
statusbar$=strarr$(366) : gosub _gridedit_updatestatusbar

rem Clear all settings
gosub _gridedit_clear_settings

rem Clear map first
gosub _gridedit_clear_map

rem Delete all assets of map work
gosub _segment_deletebank
gosub _entity_deletebank
gosub _entity_deleteelementsdata
gosub _waypoint_deleteall
gosub _mapfile_newmap

rem Load in 'floor segment' for horizon feature
segidmaster=1
selectionbank$(1)="common\ground.fps"
`
rem Localisation must find desc name of ground
tflocalfilename$="languagebank\"+language$+"\textfiles\library\segments\"+selectionbank$(1)
tflocalfilename$=left$(tflocalfilename$,len(tflocalfilename$)-4)+".loc"
if file exist(tflocalfilename$)=1
 dim tflocal$(1)
 load array tflocalfilename$,tflocal$()
 selectionbanklocal$(1)=tflocal$(0)
 undim tflocal$()
endif
`
rem load the segment in
if segidmaster>0
 segdir$="segments\"
 for segid=1 to segidmaster
  seg$=selectionbank$(segid)
  segcategory$=getfirstdir(seg$)
  segpath$=getseconddir(seg$)
  gosub _segment_load
 next segid
endif

rem Update remaining map data before editing
gosub _gridedit_updatemapbeforeedit

rem Some default setup for new scene (load markers)
gosub _editor_filemapdefaultinitfornew

rem Reset cursor
grideditselect=0 : gosub _editor_refresheditmarkers

rem Clear status text
statusbar$="" : gosub _gridedit_updatestatusbar

return

_gridedit_updatestatusbar:
 if statusbar$<>laststatusbar$
  open file map 1,"FPSEXCHANGE"
  set file map string$ 1, 4000, statusbar$
  wait for file map event 1
  close file map 1
  laststatusbar$=statusbar$
 endif
return

_gridedit_load_map:

rem Load map data
gosub _editor_hideall3d

rem Use large prompt
statusbar$=strarr$(367) : popup_text(statusbar$)

rem Load FPM project into testmap files area
tloadsuccessfully=1
if skipfpmloading=1
 rem replace NEW with RELOAD
 open file map 1,"FPSEXCHANGE"
 set file map DWORD 1, 408, 0
 wait for file map event 1
 close file map 1
else
 rem this setstloadsuccessfully to zero if failed to load FPM (corrupt zipfile)
 gosub _mapfile_loadproject_fpm
endif

rem Loaded successfully
if tloadsuccessfully=1
 `
 rem Clear map first
 gosub _gridedit_clear_map
 `
 rem Load segment bank
 popup_text_change(strarr$(610))
 gosub _segment_loadbank
 `
 rem Load entity bank and elements
 popup_text_change(strarr$(611))
 gosub _entity_loadbank
 gosub _entity_loadelementsdata
 `
 rem Load waypoints
 popup_text_change(strarr$(612))
 gosub _waypoint_loaddata
 gosub _waypoint_recreateobjs
 `
 rem Load data
 popup_text_change(strarr$(613))
 gosub _mapfile_loadmap
 `
 rem Update remaining map data before editing
 gosub _gridedit_updatemapbeforeedit
 `
 rem Load editor configuration
 gosub _editor_loadcfg
 `
 rem Load segments/prefab/entities into window
 open file map 1,"FPSEXCHANGE"
 gosub _editor_filllibrary
 close file map 1
 `
 rem Add Latest project To Recent List
 gosub _gridedit_updateprojectname
 `
else
 `
 rem FPM could not be extracted (likely a corrupt zipfile)
 popup_text_change(strarr$(614))
 sleep 2000
 `
 rem Create blank in this case
 gosub _gridedit_new_map
 `
endif

rem Popup warning if load found some missing files
if timestampactivityflagged=1
 statusbar$=strarr$(368)
 popup_text_change(statusbar$) : sleep 2000
` popup_text_change(statusbar$) : tttt=0 : texit=0
` while spacekey()=0 and texit=0 and tttt<500
`  open file map 1, "FPSEXCHANGE"
`  wait for file map event 1
`  if get file map dword( 1, 100 )=13 or get file map dword( 1, 100 )=32 then set file map dword 1, 100, 0 : texit=1
`  if get file map dword( 1, 32 )=1 then set file map dword 1, 32, 0 : texit=1
`  wait for file map event 1
`  close file map 1
`  sleep 10
`  inc tttt
` endwhile
 timestampactivityflagged=0
endif

rem Clear status text
statusbar$="" : popup_text_close()

rem Quick update of cursors and editor graphics
lastgrideditselect=-1 : gosub _editor_refresheditmarkers

return

_gridedit_changemodifiedflag:
 `
 rem project flag changed, update window text
 if lastprojectmodified<>projectmodified
  lastprojectmodified=projectmodified
  gosub _gridedit_updateprojectname
 endif
 `
return

_gridedit_updateprojectname:
 open file map 1,"FPSEXCHANGE"
 rem add to project title
 if lower$(left$(projectfilename$,len(rootdir$)))=lower$(rootdir$)
  tprojname$=right$(projectfilename$,len(projectfilename$)-len(rootdir$))
 else
  tprojname$=projectfilename$
 endif
 if projectmodified<>0 then tprojname$=tprojname$+"*"
 set file map string$ 1, 1000, tprojname$
 set file map dword 1, 416, 1
 wait for file map event 1
 while get file map dword(1, 416)=1
  wait for file map event 1
 endwhile
 rem add to recent files list
 if projectfilename$<>""
  set file map string$ 1, 1000, projectfilename$
  set file map dword 1, 438, 1
  wait for file map event 1
  while get file map dword(1, 438)=1
   wait for file map event 1
  endwhile
 endif
 close file map 1
return

_gridedit_intercept_savefirst:
 editorcanceltask=0
 if projectmodified=1
  open file map 1,"FPSEXCHANGE"
  set file map string$ 1, 1000, strarr$(369)
  set file map string$ 1, 1256, strarr$(370)
  set file map dword 1, 900, 2
  wait for file map event 1
  while get file map dword(1, 900)<>0
   wait for file map event 1
  endwhile
  tokay=get file map dword(1, 904)
  close file map 1
  rem refresh 3d view so dialog box not left black box
  for tsync=1 to 5 : sync : sleep 10 : next tsync
  if tokay=1
   rem yes save first
   gosub _gridedit_save_map_ask
   projectmodified=0 : gosub _gridedit_changemodifiedflag
  endif
  if tokay=2
   rem task cancelled
   editorcanceltask=1
  endif
 endif
return

_gridedit_open_map_ask:
 rem SAVE CURRENT (IF ANY)
 editorcanceltask=0
 if projectmodified=1
  rem If project modified, ask if want to save first
  gosub _gridedit_intercept_savefirst
 endif
 if editorcanceltask=0
  rem OPEN FPM
  open file map 1,"FPSEXCHANGE"
  set file map string$ 1, 1000, rootdir$+"mapbank\"
  set file map string$ 1, 1256, strarr$(371)
  set file map string$ 1, 1512, strarr$(372)
  set file map dword 1, 424, 1
  wait for file map event 1
  while get file map dword(1, 424)=1
   wait for file map event 1
  endwhile
  returnstring$=get file map string$(1, 1000)
  close file map 1
  rem refresh 3d view so dialog box not left black box
  for tsync=1 to 5 : sync : sleep 10 : next tsync
  if returnstring$<>""
   if lower$(right$(returnstring$,4))=".fpg"
    currentFPG$=right$(returnstring$,len(returnstring$)-len(rootdir$+"languagebank\"+language$+"\gamebank\"))
    gosub _interface_loadlevelFPMfrombuildgame
    rem extract FPM from level one of FPG
    projectfilename$=rootdir$+levelfpi$
    gosub _gridedit_load_map
   else
    if lower$(right$(returnstring$,4))=".fpm"
     projectfilename$=returnstring$
     gosub _gridedit_load_map
    else
     rem error bleep - not a FPG file!
    endif
   endif
   rem update to interface due to any gmultiplayergame change (from FPM load)
   gosub _arenamode_update
  endif
 endif
return

_gridedit_new_map_ask:
 rem SAVE CURRENT (IF ANY)
 editorcanceltask=0
 if projectmodified=1
  rem If project modified, ask if want to save first
  gosub _gridedit_intercept_savefirst
 endif
 rem refresh 3d view so dialog box not left black box
 for tsync=1 to 5 : sync : sleep 10 : next tsync
 if editorcanceltask=0
  rem NEW MAP
  gosub _gridedit_new_map
  rem update to interface due to any gmultiplayergame change
  if inputsys.donewarena=1
   rem Arena Mode
   gmultiplayergame=1 : gosub _arenamode_update
  else
   rem Single Player Level
   gmultiplayergame=0 : gosub _arenamode_update
  endif
 endif
return

_gridedit_save_map_ask:
 if projectfilename$=""
  gosub _gridedit_saveas_map
 else
  gosub _gridedit_save_map
 endif
return

_gridedit_saveas_map:
 rem SAVE AS DIALOG
 open file map 1,"FPSEXCHANGE"
 set file map string$ 1, 1000, rootdir$+"mapbank\"
 set file map string$ 1, 1256, strarr$(373)
 set file map string$ 1, 1512, strarr$(374)
 set file map dword 1, 428, 1
 wait for file map event 1
 while get file map dword(1, 428)=1
  wait for file map event 1
 endwhile
 returnstring$=get file map string$(1, 1000)
 close file map 1
 rem refresh 3d view so dialog box not left black box
 for tsync=1 to 5 : sync : sleep 10 : next tsync
 if returnstring$<>""
  if lower$(right$(returnstring$,4))<>".fpm" then returnstring$=returnstring$+".fpm"
  projectfilename$=returnstring$
  gosub _gridedit_save_map
 endif
return

_gridedit_rotatebuffermap:

rem temp array
newbuffermaxx=buffermaxy
newbuffermaxy=buffermaxx
dim storebuffermap(bufferlayer+1,newbuffermaxx+1,newbuffermaxy+1)
dim storebufferrefmap(bufferlayer+1,newbuffermaxx+1,newbuffermaxy+1)
dim storebuffermapolay(bufferlayer+1,newbuffermaxx+1,newbuffermaxy+1)

rem store map data in rotation order
for layer=0 to bufferlayer
 for my=0 to buffermaxy
  for mx=0 to buffermaxx
   storebuffermap(layer,buffermaxy-my,mx)=buffermap(layer,mx,my)
   storebufferrefmap(layer,buffermaxy-my,mx)=bufferrefmap(layer,mx,my)
   storebuffermapolay(layer,buffermaxy-my,mx)=buffermapolay(layer,mx,my)
  next mx
 next my
next layer

rem put map data back in from store
undim buffermap()
undim bufferrefmap()
undim buffermapolay(0)
dim buffermap(bufferlayer+1,newbuffermaxx+1,newbuffermaxy+1)
dim bufferrefmap(bufferlayer+1,newbuffermaxx+1,newbuffermaxy+1)
dim buffermapolay(bufferlayer+1,newbuffermaxx+1,newbuffermaxy+1)
for layer=0 to bufferlayer
 for my=0 to newbuffermaxy
  for mx=0 to newbuffermaxx
   mapid=storebuffermap(layer,mx,my)
   if mapid<>0
    gosub _gridedit_getmapvalues
    inc maprotate : if maprotate>3 then maprotate=0
    inc maporient : if maporient>3 then maporient=0
    writebuffermap(layer,mx,my,mapselection,mapscaler,mapground,maprotate,maporient,mapsymbol,maptile)
   endif
   refptr=storebufferrefmap(layer,mx,my)
   if refptr<>0
    bufferrefmap(layer,mx,my)=refptr
   endif
   tolayindex=storebuffermapolay(layer,mx,my)
   buffermapolay(layer,mx,my)=tolayindex
  next mx
 next my
next layer

rem new dimensions
buffermaxx=newbuffermaxx
buffermaxy=newbuffermaxy

rem record rotation count
inc bufferrotationcount
if bufferrotationcount>3 then dec bufferrotationcount,4

rem free usages
undim storebuffermap()
undim storebufferrefmap()
undim storebuffermapolay()

return

_gridedit_createbuffermesh:

rem Create mesh from buffermap
for layer=0 to bufferlayer
 for my=0 to buffermaxy
  for mx=0 to buffermaxx
   tbuffer=1 : tlayer=layer  : tx=mx : ty=my
   tmapid=buffermap(layer,mx,my)
   if tmapid<>0 then gosub _gridedit_addtile
   trefptr=bufferrefmap(layer,mx,my)
   if trefptr<>0
    refptr=trefptr+4 : e=*refptr
    gosub _gridedit_calctentitymesh
    gosub _gridedit_addentity
   endif
  next mx
 next my
next layer

return

_gridedit_deletebuffermesh:

rem Delete buffer meshes
if mastermeshmax>0
 for m=1 to mastermeshmax
  for s=0 to mastermeshsets
   if mastermesh(m,s).buffer=1
    obj=mastermesh(m,s).obj
    mastermesh(m,s).buffer=-1
    if object exist(obj)=1 then delete object obj
   endif
  next s
 next m
endif

return

_gridedit_updatelayershades:

rem assign fades to layers (FOR BLUEPRINT)
if mastermeshmax>0
 for m=1 to mastermeshmax
  if mastermesh(m).buffer=0
   for s=0 to mastermeshsets
    obj=mastermesh(m,s).obj
    if object exist(obj)=1
     dist=gridlayer-mastermesh(m,s).layer
     if dist=0
      show object obj
      fade object obj,100
      ghost object off obj
     else
      if gridlayershowsingle>0
       hide object obj
      else
       show object obj
       if dist>0
        tfade=50-(dist*10)
        if tfade<0 then tfade=0
        fade object obj,tfade
        ghost object off obj
       else
        tfade=25-(abs(dist)*5)
        if tfade<0 then tfade=0
        fade object obj,tfade
        ghost object on obj
       endif
      endif
     endif
    endif
   next s
  endif
 next m
endif

return

_gridedit_updatebufferobjects:

rem assign fades to layers (FOR CLIPBOARD BUFFER)
thighestpointy#=50+2+(gridlayer*100)
if mastermeshmax>0
 for m=1 to mastermeshmax
  if mastermesh(m).buffer=1
   for s=0 to mastermeshsets
    obj=mastermesh(m,s).obj
    if object exist(obj)=1
     if inputsys.activemouse=0
      hide object obj
     else
      tpointy#=50+2+(gridlayer*100)+(mastermesh(m,s).layer*100)
      if tpointy#>thighestpointy# then thighestpointy#=tpointy#
      position object obj,(inputsys.mmx*100)+50,tpointy#,(inputsys.mmy*-100)-50
      disable object zdepth obj
      ghost object on obj
      if mastermesh(m,s).layer=0
       fade object obj,100
      else
       fade object obj,40
      endif
      show object obj
     endif
    endif
   next s
  endif
 next m
endif

rem show arrow when clipboard in use
if bufferlayer<>-1
 position object 6,(inputsys.mmx*100)+50+(buffermaxx*50),thighestpointy#+10,(inputsys.mmy*-100)-50-(buffermaxy*50)
 yrotate object 6,wrapvalue(bufferrotationcount*90)
 show object 6
else
 hide object 6
endif

return

_gridedit_updatetile:

rem two iterations (as corners need final walls to make calc)
stmx=mx : stmy=my
for ttwoiters=0 to 1
 for scy=upy-1 to upy+1
  for scx=upx-1 to upx+1
    if scx>=0 and scx<maxx
     if scy>=0 and scy<maxy
      if scx<>upx or scy<>upy or updatealltiles=1
       mapid=map(uplayer,scx,scy)
       if mapid<>0
        gosub _gridedit_getmapvalues
        if mapground<4
         layer=uplayer : mx=scx : my=scy
         addgridselection=mapselection
         addgridscaler=mapscaler
         addgridground=mapground
         addgridorient=maporient
         addgridsymbol=mapsymbol
         addoffsetx=scx-upx : addoffsety=scy-upy
         if addremovenotadd=1
          if nogridsmart=-1
           gosub _gridedit_addtogridmap
          else
           if nogridsmart=0
            rem opposite wall remove, but ONLY for the tile containing that wall, else default
            tokay=0
            if gridorient=3 and addoffsetx=-1 and addoffsety= 0 then tokay=1
            if gridorient=0 and addoffsetx= 0 and addoffsety=-1 then tokay=1
            if gridorient=1 and addoffsetx= 1 and addoffsety= 0 then tokay=1
            if gridorient=2 and addoffsetx= 0 and addoffsety= 1 then tokay=1
            if tokay=1
             gosub _gridedit_deletefromgridmap
            else
             gosub _gridedit_addtogridmap
            endif
           else
            gosub _gridedit_addtogridmap
           endif
          endif
         else
          gosub _gridedit_addtogridmap
         endif
        endif
       endif
      endif
     endif
    endif
  next scx
 next scy
next ttwoiters
mx=stmx : my=stmy

rem vars used to indicate to addtile if direct-tile or update-tile
addoffsetx=0 : addoffsety=0

return

_gridedit_calctile:

 rem calc local grid coord
 tmasterx=tx/40 : tlx=tx-(tmasterx*40)
 tmastery=ty/40 : tly=ty-(tmastery*40)

 rem vars to set
 currentmastermesh=-1 : obj=-1

 rem find object holding grid mesh
 if mastermeshmax>0
  for m=1 to mastermeshmax
   if mastermesh(m,0).buffer=tbuffer and mastermesh(m,0).layer=tlayer and mastermesh(m,0).worldx=tmasterx and mastermesh(m,0).worldy=tmastery
    obj=mastermesh(m,0).obj
    currentmastermesh=m
    m=mastermeshmax+1
   endif
  next m
 endif

 rem if not found
 if obj=-1
  `
  rem if exceeding mastermesh array size, increase it
  if mastermeshmax>=mastermeshsize
   oldmastermeshsize=mastermeshsize
   if oldmastermeshsize>0
    dim storemapentries(oldmastermeshsize,mastermeshsets,40,40) as mapentriestype
    dim storemastermesh(oldmastermeshsize,mastermeshsets) as mastermeshtype
    for m=0 to oldmastermeshsize
     for s=0 to mastermeshsets
      storemastermesh(m,s).obj=mastermesh(m,s).obj
      storemastermesh(m,s).buffer=mastermesh(m,s).buffer
      storemastermesh(m,s).layer=mastermesh(m,s).layer
      storemastermesh(m,s).worldx=mastermesh(m,s).worldx
      storemastermesh(m,s).worldy=mastermesh(m,s).worldy
      for ly=0 to 40
       for lx=0 to 40
        storemapentries(m,s,lx,ly).vertmax1=mapentries(m,s,lx,ly).vertmax1
        storemapentries(m,s,lx,ly).vertmax2=mapentries(m,s,lx,ly).vertmax2
        storemapentries(m,s,lx,ly).indexmax1=mapentries(m,s,lx,ly).indexmax1
        storemapentries(m,s,lx,ly).indexmax2=mapentries(m,s,lx,ly).indexmax2
       next lx
      next ly
     next s
    next m
    undim mastermesh()
    undim mapentries()
   endif
   inc mastermeshsize,10
   dim mapentries(mastermeshsize,mastermeshsets,40,40) as mapentriestype
   dim mastermesh(mastermeshsize,mastermeshsets) as mastermeshtype
   if oldmastermeshsize>0
    for m=0 to oldmastermeshsize
     for s=0 to mastermeshsets
      mastermesh(m,s).obj=storemastermesh(m,s).obj
      mastermesh(m,s).buffer=storemastermesh(m,s).buffer
      mastermesh(m,s).layer=storemastermesh(m,s).layer
      mastermesh(m,s).worldx=storemastermesh(m,s).worldx
      mastermesh(m,s).worldy=storemastermesh(m,s).worldy
      for ly=0 to 40
       for lx=0 to 40
        mapentries(m,s,lx,ly).vertmax1=storemapentries(m,s,lx,ly).vertmax1
        mapentries(m,s,lx,ly).vertmax2=storemapentries(m,s,lx,ly).vertmax2
        mapentries(m,s,lx,ly).indexmax1=storemapentries(m,s,lx,ly).indexmax1
        mapentries(m,s,lx,ly).indexmax2=storemapentries(m,s,lx,ly).indexmax2
       next lx
      next ly
     next s
    next m
    undim storemastermesh()
    undim storemapentries()
   endif
  endif
  `
  rem see if a mastermesh slot is spare
  tokay=-1
  if mastermeshmax>0
   for m=1 to mastermeshmax
    if mastermesh(m,0).buffer=-1
     tokay=m : m=mastermeshmax+1
    endif
   next m
  endif
  `
  rem create new master mesh
  if tokay=-1
   rem new slot
   inc mastermeshmax
   m=mastermeshmax
   mastermesh(m,0).obj=currentmeshobject+1
   mastermesh(m,1).obj=currentmeshobject+2
   inc currentmeshobject,2
  else
   rem existing slot and obj number
   m=tokay
  endif
  `
  for s=0 to mastermeshsets
   mastermesh(m,s).buffer=tbuffer
   mastermesh(m,s).layer=tlayer
   mastermesh(m,s).worldx=tmasterx
   mastermesh(m,s).worldy=tmastery
  next s
  obj=mastermesh(m,0).obj
  currentmastermesh=m
  `
 endif

return

_gridedit_addtile:

 rem calculate local coords
 gosub _gridedit_calctile

 rem work out map values
 mapid=tmapid
 mapmeshoffset=100
 gosub _gridedit_getmapvalues
 if mapground=1 then mapmeshoffset=116
 if mapground=2 then mapmeshoffset=132
 if mapground=3 then mapmeshoffset=148
 tmeshindex=mapmeshoffset+maptile

 rem copy mesh into obj
 tlockforset=0
 trotate#=maprotate*90
 gosub _gridedit_lockandcopy

return

_gridedit_addentity:

 rem calculate local coords
 gosub _gridedit_calctile

 rem Choose mesh representing entity
 tmeshindex=tentitymesh

 rem copy mesh into (obj+1)=entity set
 tlockforset=1
 obj=obj+1 : trotate#=0
 gosub _gridedit_lockandcopy

return

_gridedit_lockandcopy:

 rem Make object
 if object exist(obj)=0
  make object box obj,0,0,0
  set object collision off obj
  set object cull obj,0
  set object transparency obj,1
  position object obj,50+(tmasterx*4000),(tlayer*100)+(50-(tlockforset*50)),-50+(tmastery*-4000)
  set object filter obj,0
  set object texture obj,0,0
  texture object obj,editorimagesoffset+tlockforset
  if tlockforset=1 then disable object zwrite obj
  inc objadd
 endif

 rem lock vertexdata
 lock vertexdata for limb obj,0

 rem add mesh and record entries
 vertmax1=get vertexdata vertex count()
 indexmax1=get vertexdata index count()
 add mesh to vertexdata tmeshindex
 vertmax2=get vertexdata vertex count()
 indexmax2=get vertexdata index count()

 rem Lock and Copy For Map Tile Geometry
 if tlockforset=0
 `
 rem Customise uv data
 if mapsymbol>0

  rem Calcuate texture uv for symbol
  tsymboltexture=15+mapsymbol
  tv=tsymboltexture/8 : tu=tsymboltexture-(tv*8)
  s#=1.0/8.0 : u#=s#*tu : v#=s#*tv
  `
  rem Rotate uv data based on rotation
  meshmaprot=maprotate-maporient
  if meshmaprot<0 then inc meshmaprot,4
  if meshmaprot=0
   tc1u#=u# : tc1v#=v#
   tc2u#=u# : tc2v#=v#+s#
   tc3u#=u#+s# : tc3v#=v#+s#
   tc4u#=u#+s# : tc4v#=v#
  endif
  if meshmaprot=1
   tc1u#=u#+s# : tc1v#=v#
   tc2u#=u# : tc2v#=v#
   tc3u#=u# : tc3v#=v#+s#
   tc4u#=u#+s# : tc4v#=v#+s#
  endif
  if meshmaprot=2
   tc1u#=u#+s# : tc1v#=v#+s#
   tc2u#=u#+s# : tc2v#=v#
   tc3u#=u# : tc3v#=v#
   tc4u#=u# : tc4v#=v#+s#
  endif
  if meshmaprot=3
   tc1u#=u# : tc1v#=v#+s#
   tc2u#=u#+s# : tc2v#=v#+s#
   tc3u#=u#+s# : tc3v#=v#
   tc4u#=u# : tc4v#=v#
  endif

  rem Customise uv data
  if mapmeshoffset=100 then tvert=3
  if mapmeshoffset=116 then tvert=3
  if mapmeshoffset=132 then tvert=3
  if mapmeshoffset=148 then tvert=3
  set vertexdata uv vertmax1+(tvert*4)+0,tc1u#,tc1v#
  set vertexdata uv vertmax1+(tvert*4)+1,tc2u#,tc2v#
  set vertexdata uv vertmax1+(tvert*4)+2,tc3u#,tc3v#
  set vertexdata uv vertmax1+(tvert*4)+3,tc4u#,tc4v#

 endif

 rem Customise position data for cube meshes only
 if mapmeshoffset=100 or mapmeshoffset=116 or mapmeshoffset=132 or mapmeshoffset=148
  segid=mapselection
  if segmentprofile(segid).blueprint.floorsizey<>-1
  `
  rem Rotate mapscaler based on rotation
  meshscaler1 = (mapscaler && %0001)
  meshscaler2 = (mapscaler && %0010)>>1
  meshscaler3 = (mapscaler && %0100)>>2
  meshscaler4 = (mapscaler && %1000)>>3
  select maprotate
   case 0 : meshscaler = mapscaler : endcase
   case 1 : meshscaler = (meshscaler4) + (meshscaler1<<1) + (meshscaler2<<2) + (meshscaler3<<3) : endcase
   case 2 : meshscaler = (meshscaler3) + (meshscaler4<<1) + (meshscaler1<<2) + (meshscaler2<<3) : endcase
   case 3 : meshscaler = (meshscaler2) + (meshscaler3<<1) + (meshscaler4<<2) + (meshscaler1<<3) : endcase
  endselect
  `
  rem Resize mesh
  tsc#=99.8/2.0
  tfly#=segmentprofile(segid).blueprint.floorsizey/100.0
  tsdx#=segmentprofile(segid).blueprint.sidesizex/100.0
  tsdy#=segmentprofile(segid).blueprint.sidesizey/100.0
  tsdz#=segmentprofile(segid).blueprint.sidesizez/100.0
  tscx1#=tsc#*tsdx#*-1
  tscy1#=((tsc#*1.0)*-1)
  tscz1#=tsc#*tsdz#*-1
  tscx2#=tsc#*tsdx#
  tfly2#=((tsc#*1.0)*-1)+(tfly#*(tsc#*2))
  tscy2#=((tsc#*1.0)*-1)+(tsdy#*(tsc#*2))
  tscz2#=tsc#*tsdz#

  rem z+
  tvert=0
  for t=0 to 3
   if t=0 then x#=tscx1# : y#=tscy2# : z#=tscz1#
   if t=1 then x#=tscx1# : y#=tscy1# : z#=tscz1#
   if t=2 then x#=tscx2# : y#=tscy1# : z#=tscz1#
   if t=3 then x#=tscx2# : y#=tscy2# : z#=tscz1#
   if segmentprofile(segid).blueprint.sidesizex=300
    if (meshscaler && %0001)=0 then x#=0 : y#=0 : z#=0
   endif
   set vertexdata position vertmax1+(tvert*4)+t,x#,y#,z#
  next t
  rem z-
  tvert=1
  for t=0 to 3
   if t=0 then x#=tscx1# : y#=tscy2# : z#=tscz2#
   if t=1 then x#=tscx1# : y#=tscy1# : z#=tscz2#
   if t=2 then x#=tscx2# : y#=tscy1# : z#=tscz2#
   if t=3 then x#=tscx2# : y#=tscy2# : z#=tscz2#
   if segmentprofile(segid).blueprint.sidesizex=300
    if (meshscaler && %0100)=0 then x#=0 : y#=0 : z#=0
   endif
   set vertexdata position vertmax1+(tvert*4)+t,x#,y#,z#
  next t
  rem x+
  tvert=4
  for t=0 to 3
   if t=0 then x#=tscz2# : y#=tscy2# : z#=tscx1#
   if t=1 then x#=tscz2# : y#=tscy1# : z#=tscx1#
   if t=2 then x#=tscz2# : y#=tscy1# : z#=tscx2#
   if t=3 then x#=tscz2# : y#=tscy2# : z#=tscx2#
   if segmentprofile(segid).blueprint.sidesizex=300
    if (meshscaler && %0010)=0 then x#=0 : y#=0 : z#=0
   endif
   set vertexdata position vertmax1+(tvert*4)+t,x#,y#,z#
  next t
  rem x -
  tvert=5
  for t=0 to 3
   if t=0 then x#=tscz1# : y#=tscy2# : z#=tscx1#
   if t=1 then x#=tscz1# : y#=tscy1# : z#=tscx1#
   if t=2 then x#=tscz1# : y#=tscy1# : z#=tscx2#
   if t=3 then x#=tscz1# : y#=tscy2# : z#=tscx2#
   if segmentprofile(segid).blueprint.sidesizex=300
    if (meshscaler && %1000)=0 then x#=0 : y#=0 : z#=0
   endif
   set vertexdata position vertmax1+(tvert*4)+t,x#,y#,z#
  next t
  rem y+
  tvert=2
  for t=0 to 3
   if t=0 then x#=-50 : y#=tfly2# : z#=50
   if t=1 then x#=50 : y#=tfly2# : z#=50
   if t=2 then x#=50 : y#=tfly2# : z#=-50
   if t=3 then x#=-50 : y#=tfly2# : z#=-50
   set vertexdata position vertmax1+(tvert*4)+t,x#,y#,z#
  next t
 endif
 endif
 `
 rem endif for Map Tile Geometry
 endif

 rem Lock and Copy For Entity Tile Geometry
 if tlockforset=1
 `
 `
 endif

 rem store entries (so we can delete later)
 mapentries(currentmastermesh,tlockforset,tlx,tly).vertmax1=vertmax1
 mapentries(currentmastermesh,tlockforset,tlx,tly).indexmax1=indexmax1
 mapentries(currentmastermesh,tlockforset,tlx,tly).vertmax2=vertmax2
 mapentries(currentmastermesh,tlockforset,tlx,tly).indexmax2=indexmax2

 rem prepare scale, rotate, offset
 R=MAKE MATRIX4(1)
 R=MAKE MATRIX4(2)
 SET IDENTITY MATRIX4 1
 SET IDENTITY MATRIX4 2
 ROTATE Y MATRIX4 1,trotate#*(3.141592654/180.0)
 TRANSLATE MATRIX4 2,tlx*100,0,tly*-100
 MULTIPLY MATRIX4 1,1,2

 rem apply a transform to vertex data
 R=make vector3(2) : R=make vector3(3)
 R=make vector3(4) : R=make vector3(5)
 for v=vertmax1 to vertmax2-1
  `
  rem get vertex data
  x#=get vertexdata position x(v)
  y#=get vertexdata position y(v)
  z#=get vertexdata position z(v)
  SET VECTOR3 2,x#,y#,z#
  nx#=get vertexdata normals x(v)
  ny#=get vertexdata normals y(v)
  nz#=get vertexdata normals z(v)
  SET VECTOR3 3,nx#,ny#,nz#
  `
  rem transform vertex data for scale, rotate, offset
  TRANSFORM COORDS VECTOR3 4,2,1
  TRANSFORM NORMALS VECTOR3 5,3,1
  NORMALIZE VECTOR3 5,5
  `
  rem set new vertex data
  set vertexdata position v,x vector3(4),y vector3(4),z vector3(4)
  set vertexdata normals v,x vector3(5),y vector3(5),z vector3(5)
  `
 next v

 rem unlock vertexdata
 unlock vertexdata

return

_gridedit_removetile:

 rem calculate local coords
 gosub _gridedit_calctile

 rem Remove map tile
 tlockforset=0
 gosub _gridedit_lockanddelete

return

_gridedit_removeentity:

 rem calculate local coords
 gosub _gridedit_calctile

 rem Remove map tile
 obj=obj+1
 tlockforset=1
 gosub _gridedit_lockanddelete

return

_gridedit_lockanddelete:

 rem ensure valid for removal
 if mapentries(currentmastermesh,tlockforset,tlx,tly).vertmax2>0

  rem store entries (so we can delete later)
  vertmax1=mapentries(currentmastermesh,tlockforset,tlx,tly).vertmax1
  indexmax1=mapentries(currentmastermesh,tlockforset,tlx,tly).indexmax1
  vertmax2=mapentries(currentmastermesh,tlockforset,tlx,tly).vertmax2
  indexmax2=mapentries(currentmastermesh,tlockforset,tlx,tly).indexmax2

  rem lock vertexdata
  lock vertexdata for limb obj,0

  rem delete mesh
  delete mesh from vertexdata vertmax1,vertmax2,indexmax1,indexmax2
  mapentries(currentmastermesh,tlockforset,tlx,tly).vertmax2=0

  rem unlock vertexdata
  unlock vertexdata

  rem must shuffle all v/i entries to keep track of existing meshes
  vgap=vertmax2-vertmax1
  igap=indexmax2-indexmax1
  for ly=0 to 40
   for lx=0 to 40
    if mapentries(currentmastermesh,tlockforset,lx,ly).vertmax1>vertmax1
     mapentries(currentmastermesh,tlockforset,lx,ly).vertmax1=mapentries(currentmastermesh,tlockforset,lx,ly).vertmax1-vgap
     mapentries(currentmastermesh,tlockforset,lx,ly).indexmax1=mapentries(currentmastermesh,tlockforset,lx,ly).indexmax1-igap
     mapentries(currentmastermesh,tlockforset,lx,ly).vertmax2=mapentries(currentmastermesh,tlockforset,lx,ly).vertmax2-vgap
     mapentries(currentmastermesh,tlockforset,lx,ly).indexmax2=mapentries(currentmastermesh,tlockforset,lx,ly).indexmax2-igap
    endif
   next lx
  next ly

 endif

return

_gridedit_refreshtile:

if wasmapid<>map(layer,mx,my)
 tbuffer=0 : tlayer=layer  : tx=mx : ty=my : tmapid=map(layer,mx,my)
 if map(layer,mx,my)<>0
  if wasmapid<>0 then gosub _gridedit_removetile
  gosub _gridedit_addtile
 else
  gosub _gridedit_removetile
 endif
endif

return

_gridedit_makemaskfromtile:
 `
 rem create mask from current maptile (left,top,right,bottom)
 rem and the corner data (lefttop,righttop,rightbottom,leftbottom)
 tamask=makemaskfromtile(maptile,maprotate)
 `
return

_gridedit_gettamask:
 `
 rem from map
 maptile=0 : maprotate=0
 mapid=map(layer,mx,my)
 if mapid<>0
  gosub _gridedit_getmapvalues
  addgridground=mapground
  addgridsymbol=mapsymbol
 else
  if nogridsmart=0
   rem WALL
   maprotate=gridorient : maptile=5
   addgridsymbol=1
  endif
  if nogridsmart=1
   rem FLOOR
   maprotate=gridorient : maptile=6
  endif
 endif
 `
 rem create mask from current maptile
 gosub _gridedit_makemaskfromtile
 `
return

_gridedit_filtercorners:
 `
 rem filter out corners if wall exists after above
 if tamask && %10000000 then tamask = tamask && %11110110
 if tamask && %01000000 then tamask = tamask && %11110011
 if tamask && %00100000 then tamask = tamask && %11111001
 if tamask && %00010000 then tamask = tamask && %11111100
 `
return

_gridedit_returntamask:
 `
 rem initial add vars
 addgridrotate=maprotate
 addmaptile=maptile
 `
 rem modify add vars with new mask
 select tamask

  case %11110000 : addmaptile=1 : addgridrotate=0 : endcase
  case %11010000 : addmaptile=2 : addgridrotate=0 : endcase
  case %11000000 : addmaptile=3 : addgridrotate=0 : endcase
  case %01010000 : addmaptile=4 : addgridrotate=0 : endcase
  case %01000000 : addmaptile=5 : addgridrotate=0 : endcase
  case %00000000 : addmaptile=6 : addgridrotate=0 : endcase
  case %00001000 : addmaptile=7 : addgridrotate=0 : endcase
  case %00001100 : addmaptile=8 : addgridrotate=0 : endcase
  case %00001010 : addmaptile=9 : addgridrotate=0 : endcase
  case %00001110 : addmaptile=10 : addgridrotate=0 : endcase
  case %00001111 : addmaptile=11 : addgridrotate=0 : endcase
  case %01000001 : addmaptile=12 : addgridrotate=0 : endcase
  case %01000010 : addmaptile=13 : addgridrotate=0 : endcase
  case %01000011 : addmaptile=14 : addgridrotate=0 : endcase
  case %11000010 : addmaptile=15 : addgridrotate=0 : endcase

`  case %11110000 : addmaptile=1 : addgridrotate=1 : endcase
  case %11100000 : addmaptile=2 : addgridrotate=1 : endcase
  case %01100000 : addmaptile=3 : addgridrotate=1 : endcase
  case %10100000 : addmaptile=4 : addgridrotate=1 : endcase
  case %00100000 : addmaptile=5 : addgridrotate=1 : endcase
`  case %00000000 : addmaptile=6 : addgridrotate=1 : endcase
  case %00000100 : addmaptile=7 : addgridrotate=1 : endcase
  case %00000110 : addmaptile=8 : addgridrotate=1 : endcase
  case %00000101 : addmaptile=9 : addgridrotate=1 : endcase
  case %00000111 : addmaptile=10 : addgridrotate=1 : endcase
`  case %00001111 : addmaptile=11 : addgridrotate=1 : endcase
  case %00101000 : addmaptile=12 : addgridrotate=1 : endcase
  case %00100001 : addmaptile=13 : addgridrotate=1 : endcase
  case %00101001 : addmaptile=14 : addgridrotate=1 : endcase
  case %01100001 : addmaptile=15 : addgridrotate=1 : endcase

`  case %11110000 : addmaptile=1 : addgridrotate=2 : endcase
  case %01110000 : addmaptile=2 : addgridrotate=2 : endcase
  case %00110000 : addmaptile=3 : addgridrotate=2 : endcase
  case %01010000 : addmaptile=4 : addgridrotate=2 : endcase
  case %00010000 : addmaptile=5 : addgridrotate=2 : endcase
`  case %00000000 : addmaptile=6 : addgridrotate=2 : endcase
  case %00000010 : addmaptile=7 : addgridrotate=2 : endcase
  case %00000011 : addmaptile=8 : addgridrotate=2 : endcase
  case %00001010 : addmaptile=9 : addgridrotate=2 : endcase
  case %00001011 : addmaptile=10 : addgridrotate=2 : endcase
`  case %00001111 : addmaptile=11 : addgridrotate=2 : endcase
  case %00010100 : addmaptile=12 : addgridrotate=2 : endcase
  case %00011000 : addmaptile=13 : addgridrotate=2 : endcase
  case %00011100 : addmaptile=14 : addgridrotate=2 : endcase
  case %00111000 : addmaptile=15 : addgridrotate=2 : endcase

`  case %11110000 : addmaptile=1 : addgridrotate=3 : endcase
  case %10110000 : addmaptile=2 : addgridrotate=3 : endcase
  case %10010000 : addmaptile=3 : addgridrotate=3 : endcase
  case %10100000 : addmaptile=4 : addgridrotate=3 : endcase
  case %10000000 : addmaptile=5 : addgridrotate=3 : endcase
`  case %00000000 : addmaptile=6 : addgridrotate=3 : endcase
  case %00000001 : addmaptile=7 : addgridrotate=3 : endcase
  case %00001001 : addmaptile=8 : addgridrotate=3 : endcase
  case %00000101 : addmaptile=9 : addgridrotate=3 : endcase
  case %00001101 : addmaptile=10 : addgridrotate=3 : endcase
`  case %00001111 : addmaptile=11 : addgridrotate=3 : endcase
  case %10000010 : addmaptile=12 : addgridrotate=3 : endcase
  case %10000100 : addmaptile=13 : addgridrotate=3 : endcase
  case %10000110 : addmaptile=14 : addgridrotate=3 : endcase
  case %10010100 : addmaptile=15 : addgridrotate=3 : endcase

 endselect
 `
 rem new system - 'sides control' construction
 writemap(layer,mx,my,addgridselection,addgridscaler,addgridground,addgridrotate,addgridorient,addgridsymbol,addmaptile)
 `
return

_gridedit_considercorners:
 `
 rem Possibility of intelegently adding corners where needed
 if mx>0 and my>0
  if (getmapmask(layer,mx-1,my) && %01000000)>0
   if (getmapmask(layer,mx,my-1) && %10000000)>0
    if (tamask && %11000000)=0 then tamask = tamask || %00001000
   endif
  endif
 endif
 if mx<maxx and my>0
  if (getmapmask(layer,mx+1,my) && %01000000)>0
   if (getmapmask(layer,mx,my-1) && %00100000)>0
    if (tamask && %01100000)=0 then tamask = tamask || %00000100
   endif
  endif
 endif
 if mx<maxx and my<maxy
  if (getmapmask(layer,mx+1,my) && %00010000)>0
   if (getmapmask(layer,mx,my+1) && %00100000)>0
    if (tamask && %00110000)=0 then tamask = tamask || %00000010
   endif
  endif
 endif
 if mx>0 and my<maxy
  if (getmapmask(layer,mx-1,my) && %00010000)>0
   if (getmapmask(layer,mx,my+1) && %10000000)>0
    if (tamask && %10010000)=0 then tamask = tamask || %00000001
   endif
  endif
 endif
 `
 rem Possibility of intelegently removal of corners where needed
 if mx>0 and my>0
  if (getmapmask(layer,mx-1,my) && %01000000)=0 or (getmapmask(layer,mx,my-1) && %10000000)=0
   if (tamask && %11000000)=0 then tamask = tamask && %11110111
  endif
 endif
 if mx<maxx and my>0
  if (getmapmask(layer,mx+1,my) && %01000000)=0 or (getmapmask(layer,mx,my-1) && %00100000)=0
   if (tamask && %01100000)=0 then tamask = tamask && %11111011
  endif
 endif
 if mx<maxx and my<maxy
  if (getmapmask(layer,mx+1,my) && %00010000)=0 or (getmapmask(layer,mx,my+1) && %00100000)=0
   if (tamask && %00110000)=0 then tamask = tamask && %11111101
  endif
 endif
 if mx>0 and my<maxy
  if (getmapmask(layer,mx-1,my) && %00010000)=0 or (getmapmask(layer,mx,my+1) && %10000000)=0
   if (tamask && %10010000)=0 then tamask = tamask && %11111110
  endif
 endif
 `
return

_gridedit_addtogridmap:
 `
 rem record current state
 wasmapid=map(layer,mx,my)
 `
 rem must erase old tile data so not influence new addition
 if tfreshgridadd=1 and nogridsmart=-1
  tmapid=map(layer,mx,my)
  if tmapid>0
   rem erase any entities on it

   rem erase tile
   map(layer,mx,my)=0
  endif
 endif
 `
 rem only add the set 'side'
 gosub _gridedit_gettamask
 `
 rem gridsmart system chooses best tile
 if nogridsmart=-1
  `
  rem vars used to indicate to addtile if direct-tile or update-tile
  if addoffsetx=0 and addoffsety=0
   rem default AUTO tile is all walls and floor (only direct-tile)
   tamask = %11110000
   rem force a floor for auto-full (only if not doing a buffer copy)
   if bufferlayer=-1 then addgridsymbol=0
   rem remove connected walls
   if mx>0
    if chkmapyes(layer,mx-1,my,addgridground)=1 then tamask = tamask && %01111111
   endif
   if mx<maxx
    if chkmapyes(layer,mx+1,my,addgridground)=1 then tamask = tamask && %11011111
   endif
   if my>0
    if chkmapyes(layer,mx,my-1,addgridground)=1 then tamask = tamask && %10111111
   endif
   if my<maxy
    if chkmapyes(layer,mx,my+1,addgridground)=1 then tamask = tamask && %11101111
   endif
  else
   rem update-tile only WALL in the direction of the direct-tile
   if mx-addoffsetx>=0 and mx-addoffsetx<=maxx and my-addoffsety>=0 and my-addoffsety<=maxy
    if chkmapyes(layer,mx-addoffsetx,my-addoffsety,addgridground)=1
     rem Remove wall to interconnect room
     if addoffsetx=-1 and addoffsety=-1 then tamask = tamask && %11111101
     if addoffsetx= 0 and addoffsety=-1 then tamask = tamask && %11101111
     if addoffsetx= 1 and addoffsety=-1 then tamask = tamask && %11111110
     if addoffsetx=-1 and addoffsety= 0 then tamask = tamask && %11011111
     if addoffsetx= 1 and addoffsety= 0 then tamask = tamask && %01111111
     if addoffsetx=-1 and addoffsety= 1 then tamask = tamask && %11111011
     if addoffsetx= 0 and addoffsety= 1 then tamask = tamask && %10111111
     if addoffsetx= 1 and addoffsety= 1 then tamask = tamask && %11110111
    else
     rem Add wall if no room to connect to
     if addoffsetx=-1 and addoffsety=-1 then tamask = tamask || %00000010
     if addoffsetx= 0 and addoffsety=-1 then tamask = tamask || %00010000
     if addoffsetx= 1 and addoffsety=-1 then tamask = tamask || %00000001
     if addoffsetx=-1 and addoffsety= 0 then tamask = tamask || %00100000
     if addoffsetx= 1 and addoffsety= 0 then tamask = tamask || %10000000
     if addoffsetx=-1 and addoffsety= 1 then tamask = tamask || %00000100
     if addoffsetx= 0 and addoffsety= 1 then tamask = tamask || %01000000
     if addoffsetx= 1 and addoffsety= 1 then tamask = tamask || %00001000
    endif
   endif
  endif
  `
 rem nosmart else
 else
  `
  rem direct-tile-add-one-X
  if addoffsetx=0 and addoffsety=0
   if nogridsmart=0
    rem WALL - TOP
    if gridorient=0
     tamask = tamask || %01000000
    endif
    rem RIGHT
    if gridorient=1
     tamask = tamask || %00100000
    endif
    rem BOTTOM
    if gridorient=2
     tamask = tamask || %00010000
    endif
    rem LEFT
    if gridorient=3
     tamask = tamask || %10000000
    endif
   endif
   if nogridsmart=1
    rem FLOOR
    addgridsymbol=0
   endif
  else
   if nogridsmart=0
    rem must add a reverse-version of wall (intele)
    if gridorient=3 and addoffsetx=-1 and addoffsety= 0 then tamask = tamask || %00100000
    if gridorient=0 and addoffsetx= 0 and addoffsety=-1 then tamask = tamask || %00010000
    if gridorient=1 and addoffsetx= 1 and addoffsety= 0 then tamask = tamask || %10000000
    if gridorient=2 and addoffsetx= 0 and addoffsety= 1 then tamask = tamask || %01000000
   endif
   if nogridsmart=1
    rem FLOOR
   endif
  endif
  `
 rem nosmart endif
 endif
 `
 rem Possibility of intelegently adding corners where needed
 gosub _gridedit_considercorners
 `
 rem filter out corners if wall exists after above
 gosub _gridedit_filtercorners
 `
 rem recreate maptile from new mask
 gosub _gridedit_returntamask
 `
 rem if changed, update grid
 gosub _gridedit_refreshtile
 `
return

_gridedit_deletefromgridmap:
 `
 rem record current state
 wasmapid=map(layer,mx,my)
 `
 rem only delete set 'side'
 gosub _gridedit_gettamask
 `
 rem in the case of deletes, assume the mapselection id
 addgridselection=mapselection
 `
 rem gridsmart system chooses best tile
 if nogridsmart=-1
  `
  rem default AUTO tile is NO walls (direct-tile only)
  if addoffsetx=0 and addoffsety=0
   tamask = %00000000
   addgridsymbol=1
  else
   rem add walls only in the direction of the direct-tile (return wall if delete direct-tile)
   if addoffsetx=-1 and addoffsety=-1 then tamask = tamask || %00000010
   if addoffsetx= 0 and addoffsety=-1 then tamask = tamask || %00010000
   if addoffsetx= 1 and addoffsety=-1 then tamask = tamask || %00000001
   if addoffsetx=-1 and addoffsety= 0 then tamask = tamask || %00100000
   if addoffsetx= 1 and addoffsety= 0 then tamask = tamask || %10000000
   if addoffsetx=-1 and addoffsety= 1 then tamask = tamask || %00000100
   if addoffsetx= 0 and addoffsety= 1 then tamask = tamask || %01000000
   if addoffsetx= 1 and addoffsety= 1 then tamask = tamask || %00001000
  endif
  `
 else
  `
  rem direct-tile-add-one-X (TOP,RIGHT,BOTTOM,LEFT)
  if addoffsetx=0 and addoffsety=0
   if nogridsmart=0
    rem WALL
    if gridorient=0 then tamask = tamask && %10110011
    if gridorient=1 then tamask = tamask && %11011001
    if gridorient=2 then tamask = tamask && %11101100
    if gridorient=3 then tamask = tamask && %01110110
   endif
   if nogridsmart=1
    rem remove FLOOR
    addgridsymbol=1
   endif
  else
   rem remove wall connected to direct-tile-wall
   if nogridsmart=0
    rem must remove a reverse-version of wall
    if gridorient=3 and addoffsetx=-1 and addoffsety= 0 then tamask = tamask && %11011111
    if gridorient=0 and addoffsetx= 0 and addoffsety=-1 then tamask = tamask && %11101111
    if gridorient=1 and addoffsetx= 1 and addoffsety= 0 then tamask = tamask && %01111111
    if gridorient=2 and addoffsetx= 0 and addoffsety= 1 then tamask = tamask && %10111111
   endif
   if nogridsmart=1
    rem remove no FLOOR
   endif
  endif
  `
 endif
 `
 rem filter out corners if wall exists after above
 gosub _gridedit_filtercorners
 `
 rem Possibility of intelegently adding corners where needed
 if (tamask && %11111111)=0 and addgridsymbol=1
  rem going to delete, no corners needed
 else
  gosub _gridedit_considercorners
 endif
 `
 rem recreate maptile from new mask
 gosub _gridedit_returntamask
 `
 rem If no floors or wall parts, mark map tile as deleted
 if (tamask && %11111111)=0 and addgridsymbol=1
  map(layer,mx,my)=0
 endif
 `
 rem erase any editor-entities that belong to this overlay (for lift platforms, etc)
 seg=mapselection : gosub _gridedit_deletesegentities
 `
 rem Refresh tile
 gosub _gridedit_refreshtile
 `
return

_gridedit_addentitytomap:

rem Entity To Add
entitymaintype=1
entitybankindex=gridentity

rem Create new or use free entity element
tokay=0
if entityelementlist>0
 for e=1 to entityelementlist
  if entityelement(e).maintype=0 then tokay=e : exit
 next e
endif
if tokay=0
 `
 inc entityelementlist
 e=entityelementlist

 if entityelementlist>entityelementmax
  dim storeentityelement(entityelementmax) as entitytype
  for e=1 to entityelementmax
   storeentityelement(e).editorfixed=entityelement(e).editorfixed
   storeentityelement(e).maintype=entityelement(e).maintype
   storeentityelement(e).bankindex=entityelement(e).bankindex
   storeentityelement(e).staticflag=entityelement(e).staticflag
   storeentityelement(e).x=entityelement(e).x
   storeentityelement(e).y=entityelement(e).y
   storeentityelement(e).z=entityelement(e).z
   storeentityelement(e).rx=entityelement(e).rx
   storeentityelement(e).ry=entityelement(e).ry
   storeentityelement(e).rz=entityelement(e).rz
   storeentityelement(e).eleprof=entityelement(e).eleprof
  next e
  undim entityelement()
  inc entityelementmax,10
  dim entityelement(entityelementmax) as entitytype
  for e=1 to entityelementmax-10
   entityelement(e).editorfixed=storeentityelement(e).editorfixed
   entityelement(e).maintype=storeentityelement(e).maintype
   entityelement(e).bankindex=storeentityelement(e).bankindex
   entityelement(e).staticflag=storeentityelement(e).staticflag
   entityelement(e).x=storeentityelement(e).x
   entityelement(e).y=storeentityelement(e).y
   entityelement(e).z=storeentityelement(e).z
   entityelement(e).rx=storeentityelement(e).rx
   entityelement(e).ry=storeentityelement(e).ry
   entityelement(e).rz=storeentityelement(e).rz
   entityelement(e).eleprof=storeentityelement(e).eleprof
  next e
 endif
 `
else
 e=tokay
endif

rem Fill entity element details
entityelement(e).editorfixed=gridentityeditorfixed
entityelement(e).maintype=entitymaintype
entityelement(e).bankindex=entitybankindex
entityelement(e).staticflag=gridentitystaticmode
entityelement(e).x=gridentityposx#
entityelement(e).z=gridentityposz#
entityelement(e).y=gridentityposy#
entityelement(e).rx=gridentityrotatex#
entityelement(e).ry=gridentityrotatey#
entityelement(e).rz=gridentityrotatez#
entityelement(e).eleprof=grideleprof
`
rem GRIDELEPROF might contain GUN+FLAK Data
tgunid$=entityprofile(entid).isweapon$
gosub _entity_getgunidandflakid
if tgunid>0
 rem populate the actual gun and flak settings (for further weapon entity creations)
 gun(tgunid).settings.damage=grideleprof.damage
 gun(tgunid).settings.accuracy=grideleprof.accuracy
 gun(tgunid).settings.reloadqty=grideleprof.reloadqty
 gun(tgunid).settings.iterate=grideleprof.fireiterations
 if tflakid>0
  flak(tflakid).profile.lifespan=grideleprof.lifespan
  flak(tflakid).profile.zinc=grideleprof.throwspeed
  flak(tflakid).throwangle=grideleprof.throwangle
  flak(tflakid).profile.bounceonhit=grideleprof.bounceqty
  flak(tflakid).profile.explodeonhit=grideleprof.explodeonhit
 endif
 rem which must also populate ALL other entities of same weapon
 tgunidchanged=tgunid
 for te=1 to entityelementlist
  tentid=entityelement(te).bankindex
  tgunid$=entityprofile(tentid).isweapon$
  gosub _entity_getgunidandflakid
  if tgunid=tgunidchanged
   entityelement(te).eleprof.damage=grideleprof.damage
   entityelement(te).eleprof.accuracy=grideleprof.accuracy
   entityelement(te).eleprof.reloadqty=grideleprof.reloadqty
   entityelement(te).eleprof.fireiterations=grideleprof.fireiterations
   entityelement(te).eleprof.lifespan=grideleprof.lifespan
   entityelement(te).eleprof.throwspeed=grideleprof.throwspeed
   entityelement(te).eleprof.throwangle=grideleprof.throwangle
   entityelement(te).eleprof.bounceqty=grideleprof.bounceqty
   entityelement(te).eleprof.explodeonhit=grideleprof.explodeonhit
  endif
 next te
endif
`
rem Add entity reference into map
addtobufferref=0 : gosub _gridedit_addentityreftomap

return

_gridedit_calctentitymesh:
 rem based on E
 tentitymesh=201
 tentid=entityelement(e).bankindex
 if entityprofile(tentid).ismarker=0
  if entityprofile(tentid).ischaracter=1
   tentitymesh=206
  else
   if entityelement(e).staticflag=1
    tentitymesh=202
   else
    if gmultiplayergame=0
     tentitymesh=204
    else
     if entityprofile(tentid).isammo<>0 or entityprofile(tentid).isweapon<>0 or entityprofile(tentid).ischaracter<>0 or entityprofile(tentid).ishealth<>0
      tentitymesh=204
     else
      tentitymesh=202
     endif
    endif
   endif
  endif
 else
  if entityprofile(tentid).ismarker=1
   if entityprofile(tentid).lives>0
    tentitymesh=204
   else
    tentitymesh=208
   endif
  endif
  if entityprofile(tentid).ismarker=2 then tentitymesh=203
  if entityprofile(tentid).ismarker=3 then tentitymesh=207
  if entityprofile(tentid).ismarker=4 then tentitymesh=205
 endif
return

_gridedit_addentityreftomap:

rem determine grid position of entity
layer=entityelement(e).y/100.0
mx=entityelement(e).x/100.0
my=entityelement(e).z/-100.0

rem Set reference on map tile
if addtobufferref=0 then ptrbase=refmap(layer,mx,my)
if addtobufferref=1 then ptrbase=bufferrefmap(layer,mx,my)
if ptrbase=0
 tmax=1
 ptrbase=make memory(4+4)
else
 tmax=*ptrbase
 newptrbase=make memory(4+((tmax+1)*4))
 copy memory newptrbase, ptrbase, 4+(tmax*4)
 delete memory ptrbase
 ptrbase=newptrbase
 tmax=tmax+1
endif
ptr=ptrbase+0 : *ptr=tmax
ptr=ptrbase+(tmax*4) : *ptr=e

rem Add entity marker if new
if addtobufferref=0 then trefmap=refmap(layer,mx,my)
if addtobufferref=1 then trefmap=bufferrefmap(layer,mx,my)
if addtobufferref=0
 if trefmap=0
  gosub _gridedit_calctentitymesh
  tbuffer=0 : tlayer=layer  : tx=mx : ty=my
  gosub _gridedit_addentity
 endif
endif

rem Ensure latest base ptr used
if addtobufferref=0 then refmap(layer,mx,my)=ptrbase
if addtobufferref=1 then bufferrefmap(layer,mx,my)=ptrbase

return

_gridedit_deleteentityfrommap:

rem Entity Type To Delete
entitymaintype=1

rem Use entity coord to find tile
de=tentitytoselect
layer=entityelement(de).y/100.0
mx=entityelement(de).x/100.0
my=entityelement(de).z/-100.0

rem Get reference from map tile
ptrbase=refmap(layer,mx,my)
if ptrbase>0
 `
 tmax=*ptrbase
 ptr=ptrbase+4
 for tp=1 to tmax
  de=*ptr
  if de=tentitytoselect
   `
   rem blank from entity element list
   entityelement(de).bankindex=0
   entityelement(de).maintype=0
   entityelement(de).obj=0
   `
   while tp<tmax
    newptr=ptr+4
    de=*newptr
    *ptr=de
    inc ptr,4
    inc tp
   endwhile
   dec tmax : ptr=ptrbase+0 : *ptr=tmax
   exit
  endif
  inc ptr,4
  `
 next tp
 `
 rem remove from refmap
 if tmax=0
  delete memory ptrbase
  refmap(layer,mx,my)=0
 endif
 `
 rem remove entity marker from map (if no entities left in tile)
 if tmax=0
  tbuffer=0 : tlayer=layer  : tx=mx : ty=my
  gosub _gridedit_removeentity
 endif
 `
endif

return

_gridedit_deleteallentitiesontile:

rem Get reference from map tile
if ptrbase>0
 tmax=*ptrbase
 ptr=ptrbase+4
 for tp=1 to tmax
  rem blank from entity element list
  e=*ptr
  entityelement(e).bankindex=0
  entityelement(e).maintype=0
  inc ptr,4
 next tp
endif

return

_gridedit_addolay_findfree:
 `
 rem Find free olay index
 for tti=1 to olaylistmax
  if olaylist(tti,0)=0
   olayindex=tti : exit
  endif
 next tti
 if tti>olaylistmax
  rem my hunch is a redimmed array does not save straight, so
` inc olaylistmax
` dim olaylist(olaylistmax,50) as DWORD
  dim tempolaylist(olaylistmax,50) as DWORD
  for tolay=0 to olaylistmax
   for tolayi=0 to 50
    tempolaylist(tolay,tolayi)=olaylist(tolay,tolayi)
   next tolayi
  next tolay
  undim olaylist()
  toldolaylistmax=olaylistmax
  olayindex=olaylistmax+1
  inc olaylistmax,100
  dim olaylist(olaylistmax,50) as DWORD
  for tolay=0 to toldolaylistmax
   for tolayi=0 to 50
    olaylist(tolay,tolayi)=tempolaylist(tolay,tolayi)
   next tolayi
  next tolay
  undim tempolaylist()
 endif
 `
return

_gridedit_addolay_map:

rem record olay index in map grid
if mapolay(layer,mx,my)=0
 `
 rem find a new olay index
 gosub _gridedit_addolay_findfree
 `
 rem new seglist
 mapolay(layer,mx,my)=olayindex
 for ti=0 to 50
  olaylist(olayindex,ti)=0
 next ti
 `
else
 `
 rem find seglist from map
 olayindex=mapolay(layer,mx,my)
 `
endif

rem allow addition (only one per side of same selection
for ti=0 to 50
 mapid=olaylist(olayindex,ti)
 if mapid=0
  `
  rem Add OVERLAY MAP TILE at this point in list
  if buffermapid=0
   mapid=getmapid(addgridselection,addgridscaler,addgridground,addgridrotate,addgridorient,addgridsymbol,addmaptile)
   olaylist(olayindex,ti)=mapid
  else
   rem adjust offsets based on rotation
   mapid=buffermapid
   gosub _gridedit_getmapvalues
   inc maporient,bufferrotationcount
   if maporient>3 then dec maporient,4
   mapid=getmapid(mapselection,mapscaler,mapground,maprotate,maporient,mapsymbol,maptile)
   olaylist(olayindex,ti)=mapid
  endif
  exit
  `
 else
  gosub _gridedit_getmapvalues
  if addgridselection=mapselection
   if segmentprofile(gridselection).vis.overlay=2
    exit
   else
    if gridorient=0 and maporient=0 then exit
    if gridorient=1 and maporient=1 then exit
    if gridorient=2 and maporient=2 then exit
    if gridorient=3 and maporient=3 then exit
   endif
  endif
 endif
next ti

return

_gridedit_deletesegentities:
 `
 rem scan all entities used by this seg and erase from tile location (mx,my,layer)
 for tp=0 to segmentprofileheader(seg).partmax
  if segmentprofile(seg,tp).partmode=3
    rem get entity details
    lgx#=segmentprofile(seg,tp).offx
    lgz#=segmentprofile(seg,tp).offz
    if gridorient>0
     for brot=0 to maporient-1
      lgss#=lgx# : lgx#=lgz# : lgz#=lgss#*-1
     next brot
    endif
    lgx#=lgx#+(50+(mx*100))
    lgz#=lgz#+((my*-100)-50)
    lgy#=segmentprofile(seg,tp).offy+(50+(layer*100))
    addentityx=lgx# : addentityy=lgy# : addentityz=lgz#
    addentityrx=0 : addentityry=segmentprofile(seg,tp).roty : addentityrz=0
    addentityry=addentityry+(gridorient*90)
    rem if entity here
    if entityelementlist>0
     for te=1 to entityelementlist
      if entityelement(te).maintype>0
       tgodelete=0
       if deleteolaymode=1
        rem if entity is inside tile
        if entityelement(te).x>=(mx*100) and entityelement(te).x<(mx*100)+100
         if entityelement(te).y>=(layer*100) and entityelement(te).y<(layer*100)+100
          if entityelement(te).z<(my*-100) and entityelement(te).z>=(my*-100)-100
           tgodelete=1
          endif
         endif
        endif
       endif
       if tgodelete=0
        tentid=entityelement(te).bankindex
        if abs((entityelement(te).x)-addentityx)<=2
         if abs((entityelement(te).y)-addentityy)<=2
          if abs((entityelement(te).z)-addentityz)<=2
           tgodelete=1
          endif
         endif
        endif
       endif
       if tgodelete=1
        tentitytoselect=te : entityelement(te).editorfixed=0
        gosub _gridedit_deleteentityfrommap
       endif
      endif
     next e
    endif
  endif
 next tp
 `
return

_gridedit_deleteolay_map:

`takes layer,mx,my
if mapolay(layer,mx,my)=0
 rem nothing to delete
else
 rem seglist present
 olayindex=mapolay(layer,mx,my)
 rem clear list out of segs that match direction
 for ti=0 to 50
  mapid=olaylist(olayindex,ti)
  if mapid<>0
   gosub _gridedit_getmapvalues
   if segmentprofile(mapselection).vis.overlay=2 or deleteolaymode=1
    olaylist(olayindex,ti)=0
   else
    if gridorient=0 and maporient=0 then olaylist(olayindex,ti)=0
    if gridorient=1 and maporient=1 then olaylist(olayindex,ti)=0
    if gridorient=2 and maporient=2 then olaylist(olayindex,ti)=0
    if gridorient=3 and maporient=3 then olaylist(olayindex,ti)=0
   endif
   if olaylist(olayindex,ti)=0
    rem erase any editor-entities that belong to this overlay
    seg=mapselection : gosub _gridedit_deletesegentities
   endif
  else
   exit
  endif
 next ti
 rem shuffle empty spaces out
 titer=0
 for ti=0 to 49
  if olaylist(olayindex,ti)=0
   for tti=ti to 49
    olaylist(olayindex,tti)=olaylist(olayindex,tti+1)
   next tti
   olaylist(olayindex,50)=0
   dec ti
  endif
  inc titer : if titer>50 then exit
 next ti
 rem if nothing left..
 if olaylist(olayindex,0)=0
  rem remove seglist ref
  mapolay(layer,mx,my)=0
 endif
endif

return

_gridedit_removeallolays_olayindex:
 rem clear list out of segs that match direction
 for ti=0 to 50
  mapid=olaylist(olayindex,ti)
  if mapid<>0
   olaylist(olayindex,ti)=0
  else
   exit
  endif
 next ti
 rem completely clear olaylist
 for ti=0 to 50
  olaylist(olayindex,ti)=0
 next ti
return

remstart
rem this deleted overlays without the fixed entities!
_gridedit_removeallolays:
 rem will remove all olays from all sides if primary segment paint on tile
 if mapolay(layer,mx,my)=0
  rem nothing to delete
 else
  rem seglist present
  olayindex=mapolay(layer,mx,my)
  rem clear list out of segs that match direction
  gosub _gridedit_removeallolays_olayindex
  rem remove seglist ref
  mapolay(layer,mx,my)=0
 endif
return
remend

`
` Meshes
`

_gridedit_createmeshes:

rem Interior
rem Make basic cube meshes (99.8=100 with CSG in makemeshprocess)
meshmax=16
for mesh=101 to 100+meshmax
 make object box mesh,99.8,98,99.8
 if mesh=101 then modifycube(mesh,0,0,1,0,0,0)
 if mesh=102 then modifycube(mesh,0,0,2,0,6,0)
 if mesh=103 then modifycube(mesh,6,0,3,0,6,0)
 if mesh=104 then modifycube(mesh,0,0,4,0,6,6)
 if mesh=105 then modifycube(mesh,6,0,5,0,6,6)
 if mesh=106 then modifycube(mesh,6,6,6,0,6,6)
 if mesh=107 then modifycube(mesh,6,6,7,0,6,6)
 if mesh=108 then modifycube(mesh,6,6,8,0,6,6)
 if mesh=109 then modifycube(mesh,6,6,9,0,6,6)
 if mesh=110 then modifycube(mesh,6,6,10,0,6,6)
 if mesh=111 then modifycube(mesh,6,6,11,0,6,6)
 if mesh=112 then modifycube(mesh,6,0,12,0,6,6)
 if mesh=113 then modifycube(mesh,6,0,13,0,6,6)
 if mesh=114 then modifycube(mesh,6,0,14,0,6,6)
 if mesh=115 then modifycube(mesh,6,0,15,0,6,0)
 make mesh from object mesh,mesh
 delete object mesh
next mesh

rem Interior2
for mesh=117 to 116+meshmax
 make object box mesh,99.8,98,99.8
 if mesh=117 then modifycube(mesh,0,0,1,19,0,0)
 if mesh=118 then modifycube(mesh,0,0,2,19,6,0)
 if mesh=119 then modifycube(mesh,6,0,3,19,6,0)
 if mesh=120 then modifycube(mesh,0,0,4,19,6,6)
 if mesh=121 then modifycube(mesh,6,0,5,19,6,6)
 if mesh=122 then modifycube(mesh,6,6,6,19,6,6)
 if mesh=123 then modifycube(mesh,6,6,7,19,6,6)
 if mesh=124 then modifycube(mesh,6,6,8,19,6,6)
 if mesh=125 then modifycube(mesh,6,6,9,19,6,6)
 if mesh=126 then modifycube(mesh,6,6,10,19,6,6)
 if mesh=127 then modifycube(mesh,6,6,11,19,6,6)
 if mesh=128 then modifycube(mesh,6,0,12,19,6,6)
 if mesh=129 then modifycube(mesh,6,0,13,19,6,6)
 if mesh=130 then modifycube(mesh,6,0,14,19,6,6)
 if mesh=131 then modifycube(mesh,6,0,15,19,6,0)
 make mesh from object mesh,mesh
 delete object mesh
next mesh

rem Exterior1
for mesh=132 to 131+meshmax
 make object box mesh,99.8,98,99.8
 if mesh=132 then modifycube(mesh,6,6,32,6,6,6)
 if mesh=133 then modifycube(mesh,32,32,1,32,32,32)
 if mesh=134 then modifycube(mesh,32,32,2,32,6,32)
 if mesh=135 then modifycube(mesh,6,32,3,32,6,32)
 if mesh=136 then modifycube(mesh,32,32,4,32,6,6)
 if mesh=137 then modifycube(mesh,6,32,5,32,6,6)
 if mesh=138 then modifycube(mesh,6,6,6,32,6,6)
 if mesh=139 then modifycube(mesh,6,6,7,32,6,6)
 if mesh=140 then modifycube(mesh,6,6,8,32,6,6)
 if mesh=141 then modifycube(mesh,6,6,9,32,6,6)
 if mesh=142 then modifycube(mesh,6,6,10,32,6,6)
 if mesh=143 then modifycube(mesh,6,6,11,32,6,6)
 if mesh=144 then modifycube(mesh,6,32,12,32,6,6)
 if mesh=145 then modifycube(mesh,6,32,13,32,6,6)
 if mesh=146 then modifycube(mesh,6,32,14,32,6,6)
 if mesh=147 then modifycube(mesh,6,32,15,32,6,32)
 make mesh from object mesh,mesh
 delete object mesh
next mesh

rem Exterior2
for mesh=148 to 147+meshmax
 make object box mesh,99.8,98,99.8
 if mesh=148 then modifycube(mesh,6,6,48,6,6,6)
 if mesh=149 then modifycube(mesh,48,48,1,48,48,48)
 if mesh=150 then modifycube(mesh,48,48,2,48,6,48)
 if mesh=151 then modifycube(mesh,6,48,3,48,6,48)
 if mesh=152 then modifycube(mesh,48,48,4,48,6,6)
 if mesh=153 then modifycube(mesh,6,48,5,48,6,6)
 if mesh=154 then modifycube(mesh,6,6,6,48,6,6)
 if mesh=155 then modifycube(mesh,6,6,7,48,6,6)
 if mesh=156 then modifycube(mesh,6,6,8,48,6,6)
 if mesh=157 then modifycube(mesh,6,6,9,48,6,6)
 if mesh=158 then modifycube(mesh,6,6,10,48,6,6)
 if mesh=159 then modifycube(mesh,6,6,11,48,6,6)
 if mesh=160 then modifycube(mesh,6,48,12,48,6,6)
 if mesh=161 then modifycube(mesh,6,48,13,48,6,6)
 if mesh=162 then modifycube(mesh,6,48,14,48,6,6)
 if mesh=163 then modifycube(mesh,6,48,15,48,6,48)
 make mesh from object mesh,mesh
 delete object mesh
next mesh

rem Entity makrer meshes (eight colors)
load mesh "editors\gfx\7.x",200
for mesh=201 to 208
 make object mesh,200,0
 scale object mesh,33,33,33
 if mesh=201 then modifyentity(mesh,0)
 if mesh=202 then modifyentity(mesh,1)
 if mesh=203 then modifyentity(mesh,2)
 if mesh=204 then modifyentity(mesh,3)
 if mesh=205 then modifyentity(mesh,4)
 if mesh=206 then modifyentity(mesh,5)
 if mesh=207 then modifyentity(mesh,6)
 if mesh=208 then modifyentity(mesh,7)
 make mesh from object mesh,mesh
 delete object mesh
next mesh

return

_gridedit_recreaterealviewshroud:

rem calculate shroud position center
if shroudstatic=0
 shroudmmx=inputsys.mmx
 shroudmmy=inputsys.mmy
endif
if shroudsize=10
 shroudmmx=(cx#/100.0)
 shroudmmy=(cy#/100.0)
endif

rem selection
if shroudstatic<2
 `
 rem blanking shroud to overlay blueprint
 o=1 : objstart=realviewobjectoffset
 make object plain objstart,100,100
 set object collision off objstart
 xrotate object objstart,90
 texture object objstart,editorimagesoffset+8
 set object transparency objstart,1
 disable object zread objstart
 `
 rem define layer visibility
 if gridlayershowall=0
  lystart=-1 : lyend=0
 else
  lystart=-1 : lyend=layermax-1
 endif
 if shroudsize=10 then lystart=-4
 `
 rem realview objects make up rest
 segmentselectionstart=selectionbankoffset
 for ly=lystart to lyend
  for y=0-shroudsize to shroudsize
   for x=0-shroudsize to shroudsize
    if gridlayer+ly>=0 and gridlayer+ly<=layermax
     if gridlayershowsingle=0 or (gridlayershowsingle>0 and ly=0)
      if shroudmmx+x>=0 and shroudmmx+x<=maxx
       if shroudmmy-y>=0 and shroudmmy-y<=maxy
        `
        rem scene reveal
        mapid=map(gridlayer+ly,shroudmmx+x,shroudmmy-y)
        if mapid<>0
         gosub _gridedit_getmapvalues
         sourceobj=segmentselectionstart+mapselection
         if object exist(sourceobj)=0
          rem avoid crash by removing corrupt maptile
          map(gridlayer+ly,shroudmmx+x,shroudmmy-y)=0
         else
          obj=objstart+o
          if object exist(obj)=1 then delete object obj
          instance object obj,sourceobj
          set object collision off obj
          disable object zdepth obj
          hide object obj
          inc o
         endif
        endif
        `
        rem segment overlay reveal
        olayindex=mapolay(gridlayer+ly,shroudmmx+x,shroudmmy-y)
        if olayindex>0
         for ti=0 to 50
          mapid=olaylist(olayindex,ti)
          if mapid<>0
           gosub _gridedit_getmapvalues
           sourceobj=segmentselectionstart+mapselection
           obj=objstart+o
           if object exist(obj)=1 then delete object obj
           if object exist(sourceobj)=1
            instance object obj,sourceobj
           else
            make object cube obj,25
           endif
           set object collision off obj
           disable object zdepth obj
           hide object obj
           inc o
          else
           exit
          endif
         next ti
        endif
        `
        rem entity reveal
        ptrbase=refmap(gridlayer+ly,shroudmmx+x,shroudmmy-y)
        if ptrbase<>0
         tpmax=*ptrbase
         ptr=ptrbase+4
         for tp=1 to tpmax
          e=*ptr
          obj=objstart+o
          tentid=entityelement(e).bankindex
          sourceobj=entitybankoffset+tentid
          if object exist(obj)=1 then delete object obj
          if object exist(sourceobj)=1
           entityelement(e).profileobj=sourceobj
           enable object zwrite sourceobj
           entid=tentid : entobj=obj
           rem maximum speed required - sacrifice visual accuracy!
           instance object obj,sourceobj
           if entityprofile(tentid).fixnewy<>0
            rotate object obj,0,entityprofile(tentid).fixnewy,0
            fix object pivot obj
           endif
           if entityprofile(tentid).scale<>0 then scale object obj,entityprofile(tentid).scale,entityprofile(tentid).scale,entityprofile(tentid).scale
          else
           make object sphere obj,25
          endif
          set object collision off obj
          position object obj,entityelement(e).x,entityelement(e).y,entityelement(e).z
          rotate object obj,entityelement(e).rx,entityelement(e).ry,entityelement(e).rz
          entityelement(e).obj=obj
          disable object zdepth obj
          hide object obj
          inc ptr,4
          inc o
         next tp
        endif
        `
       endif
      endif
     endif
    endif
   next x
  next y
 next ly
 `
 rem Entity floating selection
 if realviewobjectfullpreview=0
  if gridentity>0
   obj=objstart+o
   sourceobj=entitybankoffset+gridentity
   if object exist(obj)=1 then delete object obj
   if object exist(sourceobj)=1
    entid=gridentity : entobj=obj
    enable object zwrite sourceobj
    rem allow clone when viewing the single entity up close
    gosub _entity_isgrideleprofunique
    tokay=0
    if grideleprof.uniqueelement=1 and entityprofile(entid).ischaracter=0 then tokay=1
    if tokay=1
     clone object obj,sourceobj
     if total object frames(obj)>0
      set object frame obj,0
      if entityprofile(entid).ischaracter=1
       if entityprofile(entid).animmax>=1
        teai=0 : if entityanim(entid,1).start>0 then teai=1
        loop object obj,entityanim(entid,teai).start,entityanim(entid,teai).finish
       else
        loop object obj : stop object obj
       endif
      endif
     endif
     gosub _entity_updatetextureandeffectfromgrideleprof
    else
     instance object obj,sourceobj
    endif
   else
    make object sphere obj,25
   endif
   if entityprofile(gridentity).fixnewy<>0
    rotate object obj,0,entityprofile(gridentity).fixnewy,0
    fix object pivot obj
   endif
   tescale=entityprofile(gridentity).scale
   if tescale>0 then scale object obj,tescale,tescale,tescale
   set object collision off obj
   disable object zdepth obj
`   set object transparency obj,2
   gridentityobj=obj
   inc o
  endif
 endif
 `
 rem Record end of realview objects
 realviewobjectoffsetend=objstart+(o-1)
 `
endif

return

_gridedit_deleterealviewoldshroud:

rem clear OBJ values in entityelements (as all objects are being removed)
if entityelementlist>0
 for e=1 to entityelementlist
  entityelement(e).obj=0
 next e
endif

rem delete all objects used for realview
for obj=realviewobjectoffset to realviewobjectoffsetend
 if object exist(obj)=1 then delete object obj
next obj

rem Indicate no shroud
realviewobjectoffsetend=0

return

_gridedit_setpercvalue:
 if shroudsize=10
  if ly=-1 then perc#=perc#/1.5
  if ly=-2 then perc#=perc#/2.0
  if ly=-3 then perc#=perc#/2.5
  if ly=-4 then perc#=perc#/3.0
  if ly=-5 then perc#=perc#/4.0
 else
  if ly=-1 then perc#=perc#/1.5
 endif
return

_gridedit_displayrealviewshroud:

rem calculate shroud position smoothing
if shroudstatic<>0
 tx=shroudmmx
 ty=shroudmmy
else
 tx=inputsys.mmx
 ty=inputsys.mmy
endif

otx#=tx#+(cx#/100.0)
oty#=ty#+(cy#/100.0)
dec otx#,(tx+0.5)
dec oty#,(ty+0.5)
otx#=otx#*100
oty#=oty#*100
dista#=(shroudsize-1.0)*100.0
distb#=(shroudsize+0.5)*100.0

rem full view shroud keeps base in corner
if shroudsize=10
 basex#=(shroudmmx*100)+50
 basey#=(shroudmmy*-100)-50
else
 basex#=(tx*100)+50
 basey#=(ty*-100)-50
endif

rem define layer visibility
if gridlayershowall=0
 lystart=-1 : lyend=0
else
 lystart=-1 : lyend=layermax-1
endif
if shroudsize=10 then lystart=-4
`
rem create blanker
o=1 : objstart=realviewobjectoffset
if object exist(objstart)=1
 position object objstart,basex#+otx#,0+(gridlayer*100.0),basey#-oty#
 scale object objstart,200+(shroudsize*200),200+(shroudsize*200),100
 if gridlayershowall=1 then hide object objstart
 if grideditselect=4 then hide object objstart
 if shroudsize=10 then scale object objstart,15000,15000,15000
endif

rem if shroud exist to display
if realviewobjectoffsetend<>0

rem create realview instances
for ly=lystart to lyend
 for y=0-shroudsize to shroudsize
  for x=0-shroudsize to shroudsize
   if gridlayer+ly>=0 and gridlayer+ly<=layermax
    if gridlayershowsingle=0 or (gridlayershowsingle>0 and ly=0)
     if shroudmmx+x>=0 and shroudmmx+x<=maxx
      if shroudmmy-y>=0 and shroudmmy-y<=maxy
       `
       rem alpha perc (shroudsize of zero means show all)
       perc#=0.0
       objx#=basex#+(x*100) : objy#=basey#+(y*100)
       dx#=(objx#-basex#)-otx# : dy#=(objy#-basey#)+oty#
       dist#=sqrt(abs(dx#*dx#)+abs(dy#*dy#))
       if dist#<=dista#
        perc#=100.0
       else
        if dist#<=distb#
         perc#=100.0-((dist#-dista#)/1.5)
        endif
       endif
       if gridlayershowall=1
        perc#=100.0-((100.0/lyend)*ly)
        if perc#<25.0 then perc#=25.0
        if perc#>80.0 then perc#=80.0
       endif
       if shroudsize=10 then perc#=100.0
       `
       rem map segment
       mapid=map(gridlayer+ly,shroudmmx+x,shroudmmy-y)
       if mapid<>0
         rem determine if scene obj visible
         vis=1 : obj=objstart+o
         if object exist(obj)=1
            gosub _gridedit_getmapvalues
            if maptile>=49 then dec maptile,48
            mapatl=gridlayer+ly : mapatx=shroudmmx+x : mapaty=shroudmmy-y
            gosub _segment_customisesinglesegment
            rem position real object
            position object obj,objx#,50+((gridlayer+ly)*100.0),objy#
            rem set alpha for real object
            if shroudstatic=1
               show object obj : set alpha mapping on obj,100
            else
               if perc#<=0.0
                  hide object obj
               else
                  show object obj
                  gosub _gridedit_setpercvalue
                  set alpha mapping on obj,perc#
               endif
            endif
         endif
         inc o
       endif
       `
       rem segment overlay reveal
       olayindex=mapolay(gridlayer+ly,shroudmmx+x,shroudmmy-y)
       if olayindex>0
        for ti=0 to 50
         mapid=olaylist(olayindex,ti)
         if mapid<>0
          rem determine if scene obj visible
          obj=objstart+o
          if object exist(obj)=1
             rem if scene obj present and visible, customise instance
             gosub _gridedit_getmapvalues
             if maptile>=49 then dec maptile,48
             mapatl=gridlayer+ly : mapatx=shroudmmx+x : mapaty=shroudmmy-y
             gosub _segment_customisesinglesegment
             rem position real object
             position object obj,objx#,50+((gridlayer+ly)*100.0),objy#
             rem set alpha for real object
             if shroudstatic=1
                show object obj : set alpha mapping on obj,100
             else
                if perc#<=0.0
                   hide object obj
                else
                   show object obj
                   gosub _gridedit_setpercvalue
                   set alpha mapping on obj,perc#
                endif
             endif
          endif
          inc o
         else
          exit
         endif
        next ti
       endif
       `
       rem entity reveal
       ptrbase=refmap(gridlayer+ly,shroudmmx+x,shroudmmy-y)
       if ptrbase<>0
         tpmax=*ptrbase
         ptr=ptrbase+4
         for tp=1 to tpmax
          rem set alpha for real object
          obj=objstart+o
          if shroudstatic=1
             show object obj : rem set alpha mapping on obj,100 - entities need to retain alpha
          else
             if perc#<=0.0
                hide object obj
             else
                show object obj
`                gosub _gridedit_setpercvalue
                rem set alpha mapping on obj,perc# - entities need to retain alpha
             endif
          endif
          inc ptr,4
          rem next reveal-obj
          inc o
         next tp
       endif
       `
      endif
     endif
    endif
   endif
   `
  next x
 next y
next ly

rem endif shroud exists
endif

rem create entity foating selection
if gridentity>0
 obj=objstart+o
 if object exist(obj)=1
`  position object obj,gridentityposx#,gridentityposy#+entityprofile(gridentity).offy,gridentityposz#
  position object obj,gridentityposx#,gridentityposy#,gridentityposz#
  rotate object obj,gridentityrotatex#,gridentityrotatey#,gridentityrotatez#
 endif
 inc o
endif

return

`
` SUPPORT SUBROUTINES FOR GRIDEDIT CODE
`

_gridedit_getmapvalues:
 `
 rem mapid in
 mapselection    = ( mapid && %11111111111100000000000000000000 ) >> 20
 mapscaler       = ( mapid && %00000000000011110000000000000000 ) >> 16
 mapground       = ( mapid && %00000000000000001100000000000000 ) >> 14
 maprotate       = ( mapid && %00000000000000000011000000000000 ) >> 12
 maporient       = ( mapid && %00000000000000000000110000000000 ) >> 10
 mapsymbol       = ( mapid && %00000000000000000000001111110000 ) >> 4
 maptile         = ( mapid && %00000000000000000000000000001111 )
 `
return


`
` SUBROUTINES FOR ARENA MODE TOGGLE
`

_arenamode_update:
 `
 rem In and Out of Arena Mode
 if gmultiplayergame=1
  rem toggle FPG to arena project
  if currentFPGtype=currentSMFPGtype
   currentFPGtype=currentAMFPGtype
   currentFPG$=currentAMFPG$
  endif
 else
  rem toggle FPG to singleplayer project
  if currentFPGtype=currentAMFPGtype
   currentFPGtype=currentSMFPGtype
   currentFPG$=currentSMFPG$
  endif
 endif
 `
return

`
` FUNCTION TO CHECK MAP DATA
`
function chkmapyes(l,x,y,ground)
 mapid = map(l,x,y)
 maptile = ( mapid && %00000000000000000000000000001111 )
 mapground = ( mapid && %00000000000000001100000000000000 ) >> 14
 if mapground<4 and mapground=ground
  if maptile>0 and maptile<16 then res=1 else res=0
 else
  res=0
 endif
endfunction res

function chkmapno(l,x,y,ground)
 mapid = map(l,x,y)
 maptile = ( mapid && %00000000000000000000000000001111 )
 mapground = ( mapid && %00000000000000001100000000000000 ) >> 14
 if mapground<4 and mapground=ground
  if maptile<=0 or maptile>=16 then res=1 else res=0
 else
  res=1
 endif
endfunction res

function getmapmask(l,x,y)
 tamask as DWORD
 mapid = map(l,x,y)
 maptile = ( mapid && %00000000000000000000000000001111 )
 maprotate = ( mapid && %00000000000000000011000000000000 ) >> 12
 tamask=makemaskfromtile(maptile,maprotate)
endfunction tamask

function makemaskfromtile(maptile,maprotate)
 rem create mask from current maptile (left,top,right,bottom)
 rem and the corner data (lefttop,righttop,rightbottom,leftbottom)
 tamask as DWORD
 tamask=%00000000
 if maprotate=0
  select maptile
   case  1 : tamask=%11110000 : endcase
   case  2 : tamask=%11010000 : endcase
   case  3 : tamask=%11000000 : endcase
   case  4 : tamask=%01010000 : endcase
   case  5 : tamask=%01000000 : endcase
   case  6 : tamask=%00000000 : endcase
   case  7 : tamask=%00001000 : endcase
   case  8 : tamask=%00001100 : endcase
   case  9 : tamask=%00001010 : endcase
   case 10 : tamask=%00001110 : endcase
   case 11 : tamask=%00001111 : endcase
   case 12 : tamask=%01000001 : endcase
   case 13 : tamask=%01000010 : endcase
   case 14 : tamask=%01000011 : endcase
   case 15 : tamask=%11000010 : endcase
  endselect
 endif
 if maprotate=1
  select maptile
   case  1 : tamask=%11110000 : endcase
   case  2 : tamask=%11100000 : endcase
   case  3 : tamask=%01100000 : endcase
   case  4 : tamask=%10100000 : endcase
   case  5 : tamask=%00100000 : endcase
   case  6 : tamask=%00000000 : endcase
   case  7 : tamask=%00000100 : endcase
   case  8 : tamask=%00000110 : endcase
   case  9 : tamask=%00000101 : endcase
   case 10 : tamask=%00000111 : endcase
   case 11 : tamask=%00001111 : endcase
   case 12 : tamask=%00101000 : endcase
   case 13 : tamask=%00100001 : endcase
   case 14 : tamask=%00101001 : endcase
   case 15 : tamask=%01100001 : endcase
  endselect
 endif
 if maprotate=2
  select maptile
   case  1 : tamask=%11110000 : endcase
   case  2 : tamask=%01110000 : endcase
   case  3 : tamask=%00110000 : endcase
   case  4 : tamask=%01010000 : endcase
   case  5 : tamask=%00010000 : endcase
   case  6 : tamask=%00000000 : endcase
   case  7 : tamask=%00000010 : endcase
   case  8 : tamask=%00000011 : endcase
   case  9 : tamask=%00001010 : endcase
   case 10 : tamask=%00001011 : endcase
   case 11 : tamask=%00001111 : endcase
   case 12 : tamask=%00010100 : endcase
   case 13 : tamask=%00011000 : endcase
   case 14 : tamask=%00011100 : endcase
   case 15 : tamask=%00111000 : endcase
  endselect
 endif
 if maprotate=3
  select maptile
   case  1 : tamask=%11110000 : endcase
   case  2 : tamask=%10110000 : endcase
   case  3 : tamask=%10010000 : endcase
   case  4 : tamask=%10100000 : endcase
   case  5 : tamask=%10000000 : endcase
   case  6 : tamask=%00000000 : endcase
   case  7 : tamask=%00000001 : endcase
   case  8 : tamask=%00001001 : endcase
   case  9 : tamask=%00000101 : endcase
   case 10 : tamask=%00001101 : endcase
   case 11 : tamask=%00001111 : endcase
   case 12 : tamask=%10000010 : endcase
   case 13 : tamask=%10000100 : endcase
   case 14 : tamask=%10000110 : endcase
   case 15 : tamask=%10010100 : endcase
  endselect
 endif
endfunction tamask

function getmapid(selection,scaler,ground,rotate,orient,symbol,side)
 mapid =         (selection << 20)
 mapid = mapid + (scaler << 16)
 mapid = mapid + (ground << 14)
 mapid = mapid + (rotate << 12)
 mapid = mapid + (orient << 10)
 mapid = mapid + (symbol << 4)
 mapid = mapid + (side)
endfunction mapid

function writemap(layer,mx,my,selection,scaler,ground,rotate,orient,symbol,side)
 mapid =         (selection << 20)
 mapid = mapid + (scaler << 16)
 mapid = mapid + (ground << 14)
 mapid = mapid + (rotate << 12)
 mapid = mapid + (orient << 10)
 mapid = mapid + (symbol << 4)
 mapid = mapid + (side)
 map(layer,mx,my)=mapid
endfunction

function writebuffermap(layer,mx,my,selection,scaler,ground,rotate,orient,symbol,side)
 mapid =         (selection << 20)
 mapid = mapid + (scaler << 16)
 mapid = mapid + (ground << 14)
 mapid = mapid + (rotate << 12)
 mapid = mapid + (orient << 10)
 mapid = mapid + (symbol << 4)
 mapid = mapid + (side)
 buffermap(layer,mx,my)=mapid
endfunction

`
` FUNCTION TO FIND ENTITY UNDER CURSOR
`
function findentitycursorobj()
 result=0 : tbesty#=-1.0
 for o=realviewobjectoffset+1 to realviewobjectoffsetend
  if object exist(o)=1
   if object visible(o)=1
    c=pick object(inputsys.xmouse,inputsys.ymouse,o,o)
    if c<>0
     tentitytoselect=findentityfromobj(o)
     if tentitytoselect>0
      ty#=entityelement(tentitytoselect).y
      if ty#>tbesty#
       tbesty#=ty# : result=tentitytoselect
      endif
     endif
    endif
   endif
  endif
 next o
endfunction result

`
` FUNCTION TO MODIFY OBJECT AT VERTEX LEVEL
`

function modifyplain(objno,bb)

rem Lock the vertex data of the object
lock vertexdata for limb objno,0

rem calcuate uv area
tv=bb/8 : tu=bb-(tv*8)
s#=1.0/8.0 : u#=s#*tu : v#=s#*tv

rem adjust position data
set vertexdata position 0,-50,-49, 50
set vertexdata position 1,-50,-49,-50
set vertexdata position 2, 50,-49, 50
set vertexdata position 3, 50,-49,-50

rem adjust normals data
set vertexdata normals 0,0,1,0
set vertexdata normals 1,0,1,0
set vertexdata normals 2,0,1,0
set vertexdata normals 3,0,1,0

rem adjust UV data
set vertexdata uv 0,u#,v#
set vertexdata uv 1,u#,v#+s#
set vertexdata uv 2,u#+s#,v#
set vertexdata uv 3,u#+s#,v#+s#

rem Unlock the vertex data of the object
unlock vertexdata

endfunction

function modifycube(objno,ff,bb,tt,mm,rr,ll)

rem Lock the vertex data of the object
lock vertexdata for limb objno,0

rem 0 front
rem 1 back
rem 2 top
rem 3 bottom
rem 4 right
rem 5 left
for p=0 to 5
 `
 rem define new normals
 if p=0 then nx=0 : ny=0 : nz=1
 if p=1 then nx=0 : ny=0 : nz=-1
 if p=2 then nx=0 : ny=1 : nz=0
 if p=3 then nx=0 : ny=1 : nz=0
 if p=4 then nx=-1 : ny=0 : nz=0
 if p=5 then nx=1 : ny=0 : nz=0
 `
 rem determine U/V flipping
 flip=0 : f=ff : b=bb : t=tt : m=mm : r=rr : l=ll
 if p=0 and ff>=100 then flip=1 : f=ff-100
 if p=1 and bb>=100 then flip=1 : b=bb-100
 if p=2 and tt>=100 then flip=1 : t=tt-100
 if p=3 and nm>=100 then flip=1 : m=mm-100
 if p=4 and rr>=100 then flip=1 : r=rr-100
 if p=5 and ll>=100 then flip=1 : l=ll-100
 `
 rem define area within texture
 if p=0 then tv=f/8 : tu=f-(tv*8)
 if p=1 then tv=b/8 : tu=b-(tv*8)
 if p=2 then tv=t/8 : tu=t-(tv*8)
 if p=3 then tv=m/8 : tu=m-(tv*8)
 if p=4 then tv=r/8 : tu=r-(tv*8)
 if p=5 then tv=l/8 : tu=l-(tv*8)
 `
 rem calcuate uv area
 s#=1.0/8.0 : u#=s#*tu : v#=s#*tv
 `
 rem adjust UV data
 if p=0
  if flip=0
   set vertexdata uv (p*4)+0,u#+s#,v#
   set vertexdata uv (p*4)+1,u#+s#,v#+s#
   set vertexdata uv (p*4)+2,u#,v#+s#
   set vertexdata uv (p*4)+3,u#,v#
  else
   set vertexdata uv (p*4)+0,u#+s#,v#+s#
   set vertexdata uv (p*4)+1,u#+s#,v#
   set vertexdata uv (p*4)+2,u#,v#
   set vertexdata uv (p*4)+3,u#,v#+s#
  endif
 endif
 if p=1
  if flip=0
   set vertexdata uv (p*4)+0,u#+s#,v#
   set vertexdata uv (p*4)+1,u#,v#
   set vertexdata uv (p*4)+2,u#,v#+s#
   set vertexdata uv (p*4)+3,u#+s#,v#+s#
  else
   set vertexdata uv (p*4)+0,u#+s#,v#+s#
   set vertexdata uv (p*4)+1,u#,v#+s#
   set vertexdata uv (p*4)+2,u#,v#
   set vertexdata uv (p*4)+3,u#+s#,v#
  endif
 endif
 if p=2
  set vertexdata uv (p*4)+0,u#,v#
  set vertexdata uv (p*4)+1,u#+s#,v#
  set vertexdata uv (p*4)+2,u#+s#,v#+s#
  set vertexdata uv (p*4)+3,u#,v#+s#
 endif
 if p=3
  set vertexdata uv (p*4)+0,u#,v#
  set vertexdata uv (p*4)+1,u#,v#+s#
  set vertexdata uv (p*4)+2,u#+s#,v#+s#
  set vertexdata uv (p*4)+3,u#+s#,v#
 endif
 if p=4
  if flip=0
   set vertexdata uv (p*4)+0,u#+s#,v#+s#
   set vertexdata uv (p*4)+1,u#+s#,v#
   set vertexdata uv (p*4)+2,u#,v#
   set vertexdata uv (p*4)+3,u#,v#+s#
  else
   set vertexdata uv (p*4)+0,u#+s#,v#
   set vertexdata uv (p*4)+1,u#+s#,v#+s#
   set vertexdata uv (p*4)+2,u#,v#+s#
   set vertexdata uv (p*4)+3,u#,v#
  endif
 endif
 if p=5
  if flip=0
   set vertexdata uv (p*4)+0,u#,v#+s#
   set vertexdata uv (p*4)+1,u#+s#,v#+s#
   set vertexdata uv (p*4)+2,u#+s#,v#
   set vertexdata uv (p*4)+3,u#,v#
  else
   set vertexdata uv (p*4)+0,u#,v#
   set vertexdata uv (p*4)+1,u#+s#,v#
   set vertexdata uv (p*4)+2,u#+s#,v#+s#
   set vertexdata uv (p*4)+3,u#,v#+s#
  endif
 endif
 `
 rem normals
 set vertexdata normals (p*4)+0,nx,ny,nz
 set vertexdata normals (p*4)+1,nx,ny,nz
 set vertexdata normals (p*4)+2,nx,ny,nz
 set vertexdata normals (p*4)+3,nx,ny,nz
 `
next p
`
rem Unlock the vertex data of the object
unlock vertexdata

endfunction

function modifyentity(objno,tex)

rem Smooth out mesh
set object smoothing objno,100

rem Lock the vertex data of the object
lock vertexdata for limb objno,0

rem define area within texture
tv=tex/8 : tu=tex-(tv*8)
s#=1.0/8.0 : u#=s#*tu : v#=s#*tv

rem adjust UV data
vmax=12*3
for t=0 to vmax-1
 set vertexdata uv t,u#+(s#/2.0),v#+(s#/2.0)
next t

vmax=11*3
for t=vmax to vmax+5
 set vertexdata position t,0,0,0
next t

rem Unlock the vertex data of the object
unlock vertexdata

endfunction

function modifyplaneimagestrip(objno,texmax,texindex)

rem Lock the vertex data of the object
lock vertexdata for limb objno,0

rem adjust UV data
s#=1.0/texmax : u#=texindex*s#
set vertexdata uv 0,u#+s#,0.0
set vertexdata uv 1,u#,0.0
set vertexdata uv 2,u#+s#,1.0
set vertexdata uv 3,u#,0.0
set vertexdata uv 4,u#,1.0
set vertexdata uv 5,u#+s#,1.0

rem Unlock the vertex data of the object
unlock vertexdata

endfunction

