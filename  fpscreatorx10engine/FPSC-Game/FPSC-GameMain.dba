rem
rem GAME MAIN
rem

rem Create controls for debug view
global gamedebugrefresh : gamedebugrefresh=0
global gamedebugviewtime : gamedebugviewtime=0
global gamedebugviewmem : gamedebugviewmem=GET MEMORY AVAILABLE(0)
global gamedebugviewlastmem : gamedebugviewlastmem=0
global gamedebugview$ : debugviewactivate(1)
global testgametabtoggle : testgametabtoggle=0
global debugviewmode
global debugviewtog

rem Set editor fonts and text style and size
set text font "Calibri"
ink rgb(255,255,255),0
set text size 16

rem Init app
sync on : sync rate 30 : autocam off : disable systemkeys
hide mouse : backdrop off : disable escapekey

rem X10 - 011107 - removed expiry now bETA test over
`rem X10 - 230907 - kill game exe if used beyond spiry date
`td$=get date$() : tm=val(left$(td$,2)) : ty=val(right$(td$,2))
`if ty<>7 or tm=12
` exit prompt "This BETA version expires after the 30th November 2007!","BETA Expired"
` end
`endif

rem If Game is NOT IN TEST MODE, default is full screen shown
if gtestgamemodefromeditor=0 and gcompilestandaloneexe=0
 `
 rem Show window
 timestampactivity(0,"Start Fullscreen")
 gosub _main_game_showwindownow
 `
 `rem If FREEWARE PROMPT tampered, exit (EA ONLY VERSION)
 `if grealgameviewstate=1
 ` filename$="languagebank\"+language$+"\gamecore\huds\freeware.jpg"
 ` fsize=file size(filename$)
 ` if fsize=47319
 `  load image filename$,1
 `  if image exist(1)=1
 `   delete image 1
 `  else
 `   fsize=0
 `  endif
 ` endif
 ` if fsize<>47319
 `  screenprompt(img,strarr$(121))
 `  timestampactivity(0,strarr$(122))
 `  sleep 5000
 `  end
 ` endif
 `endif
 `
 rem splash check at start for splash.jpg existence and size (alter proof)
 dosplashdelay=0 : gosub _version_dosplash
 `
 rem get the actual server IP for information purposes
 if gmultiplayergame=1
  `
  rem connection check and IP gathering
  show mouse
  `
  rem FPSCV105 - 090307 - check FIREWALL
  rem FPSCV105RC2 - 100307 - AND puts the actual HOSTable IP address in serveripaddress$
  gosub _ai_gamelist_checkforfirewall
  `
  rem FPSCV105RC3 - 140307 - also gather the local IP (in case they want a LAN game) ;localipaddress$;
  MULTIPLAYER CREATE TCP SERVER servername$
  localipaddress$=MULTIPLAYER GET IP ADDRESS()
  if left$(localipaddress$,8)<>"192.168." then localipaddress$=""
  for c=1 to len(serveripaddress$)
   if mid$(localipaddress$,c)=":" then localipaddress$=left$(localipaddress$,c-1) : exit
  next c
  MULTIPLAYER DISCONNECT
  `
  rem done with network stuff for now
  hide mouse
  `
 endif
 if image exist(1)=1
  for f=255 to 0 step -20
   cls 0 : set sprite alpha 1,f : sync
  next f
  set sprite alpha 1,0
  cls 0 : sync : cls 0 : sync
  delete sprite 1
  delete image 1
 endif
 `
endif

rem Reset file collector
resetfilecollection()

rem Add localisation text to final game
if gcompilestandaloneexe=1
 addfiletocollection("languagebank\"+language$+"\textfiles\fpsc-050.ini")
 addfiletocollection("languagebank\"+language$+"\textfiles\fpsc-050.txt")
endif

rem Add ODE licenses text files to final game
if gcompilestandaloneexe=1
 rem freeware splash for standalone executable
 gosub _version_includesplashfile
 addfiletocollection("License\LICENSE-BSD.TXT")
endif

rem Add SAVELOAD mandatory media
if gcompilestandaloneexe=1
 addfiletocollection("languagebank\"+language$+"\gamecore\huds\saveload\load-base.png")
 addfiletocollection("languagebank\"+language$+"\gamecore\huds\saveload\areyousure.png")
 addfiletocollection("languagebank\"+language$+"\gamecore\huds\saveload\save-base.png")
endif

rem Forced 'Shader Compatibility Warning' PROMPT
if gcompilestandaloneexe=1 or grealgameviewstate=1
 filename$="languagebank\"+language$+"\gamecore\huds\noshader.dds"
 img=loadinternalimagecompressquality(filename$,5,1)
endif
if grealgameviewstate=1
 tneed#=0.0
 if guseeffectstate=1
  tneed#=1.0
  if guseeffectonscenesstate=1
   tneed#=2.0
  endif
 endif
 tpsv#=get maximum pixel shader version()
 timestampactivity(0,"Shaders - Need:"+str$(tneed#)+" Got:"+str$(tpsv#))
 if tneed#>tpsv#
  screenprompt(img,strarr$(123))
 endif
endif

rem Run gameflow default screen path
timestampactivity(0,"Game Flow Started..")
gosub _gameflow_default

rem Export game as standalone if -B used
if gcompilestandaloneexe=1
 rem Generate unique code
 guniquegamecode$=genuniqueservercode(gbuildname$)
 rem Build Executable Game Mode
 gosub _main_game_buildexe
 rem close dialog (cannot reload data into it when RELOAD MAPEDITOR)
 open file map 1, "FPSBUILDGAME"
 set file map dword 1, 24, 1
 wait for file map event 1
 close file map 1
 rem call map editor back
 open file map 1, "FPSEXCHANGE"
 set file map string$ 1, 1000, "bin\FPSC-MapEditor.exe"
 set file map string$ 1, 1256, "-r"
 set file map dword 1, 994, 0
 set file map dword 1, 924, 1
 wait for file map event 1
 close file map 1
 rem FPSXV10X - time for CPU(FPSCreator.exe) to conduct filemap scan
 `if gexitpromptreportmodestate<>0
 ` backdrop off
 ` show window
 ` position camera 0,50000,0
 ` while shiftkey()=0
 `  cls 0
 `  ink rgb(rnd(255),rnd(255),rnd(255)),0
 `  center text screen width()/2,(screen height()/2)-20,"USE 'FPSCREATORDUMPMEM.EXE' NOW!"
 `  center text screen width()/2,(screen height()/2)+00,"USE PROCESS VIEW TO SEE IF FPSC-MAPEDITOR.EXE APPEARS (give it one minute)"
 `  center text screen width()/2,(screen height()/2)+20,"PRESS SHIFT WHEN TESTS COMPLETE"
 `  sleep 1
 `  sync
 ` endwhile
 `endif
endif

rem If Game is NOT IN TEST MODE, show end splash for final executable
if gtestgamemodefromeditor=0 and gcompilestandaloneexe=0
 dosplashdelay=3000 : gosub _version_dosplash
endif

rem End executable
if gexitpromptreportmodestate<>0 then exit prompt "Terminated Game Exe","FPSCV10X Debug Report"
timestampactivity(0,strarr$(125))
end

`
` EXE Building Subroutines
`

_main_game_buildexe:
 `
 rem Version control on EXE Building
 gosub _version_main_game_buildexe
 `
return

`
` MAIN GAME SUBROUTINES
`

_main_game_loadgamedata:
 `
 rem Display game loading/creating-game backdrop
 if gdebugreportmodestate=1
  if gtestgamemodefromeditor=0
   for s=0 to 1
    cls rgb(255,255,0)
    ink rgb(0,0,255),0 : center text screen width()/2,screen height()/2,"DEBUG REPORT MODE ACTIVE"
    ink rgb(255,255,255),0
    sync
   next s
  endif
 endif
 debugviewprogressmax(330)
 `
 rem Place camera faw away (effectively hide all 3D)
 realrange#=9000.0
 set camera range 2.0,realrange#
 position camera 0,-50000,50000,50000
 point camera 0,-50000,50010,50000
 `
 rem Load segment banks
 segobjusedforfinalgame=1 : segnoeffects=gsegnoeffectstate
 `
 rem Load AI Scripts (can be done in elements process-only load as needed)
 debugviewtext(30,strarr$(126)) : gosub _ai_loadallscripts
 debugviewtext(60,strarr$(127)) : gosub _decal_init
 if gmultiplayergame=0 then debugviewtext(70,strarr$(128)) : gosub _flak_init
 debugviewtext(75,strarr$(129)) : gosub _gun_init
 debugviewtext(80,strarr$(130)) : gosub _gun_setup
 `
return

_main_game_freeleveldata:
 `
 rem only for final game run ( not test game ) - uses leavegamedataalone in last part
 if grealgameviewstate=1 or gcompilestandaloneexe=1
  `
  rem X10 certain entity free-ups required
  for e=1 to entityelementlist
   if entityelement(e).firesoundloop>0
    if sound exist(entityelement(e).firesoundloop)=1
     stop sound entityelement(e).firesoundloop
    endif
    entityelement(e).firesoundloop=0
   endif
  next e
  `
  rem X10 free AI resouces
  gosub _aiss_free
  `
  rem X10 end camera sync sequence
  if gcompilestandaloneexe=0
   gosub _sync_deletecameras
  endif
  `
  rem Free multiplayer resources
  gosub _multi_free
  `
  rem Free fragments
  if gmultiplayergame=0 then gosub _part_free
  `
  rem Free the old gun
  gosub _gun_freeafterlevel
  `
  rem Place camera faw away (effectively hide all 3D)
  position camera 0,-50000,50000,50000
  point camera 0,-50000,50010,50000
  `
  rem Remove universe (so camera can reset to no-3D-view)
  gosub _universe_destruct
  `
  rem Physics cleanup
  gosub _physics_cleanup
  `
  rem X10 - 041007 - free entities (objects, shadows and physics ties)
  rem Delete ALL game objects
  delete objects entityattachmentsoffset,66635
  entityprofileslotclonestart=entityprofileslotclonestartmaster
  `
  rem Remove all images
  deleteallinternalimages()
  `
  rem FREE REST OF GAME RESOURCES
  for p=1 to 65535 : if particles exist(p)=1 : delete particles p : endif : next p
  for e=1 to 65535 : if effect exist(e)=1 : delete effect e : endif : next e
  for s=1 to 65535 : if sound exist(s)=1 : delete sound s : endif : next s
  delete objects 1,endofallobjectsoffset
  `
  rem FREE ANY DATA
  undim undoredolist()
  undim meshbank$()
  undim texturebank$()
  undim effectbank$()
  undim soundbank$()
  undim prefabbank$()
  undim selectionbank$()
  undim entitybank$()
  undim gunbank$()
  undim muzzlebank$()
  undim brassbank$()
  undim smokebank$()
  undim flakbank$()
  undim decalbank$()
  undim imagebank$()
  undim segmentprofileheader()
  undim segmentprofile()
  undim map()
  undim viscolmap()
  undim lighttable()
  undim refmap()
  undim mapolay()
  undim olaylist()
  undim mapentries()
  undim mastermesh()
  undim entitybodypart()
  undim entityanim()
  undim entityprofileheader()
  undim entityprofile()
  undim entityelement()
  undim entityelementwhichslot()
  undim entityelementusingode()
  undim entityelementwhichobj()
  undim entityelementtexarrayindex()
  undim entityelementusingrefraction()
  undim entitydebug$()
  undim aiactionseq()
  undim aiaction()
  undim aiconditionseq()
  undim aicond()
  undim ailist()
  undim waypointcoord()
  undim waypoint()
  undim debris()
  undim gun()
  undim gunsound()
  undim gunsoundcompanion()
  undim gunsounditem()
  undim flak()
  undim flakelement()
  undim decal()
  undim decalelement()
  undim player()
  undim playersound()
  undim playerinventory()
  undim infinilight()
  undim infinilightshortlist()
  undim shadowlight()
  undim hud()
  `
  rem Ensure loader HUD is not used if resources removed
  internalloaderhud=0
  `
  rem Special exception as only arrays that need carrying to new levels
  if leavegamedataalone=0
   undim scriptbank$()
   undim weaponslot()
   undim weaponammo()
   undim weaponclipammo()
  endif
  undim weaponhud()
  `
  rem Recreate all data for new level (uses leavegamedataalone)
  gosub _FPSC_Full_Data_Init
  `
 endif
 `
return

_main_game_core:
 `
 rem Transition
 if gamewarmupcount=0
  if gametransitionscreen=1
   dec gametransitionscreencount,30
   if gametransitionscreencount<=0
    set camera view 0,0,0,screen width(),screen height()
    gametransitionscreen=0 : gametransitionscreencount=0
    rem Handle Hosting/Joining (multiplayer) when 3D starts
    if gmultiplayergame=1 and multiplayerinitialised=0 then gosub _multi_start
   else
    if gametransitionscreencount<(screen height()/2)-30
     position camera playercam,lastcamx#,lastcamy#,lastcamz#
     color backdrop rgb(0,0,64)
    endif
    set camera view 0,0,gametransitionscreencount,screen width(),gametransitionscreencount+(screen height()-(gametransitionscreencount*2))
   endif
  endif
 else
  rem the warmup allows decals to form, player start gravity to settle, etc
  cls 0 : dec gamewarmupcount : if gamewarmupcount<0 then gamewarmupcount=0
  if gamewarmupcount=0
   rem warm-up over, clear mouse deltas
   cleardelta=mousemovex() : cleardelta=mousemovey()
   rem start physics gravity now
   gosub _physics_startgravityafterwarmup
   rem record time at startup (used in AI to allow plrtriggers after 1 second)
   gamewarmupstarttime=timer()
  endif
 endif
 `
 rem Sky stays with camera
 gosub _sky_positionsky
 `
 rem Control main game
 gosub _main_game_corecontrol
 `
 rem Get time from last sample to SYNC command (rest)
 inc gameperfresttosync, perftimer()-gameperftimestamp
 gameperftimestamp=perftimer()
 `
 rem Update physics
 gosub _physics_update
 `
 rem Count physics time
 inc gameperfphysics, perftimer()-gameperftimestamp
 gameperftimestamp=perftimer()
 `
 rem Measure overall performance counts
 inc gameperftotalcount, perftimer()-gameperftotalcountTOP
 gameperftotalcountTOP=perftimer()
 `
 rem Parent Slot management readout debug
 if 0
  set cursor 0,0
  print "parent slots debug"
  for s=0 to entityprofileslotclonequantity-1
   print s;"s=";entityprofileslot(s);" ref=";entityprofileslotref(s)
  next s
  if noslots=1
   print "no more slots available"
  endif
 endif
 `
 rem AI Update
 AI Update
 gameperfai=gameperfai+(perftimer()-gameperftimestamp)
 gameperftimestamp=perftimer() 
 `
 rem X9 Update screen sync
 rem X10 sync sequence control (bloom, reflection, refract, etc)
 gosub _sync_sequence
 `
 rem Sync Performance check
 gameperfsync=gameperfsync+(perftimer()-gameperftimestamp)
 gameperftimestamp=perftimer()
 gamedebugviewtime=timer()
 `
 rem Exit Conditions for test game
 if grealgameviewstate=0
  if escapekey()=1 then continueokay=1 : levelwon=2 : rem QUIT
 endif
 `
 rem Logo compliance
 if terminate()=1 then continueokay=1 : levelwon=2 : rem TERMINATE - RESTART MANAGER
 `
return



rem
rem LEES Game Runner Code
rem

_load_game_scene:

rem Loading Screen
if gdebugreportmodestate=0 then set camera view 0,0,0,1,1

rem Direct to realgame or testgame
if grealgameviewstate=1
 `
 rem Set realgame level path
 levelmapptah$=myownrootdir$+"levelbank\testlevel\"
 `
 rem load the FPL file which populates testlevel for current level to play (level var)
 gosub _mapfile_load_fpl
 `
else
 `
 rem During test map this path can be used (map edit files)
 levelmapptah$=myownrootdir$+"mapbank\testmap\"
 `
 rem Load the FPM data to mapbank\testmap (level var)
 if gcompilestandaloneexe=1
  gosub _mapfile_loadgamemap_fpm
  elementsfilename$=""
 endif
 `
endif

rem Free any old player resources
debugviewtext(120,strarr$(131)) : gosub _player_free
debugviewtext(120,strarr$(131)) : gosub _particles_free

rem Flush video for new graphics usages
debugviewtext(130,strarr$(132)) : flush video memory

rem Free old resources first
debugviewtext(140,strarr$(133)) : gosub _entity_deleteelements

rem Load waypoints
if gshowdebugtextingamestate=0 then gdontcreatewaypointobjects=1
debugviewtext(150,strarr$(134)) : gosub _waypoint_loaddata
if gshowdebugtextingamestate=1 then gosub _waypoint_createallobjs

rem Ensure segments are loaded (not for final game though - universe dbo does this)
if grealgameviewstate=0 then debugviewtext(160,strarr$(135)) : gosub _segment_loadbank

rem Ensure segments and entities are up to date
debugviewtext(170,strarr$(136)) : gosub _entity_loadbank

rem Load individual-elements
debugviewtext(180,strarr$(137)) : gosub _entity_loadelementsdata
debugviewtext(185,strarr$(137)) : gosub _entity_switchtostaticformultiplayer

rem 290607 - AI inits here just before 'static entities' are added as AI obstacle
gosub _aiss_init

rem Load map (with any segment entitiy-elements)
debugviewtext(200,strarr$(138)) : gosub _game_loadmap

rem Finally create and attach elements to map
debugviewtext(299,strarr$(626)) : gosub _particles_init
if gmultiplayergame=0 then debugviewtext(299,strarr$(626)) : gosub _part_init
debugviewtext(300,strarr$(139)) : gosub _entity_createelements
debugviewtext(310,strarr$(140)) : gosub _entity_attachelementstogame
debugviewtext(311,strarr$(141)) : gosub _ai_createentityreferences

rem Load material list and sounds
debugviewtext(312,strarr$(142)) : gosub _physics_loadmateriallist

rem Entities can intropduce fake players, init all
debugviewtext(312,strarr$(142)) : gosub _player_startgun
debugviewtext(313,strarr$(143)) : gosub _gun_loadonlypresent
debugviewtext(313,strarr$(143)) : gosub _flak_loadonlypresent
debugviewtext(314,strarr$(144)) : gosub _decal_loadonlyactivedecals
debugviewtext(314,strarr$(144)) : gosub _muzzle_createall

rem Entities can intropduce fake players, init all
debugviewtext(318,strarr$(145)) : gosub _player_init : gosub _player_resetobjectives
debugviewtext(320,strarr$(146)) : gosub _entity_startentitiesoff

rem X10 start camera sync sequence
gosub _sync_createcameras

rem Okay for start of game, can skip for exe construction
if gcompilestandaloneexe=1
 `
 rem 240907 - these two are called insied universe_construct just before zip is built! 
 `gosub _aiss_setup : gosub _aiss_free
 `
else
 `
 rem Physics init of universe and entities (321,322,323)
 debugviewtext(321,strarr$(627)) : gosub _physics_init
 `
 rem Setup camera (player)
 debugviewtext(324,strarr$(628)) : gosub _player_setup
 `
 rem X10 AI Call after assets loaded, before game starts
 gosub _aiss_setup
 prepareentitiesmode=0 : gosub _aiss_prepareentities
 `
 rem Reset multiplayer state (multiplayer)
 if gmultiplayergame=1
  gosub _multi_restartprepare
  multiplayerinitialised=0
 endif
 `
 rem Starting main loop
 debugviewtext(329,strarr$(629))
 `
endif

rem TestGameFromEditor Mode
if gtestgamemodefromeditor=1
 `
 rem Activate OK button
 open file map 1, "FPSTESTGAMEDIALOG"
 set file map dword 1, 12, 1
 set file map string$ 1, 1000, strarr$(147)
 set file map dword 1, 8, 100
 wait for file map event 1
 close file map 1
 while 1
  open file map 1, "FPSEXCHANGE"
  wait for file map event 1
  rem Wait for Test Game Dialog OK button pressed
  if get file map dword( 1, 974 ) = 1 then exit
  if get file map dword( 1, 994 ) = 1
   rem terminate test game mid-build
   set file map string$ 1, 1000, "bin\FPSC-MapEditor.exe"
   set file map string$ 1, 1256, "-r"
   set file map dword 1, 994, 2
   set file map dword 1, 924, 1
   wait for file map event 1
   close file map 1
   rem Terminate
   end
  else
   close file map 1
  endif
  sync
 endwhile
 close file map 1
 `
 rem make sure the cancel code is not detected for anymore in debug function
 gtestgamemodefromeditorokaypressed=1
 `
 rem Version Control - possible logo use
 gosub _version_onscreenlogos
 `
 rem Show Test Game Window
 gosub _main_game_showwindownow
 `
endif

rem Sample transition IN
gametransitionscreen=1 : gametransitionscreencount=600/2

return

_main_game_showwindownow:
 window to back
 set window layout 0,0,0
 sleep 100
 window to front "FPSC Game"
 show window
 maximize window
return

_main_game_corecontrol:

rem Stamp time for performance meter
if showgamemenu=0
 if debugviewmode=0
  rem X10 also uses mouse when in TAB debug X10 effecte menu 'debugviewmode'
  position mouse screen width()/2,screen height()/2
 endif
endif

rem STATUS AND HUD GRAPHICS
if gamewarmupcount=0
 gosub _screen_control
endif

rem X10 - 240907 - calculate a constant global time for pacing by timer, not counter
timebasepercycle#=(1.0/30.0)*(timer()-timebasepercyclestamp) : timebasepercyclestamp=timer()

rem FPSCV104RC4 - i want to see this
`if grealgameviewstate=0
if gdebugreportmodestate=1 or grealgameviewstate=0
 `
 rem Debug info
 debuggameoverlaysystem(0)
 inc gameperfdebug, perftimer()-gameperftimestamp
 gameperftimestamp=perftimer()
 `
else
 `
 rem X10 handles effects in here (when flag set to 1 we ignore profiling)
 debuggameoverlaysystem(1)
 `
 rem Ingame debug FPS
 if keystate(15)=0 then keystate15pressed=0
 if keystate(15)=1 and keystate15pressed=0
  inc showfpsinrealgame
  if ggodmodestate=0
   if showfpsinrealgame>1 then showfpsinrealgame=0
  else
   if showfpsinrealgame>2 then showfpsinrealgame=0
  endif
  keystate15pressed=1
 endif
 if showfpsinrealgame=1 then set cursor 0,0 : print screen fps()
 `
 rem suicide key
 if gmultiplayergame=1
  if lower$(inkey$())="i" and gtalkytoaster=0
   tdamage=10 : e=characterchoiceentityindex(iLocalEL)
   if entityelement(e).health>0
    gosub _multi_dealentityedamage
   endif
  endif
 endif
 `
 rem Talk system
 if gmultiplayergame=1
  tylinevalue=screen height()-20
  if lower$(inkey$())="t" and gtalkytoaster=0
   gtalkytoaster=1 : clear entry buffer
  endif
  if gtalkytoaster=1
   set cursor 0,tylinevalue
   print "TALK>";entry$();
  endif
  if returnkey()=1 and gtalkytoaster=1
   rem send message to all
   gtalkytoaster=0
   tmessage$=entry$()
   MULTIPLAYER SEND FROM PLAYER dwLocalPlayerID
   MULTIPLAYER SEND MESSAGE STRING ">>"+tmessage$,0x0080
   clear entry buffer
   rem see own message (only if server)
   if createorjoin=1
    talkscript$(talkindex)=">>"+tmessage$
    talkscriptcount(talkindex)=200
    talkscriptwho(talkindex)=iLocalEL
    inc talkindex : if talkindex>10 then talkindex=0
   endif
  endif
 endif
 `
 rem Ingame debug SPEEDTESTS
 if showfpsinrealgame=2
  rem multiplayer data
  if gmultiplayergame=1
   if timer()-totalbytestime>1000
    totalbytestime=timer()
    totalguarenteedbytes=guarenteedbytes
    totalunreliablebytes=unreliablebytes
    guarenteedbytes=0
    unreliablebytes=0
   endif
   tt$="GD="+str$(totalguarenteedbytes)
   text (screen width()/2)-75,screen height()-80,tt$
   tt$="UD="+str$(totalunreliablebytes)
   text (screen width()/2)+00,screen height()-80,tt$
   tt$="QUEUE="+str$(multiplayer get queue size(0))+","+str$(multiplayer get queue size(1))
   text (screen width()/2)+75,screen height()-80,tt$
  endif
  rem regular stats
  debugviewmode=0
  debuggameoverlaysystem(0)
  inc gameperfdebug, perftimer()-gameperftimestamp
  gameperftimestamp=perftimer()
 endif
 `
endif

rem Dynamic lighting control
gosub _lighting_ambientcontrol
if (gdynamiclightingstate=1 and lightingsystemdisabled=0) or forceambientlightsetting>0
 gosub _lighting_control
 gosub _lighting_managedynamiclights
 rem the following three are not required in X10
 `gosub _lighting_managegloballighting
 `gosub _lighting_applyplayerlighting
 `gosub _lighting_applytoscene
endif
gosub _lighting_controlupdate
inc gameperflighting, perftimer()-gameperftimestamp
gameperftimestamp=perftimer()

rem Game Active
if gamewarmupcount=0
 `
 rem Skip input (if not multiplayer ready or talkmode on)
 tokay=1
 if gmultiplayergame=1 and PlayerCanStart=0 then tokay=0
 if gtalkytoaster=1 then tokay=0
 if tokay=1
  `
  rem Player management
  gosub _player_input
  gosub _player_manager
  gosub _player_itemmanager
  gosub _player_mission
  `
  rem The Player Camera
  gosub _player_camera
  gosub _gun_update_hud
  `
 endif
 `
endif

rem X10 new water control
gosub _sync_controlwater

rem Measure plr calcs time
inc gameperfplayer, perftimer()-gameperftimestamp
gameperftimestamp=perftimer()

rem Entity Control Handling Here
gosub _entity_controlelements
gosub _muzzle_control
inc gameperfentities, perftimer()-gameperftimestamp
gameperftimestamp=perftimer()

rem X10 AI control of entities
`gosub _aiss_control `moved to controlelements

rem X10 AI Control Player and Team controls
gosub _aiss_playercontrol

rem Control multiplayer communicaions (multiplayer)
if gmultiplayergame=1 and multiplayerinitialised=1 and multiplayersystemdisabled=0
 gosub _multi_control
endif

rem Game Active
if gamewarmupcount=0
 `
 rem After AutoCol (after plr move and entity push-back, use autocol so stay in walls)
 gosub _physics_playeraftermove
 gosub _physics_playerpickup
 `
 rem The Gun Manager after new camera pos/rot
 gosub _gun_manager
 inc gameperfgun, perftimer()-gameperftimestamp
 gameperftimestamp=perftimer()
 `
endif

rem Flak in-game handling
gosub _particles_control
if gmultiplayergame=0 then gosub _flakelement_control
if supportsystemdisabled=0
 gosub _decalelement_control
endif
gosub _part_controlexploders
gosub _gun_update_overlay
inc gameperfmisc, perftimer()-gameperftimestamp
gameperftimestamp=perftimer()

return

function screenprompt(img,desc$)
 backdrop off : position camera 0,-50000,-50000,-50000 : point camera 0,-550000,-550000,-550000
 ink rgb(255,255,255),0 : set text font "Verdana" : set text size 24
 cls 0 : sync : cls 0 : sync
 for s=1 to 20
  center text screen width()/2,(screen height()/2)-16,desc$
  if img>0
   if image exist(img)=1
    paste image img,(screen width()-512)/2,(screen height()-384)/2
   endif
  endif
  sync : sleep 200
 next s
endfunction

function timestampactivity(i,desc$)
 if gproducelogfiles=1
  if i=0
   inc timestampactivityindex
   timestampactivityflagged=1
   i=timestampactivityindex
  else
   timestampactivityindex=i
  endif
  if i>timestampactivitymax
   timestampactivitymax=i
  endif
  dim timestampactivity$(timestampactivitymax)
  timestampactivity$(i)=str$(timer())+" : "+desc$
  file$="..\FPSC-Game.log" : if file exist(file$)=1 then delete file file$
  open to write 1,file$
   for t=1 to timestampactivitymax
    write string 1,timestampactivity$(t)
   next t
  close file 1
 endif
endfunction

rem Function to use anywhere
function genuniqueservercode(name$)
 date$=get date$()
 time$=get time$()
 code$=""
 for index=0 to 10
  ci1=index mod len(name$) : c1$=mid$(name$,1+ci1) : if c1$="," then c1$="."
  ci2=index mod len(date$) : c2$=mid$(date$,1+ci2) : if c2$="," then c2$="."
  ci3=index mod len(time$) : c3$=mid$(time$,1+ci3) : if c3$="," then c3$="."
  code$=code$+c1$+c2$+c3$
 next index
 code$=right$(code$,32)
endfunction code$

`
` TO resolve share issue with new version attachment
`

_interface_openbuildgame:
_interface_handlebuildgame:
_interface_closebuildgame:
return

`
` X10 SYNC SEQUENCE CONTROL
`

_sync_createcameras:
 `
 rem Default master camera
 cammainscene=5
 `
 rem create cameras (need to have them all created so render chain still works - bug?)
 dim camname$(15)
 rem refract/reflect/shadow
 makecamera(1,"REDUNDANT",0,screen width(),screen height(),"",0,0,0,0,1,0)
 makecamera(4,"reflect scene 3D",0,screen width(),screen height(),"",0,0,0,0,2,0)
 makecamera(5,"game with water 3D",0,screen width(),screen height(),"",0,0,0,0,0,1)
 makecamera(2,"shadow scene 3D",0,screen width(),screen height(),"",0,0,0,5,0,0)
 makecamera(3,"soft shadow QUAD",1,screen width()/2,screen height()/2,"blur10.fx",2,0,0,0,0,0)
 rem bloom chain
 makecamera(8,"bloom downsize 1 QUAD",1,screen width()/2,screen height()/2,"bloomtone10.fx",cammainscene,0,0,0,0,0)
 makecamera(6,"bloom downsize 2 QUAD",1,screen width()/4,screen height()/4,"bloomtone10.fx",8,0,0,0,0,0)
 makecamera(9,"bloom blur QUAD",1,screen width()/8,screen height()/8,"bloomblurH10.fx",6,0,0,0,0,0)
 makecamera(7,"bloom blur QUAD",1,screen width()/8,screen height()/8,"bloomblurV10.fx",9,0,0,0,0,0)
 rem final render 
 makecamera(0,"backbuffer QUAD",1,screen width(),screen height(),"finalrender10.fx",cammainscene,7,3,0,0,0)
 rem image render targets
 copy camera to image 5,19876 : rem initialise (for texture commands below)
 copy camera to image 5,19877 : rem initialise (for texture commands below)
 `
 rem Set flags
 if camera exist(2)=0 then gpuload2=1
 if camera exist(3)=0 then gpuload3=1
 if camera exist(4)=0 then gpuload4=1
 if camera exist(5)=0 then gpuload5=1
 if camera exist(6)=0 then gpuload6=1
 if camera exist(7)=0 then gpuload7=1
 `
 rem align FOV and RANGE to all sync cameras
 if camera exist(1)=1 then set camera fov 1,75.0 : set camera aspect 1,gdisplayratio#
 if camera exist(2)=1 then set camera fov 2,75.0 : set camera aspect 2,gdisplayratio#
 if camera exist(4)=1 then set camera fov 4,75.0 : set camera aspect 4,gdisplayratio#
 if camera exist(5)=1 then set camera fov 5,75.0 : set camera aspect 5,gdisplayratio#
 realrange#=9000.0
 if camera exist(1)=1 then set camera range 1,2.0,realrange#
 if camera exist(2)=1 then set camera range 2,2.0,realrange#
 if camera exist(4)=1 then set camera range 4,2.0,realrange#
 if camera exist(5)=1 then set camera range 5,2.0,realrange# 
 `
 rem default water position
 if gdefaultwaterlevelstate=1
  `waterlevel#=515.0 `260907 - move water below default layer floor
  waterlevel#=490.0
 else
  waterlevel#=-50000.0
 endif
 waterisbelowplayer=1
 `
 rem Trigger calc on whether player above or below water
 tchangethewaterclipping=2
 `
 rem setup basic defaults (before we change X10 shader effects)
 if gpuload4=0
  if camera exist(4)=1 then set camera clip 4,2,0,waterlevel#+1,0,0,1,0
 else
  if camera exist(4)=1 then set camera clip 4,0,0,0,0,0,0,0
 endif
 `
 rem water plane (we can have one for each water zone)
 `x10-021107 - if gpuload3=0 or gpuload4=0
 obj=11 : watereffectid=11
 make object plain obj,80*100,80*100
 position object obj,0,waterlevel#,0
 scale object texture obj,80,80
 set object mask obj,%100000,%0,%0
 xrotate object obj,90
 set object cull obj,0
 dirbefore$=get dir$() : set dir commoneffects$
 tfile$="basepool.fx" : addfiletocollection(commoneffects$+tfile$)
 tfile$="Water10.fx" : addfiletocollection(commoneffects$+tfile$)
 load effect tfile$,watereffectid,0
 tfile$="Water_N.dds" : addfiletocollection(commoneffects$+tfile$)
 load image tfile$,obj
 set dir dirbefore$
 texture object obj,0,obj
 texture object obj,1,19876 : rem from IMAGE 19876 refraction source
 texture object obj,2,4
 set object effect obj,watereffectid
 set effect technique watereffectid,"DrawRefractReflect"
 `endif
 `
 rem apply camera source to refractive entities
 for entid=1 to entidmastermax
  entobj=entitybankoffset+entid
  if object exist(entobj)=1
   if right$(lower$(entityprofile(entid).effect$),10)="cubeent.fx"
    texture object entobj,2,19877 : rem from IMAGE 19877 refraction source
   endif
  endif
 next entid
 `
 rem set main camera
 playercam=5 : set current camera playercam
 `
return

_sync_controlwater:
 `
 rem X10 - 031107 - if flag is off
 if gdefaultwaterlevelstate=0
  rem ignore all water level code and remove it
  waterlevel#=-50000.0
 endif 
 `
 rem water level
 position object 11,0,waterlevel#,0
 `
 rem water transition
 if camera position y(playercam)>waterlevel#+1.0
  if waterisbelowplayer=2
   rem player is above water
   waterisbelowplayer=1
   r=make vector4(1) : set vector4 1, 0.0, 0.0, 0.0, 0
   set effect constant vector 6,"g_fBloomColor",1 : r=delete vector4(1)
   rem leave water sound
   if watertransitionbyrestart=0
    rem only if did no during game, not through restart transition 
    playinternal3dsound(playersound(1,17),camera position x(playercam),camera position y(playercam),camera position z(playercam))
    rem also play gasp sound if in water for too long
    if timer()-wateroccupiedtimer>4000
     playinternal3dsound(playersound(1,19),camera position x(playercam),camera position y(playercam),camera position z(playercam))
     set sound volume playersound(1,19),soundvolumes(0)
    endif
   endif
   rem stop underwater atmos sound
   if waterunderwatersoundid>0 then stopsound(waterunderwatersoundid)
   rem subdued sound back to normal
   `tmp#=25.0 : tmp#=tmp#/100.0 : scale listener tmp#
   rem normal camera clip
   tcameraclippingmode=1 : tchangethewaterclipping=1
   rem refresh fog and bloom settings (aided in debug by waterisbelowplayer-1)
   hudupdateeffects=1 : rem tupdatefog=1 : tupdatebloom=1
   rem flags
   triggersplash=2
  endif
 endif
 if camera position y(playercam)<waterlevel#-1.0
  if waterisbelowplayer=1
   rem player is underwater
   waterisbelowplayer=2
   rem subdued sound
   `tmp#=5.0 : tmp#=tmp#/100.0 : scale listener tmp#
   rem enter water sound
   if watertransitionbyrestart=0
    rem only if did no during game, not through restart transition 
    playinternal3dsound(playersound(1,18),camera position x(playercam),camera position y(playercam),camera position z(playercam))
   endif
   rem loop underwater atmos sound
   if waterunderwatersoundid>0 then loopsound(waterunderwatersoundid)
   rem reverse camera clip
   tcameraclippingmode=2 : tchangethewaterclipping=1
   rem start timer on how long in water
   wateroccupiedtimer=timer()
   rem refresh fog and bloom settings (aided in debug by waterisbelowplayer-1)
   hudupdateeffects=1 : rem tupdatefog=1 : tupdatebloom=1
   rem flags
   triggersplash=1
  endif
  rem change bloom tint color if in water
  fullyinwater#=0.53
  if camera position y(playercam)>waterlevel#-50.0
   perc#=abs(waterlevel#-camera position y(playercam))/50.0
   fullyinwater#=0.2+(perc#/3.0)
  endif
  r=make vector4(1)
  set vector4 1,(rgbr(hudunderwatercolor)/255.0)*fullyinwater#,(rgbg(hudunderwatercolor)/255.0)*fullyinwater#,(rgbb(hudunderwatercolor)/255.0)*fullyinwater#,1
  set effect constant vector 6,"g_fBloomColor",1
  r=delete vector4(1)
 endif
 `
 rem Reset this value when reach this subroutine
 watertransitionbyrestart=0
 `
 rem X10 trigger some ripples using the decal system
 if waterdecalripple>0
  ripplex=camera position x(playercam)+rnd(4)-2
  ripplez=camera position z(playercam)+rnd(4)-2
  if (plrkeyC)=1
   rem crouch causes ripples in water
   theightofplrcamforripple#=22.0
  else
   rem waling in water causes ripples
   theightofplrcamforripple#=57.0
  endif
  if camera position y(playercam)<waterlevel#+theightofplrcamforripple# and camera position y(playercam)>waterlevel# 
   if abs(lastripplex-ripplex)>5 or abs(lastripplez-ripplez)>5
    lastripplex=ripplex : lastripplez=ripplez
    ripplequantity=70
   else
    ripplequantity=5000
   endif
   if timer()-rippleplayermakes>ripplequantity
    rippleplayermakes=timer()
    decalid=waterdecalripple
    decalorient=0
    decalx=ripplex
    decaly=waterlevel#+1.0
    decalz=ripplez
    decalorient=2
    decalscalemodx=50 : decalscalemody=decalscalemodx
    decalalpha=25
    originatore=0 : gosub _decalelement_create
   endif 
  endif
 endif
 `
 rem X10 water splash
 if splashdecalid>0 and triggersplash<>0
  if timer()-splashsplash>500
   splashsplash=timer()
   decalid=splashdecalid
   decalorient=0
   if triggersplash=2
    decalx=newxvalue(camera position x(playercam),camera angle y(playercam),40.0)
    decalz=newzvalue(camera position z(playercam),camera angle y(playercam),40.0)
    decaly=waterlevel#-50.0
    decalscalemodx=50
   else
    decalx=camera position x(playercam)
    decalz=camera position z(playercam)
    decaly=waterlevel#
    decalscalemodx=100
   endif
   decalscalemody=decalscalemodx
   decalalpha=100
   originatore=0 : gosub _decalelement_create
  endif 
  triggersplash=0
 endif
 `
 rem If remotely trigger clipping update (ie form X10 effect menu)
 if tchangethewaterclipping=2
  if camera position y(playercam)>waterlevel#
   tcameraclippingmode=1
  else
   tcameraclippingmode=2
  endif
  tchangethewaterclipping=1
 endif
 `
 rem X10 refraction used by windows
 if grefractionelementused=1
  glastrefractionelementused=grefractionelementused
  tchangethewaterclipping=1
 endif
 `
 rem Set new water clipping level
 if tchangethewaterclipping=1
  tchangethewaterclipping=0
  `if grefractionelementused=1
  ` if gpuload5=0
  `  if camera exist(1)=1 then set camera clip 1,1,0,100000,0,0,-1,0
  ` endif
  `else
  ` if tcameraclippingmode=1
  `  if gpuload5=0
  `   if camera exist(1)=1 then set camera clip 1,1,0,waterlevel#+4,0,0,-1,0
  `  endif
  ` endif
  `` if tcameraclippingmode=2
  `  if gpuload5=0
  `   if camera exist(1)=1 then set camera clip 1,1,0,waterlevel#-4,0,0,1,0
  `  endif
  ` endif
  `endif
  if tcameraclippingmode=1
   if gpuload4=0
    if camera exist(4)=1 then set camera clip 4,2,0,waterlevel#+1,0,0,1,0
   endif
  endif
  if tcameraclippingmode=2
   if gpuload4=0
    if camera exist(4)=1 then set camera clip 4,2,0,waterlevel#-1,0,0,-1,0
   endif
  endif
 endif 
 `
return

_sync_deletecameras:
 `
 rem delete cameras
` instead we keep the cameras existing, and use them after creation
` for c=1 to 7 : delete camera c : next c
 `
return

_sync_sequence:
 `
 rem X10 - 171007 - auto water refraction 
 if gautorefractionmode=1
  tperc#=camera position y(playercam)-waterlevel#
  lasthudwaterrefr=hudwaterrefr
  if abs(tperc#)<=100
   hudwaterrefr=100.0-abs(tperc#)
  else
   hudwaterrefr=0
  endif
  if lasthudwaterrefr<>hudwaterrefr
   hudwaterrefrupdate=1
  endif
 endif
 `
 rem X10 - 220807 - Control which processes are active based on effect values
 if hudwaterrefl=0 then gpuload4=1 else gpuload4=0
 if hudwaterrefr=0 then gpuload1=1 else gpuload1=0
 if hudshadowstrength=0 : gpuload2=1 : gpuload3=1 : else : gpuload2=0 : gpuload3=0 : endif
 if hudshadowquantity=0 : gpuload2=1 : gpuload3=1 : else : gpuload2=0 : gpuload3=0 : endif
 if hudbloomstrength(waterisbelowplayer-1)=0 : gpuload6=1 : gpuload7=1 : else : gpuload6=0 : gpuload7=0 : endif
 `
 rem If detect change in render processes, clear out old camera renders
 `tchanged=(gpuload1<<1)+(gpuload2<<2)+(gpuload3<<3)+(gpuload4<<4)+(gpuload5<<5)+(gpuload6<<6)
 tchanged=(gpuload2<<2)+(gpuload3<<3)+(gpuload4<<4)+(gpuload5<<5)+(gpuload6<<6)
 if tchanged<>tlastchanged
  tlastchanged=tchanged
  if gpuload2=1 then position camera 2,50000,50000,50000 : point camera 2,50000,60000,50000
  if gpuload3=1 then clear camera view 3,0
  if gpuload4=1 then position camera 4,50000,50000,50000 : point camera 4,50000,60000,50000
  if gpuload6=1 then clear camera view 6,0
  if gpuload7=1 then clear camera view 7,0
  sync mask camask(2) : fastsync
  sync mask camask(3) : fastsync
  sync mask camask(4) : fastsync
  sync mask camask(6) : fastsync
  sync mask camask(7) : fastsync
 endif
 `
 rem SYNC performance meters
 gamesyncperftimestamp=perftimer()
 `
 rem Simple Or Sophisticated
 if playercam<>0
  `
  rem Align sync cameras to main camera
  if camera exist(2)=1
   position camera 2,camera position x(playercam),camera position y(playercam),camera position z(playercam)
   rotate camera 2,camera angle x(playercam),camera angle y(playercam),camera angle z(playercam)
  endif
  if camera exist(4)=1
   position camera 4,camera position x(playercam),camera position y(playercam),camera position z(playercam)
   rotate camera 4,camera angle x(playercam),camera angle y(playercam),camera angle z(playercam)
  endif
  `280807 - no more camera one
  `if camera exist(5)=1
  ` position camera 5,camera position x(playercam),camera position y(playercam),camera position z(playercam)
  ` rotate camera 5,camera angle x(playercam),camera angle y(playercam),camera angle z(playercam)
  `endif
  `
  rem Render Reflection first
  if gpuload4=0 then sync mask camask(4) : fastsync : rem FOR REFLECTION
  `
  rem Stat1
  gamesyncperfsync(1)=gamesyncperfsync(1)+(perftimer()-gamesyncperftimestamp)
  gamesyncperftimestamp=perftimer()
  `
  rem After FIRST FASTSYNC, animation/transform Update will have taken place
  rem which means we can use the new world positions/transforms/etc for things
  rem like gun placement, pseudo-glued objects, etc 
  gosub _sync_align_pseudoglued_objects
  rem But we need to update any instance buffers holding instance positions
  rem like guns more than 10 so we can see them aligned correctly (in sync)
  rem this is achieved within the engine with a piece of code before each
  rem FASTSYNC which checks if there have been any instance buffer changes
  rem since the main UPDATE (SYNC) work and update accordingly (using a global flag)
  `
  rem Stat2
  gamesyncperfsync(2)=gamesyncperfsync(2)+(perftimer()-gamesyncperftimestamp)
  gamesyncperftimestamp=perftimer()
  `
  rem If no glass found in sequence, we scan skip the glass slicing render in camera 5
  tindexofclosestglassifany=0
  `
  rem [5] part A
  if gpuload5=0
   `
   rem Just camrea 5
   sync mask camask(5)
   `
   rem Hide water (while we render under the water)
   hide object 11
   if currentgunobj>0 then hide object currentgunobj
   `
   rem Glass should not refract under water
   if grefractionshadereffect>0
    if effect exist(grefractionshadereffect)=1
     set effect technique grefractionshadereffect,"DrawInstNoRefraction"
    endif
   endif
   `
   rem [5] UNDER - clip to render only below water
   if tcameraclippingmode=1
    set camera clip 5,1,0,waterlevel#+4,0,0,-1,0
   else
    set camera clip 5,1,0,waterlevel#-4,0,0,1,0
   endif
   `
   rem [5] If refraction enabled, render scene for refr source
   if gpuload1=0
    fastsync : copy camera to image 5,19876 : rem store for water refraction
   endif
   `
   rem Stat3
   gamesyncperfsync(3)=gamesyncperfsync(3)+(perftimer()-gamesyncperftimestamp)
   gamesyncperftimestamp=perftimer()
   `
   rem Show water (while we render refraction beyond window)
   show object 11
   if hudwaterrefl>0 or hudwaterrefr>0
    set effect technique watereffectid,"DrawRefractReflect"
    set object transparency 11,1
   else
    set effect technique watereffectid,"DrawColor"
    set object transparency 11,2
   endif
   `
   rem Hide windows (while we render refraction beyond window)
   if grefractionshadereffect>0 and hudglassrefr>0
    rem X10 - 131007 - only if we have a window in the level that refracts
    tglassdirection=-1
    tclosestglass#=999999.99
    for e=1 to entityelementlist
     obj=entityelement(e).obj
     if obj>0 and entityelement(e).active=1
      entid=entityelement(e).bankindex
      if object exist(obj)=1
       if entityprofile(entid).usingeffect=grefractionshadereffect
        rem must still be calculating which one
        if tindexofclosestglassifany<>-1
         rem must also be facing it (obj must be in screen and visible)
         if object in screen(obj)=1 and object visible(obj)=1
          rem and must be the first OR only glass facing this direction (RY)
          if tglassdirection=-1 or entityelement(e).ry=tglassdirection
           rem if facing same direction, must be on same plane otherwise player can stand between 
           rem the windows which may create a two planes running into distance with plr in middle problem
           tokay=1
           if tindexofclosestglassifany>0
            if tglassdirection=0 or tglassdirection=180
             if abs(entityelement(tindexofclosestglassifany).z-entityelement(e).z)>10
              rem horizontal plane direction with vertical span between windows
              tokay=0
             endif
            else
             if abs(entityelement(tindexofclosestglassifany).x-entityelement(e).x)>10
              rem vertical plane direction with horizontal span between windows
              tokay=0
             endif
            endif
            if tokay=0
             rem more than one glass plane in scene (cannot slice this scene)
             tindexofclosestglassifany=-1
            endif
           endif
           if tokay=1          
            rem must be nearest
            tthisglassdistance#=entityelement(e).plrdist
            if tthisglassdistance#<tclosestglass#
             tglassdirection=entityelement(e).ry
             tclosestglass#=tthisglassdistance#
             tindexofclosestglassifany=e
            endif
           endif
          else
           rem more than one glass, and they face different ways
           tindexofclosestglassifany=-1
          endif
         endif
        endif
        hide object obj
       endif
      endif
     endif
    next e
   endif
   `
   rem [5] BEYOND WINDOW - clip behind nearest window
   if tindexofclosestglassifany>0
    rem found glass closest to player, create ONE clip at window
    nearestwindowx#=entityelement(tindexofclosestglassifany).x
    nearestwindowy#=entityelement(tindexofclosestglassifany).y
    nearestwindowz#=entityelement(tindexofclosestglassifany).z
    nearestwindowpx#=newxvalue(0,entityelement(tindexofclosestglassifany).ry,-1.0)
    nearestwindowpz#=newzvalue(0,entityelement(tindexofclosestglassifany).ry,-1.0)
    nearestwindowpy#=0.0
    viewanglex#=nearestwindowx#-camera position x(playercam)
    viewanglez#=nearestwindowz#-camera position z(playercam)
    viewangle#=atanfull(viewanglex#,viewanglez#)
    viewangle#=abs(entityelement(tindexofclosestglassifany).ry-viewangle#)
    if viewangle#>90 and viewangle#<270
     rem facing front of glass
     tdirectionofnormal#=-1.0
    else
     rem facing back of glass
     tdirectionofnormal#=1.0
    endif
    tobj=entityelement(tindexofclosestglassifany).obj
    nearestwindowpx#=newxvalue(0,entityelement(tindexofclosestglassifany).ry,tdirectionofnormal#)
    nearestwindowpz#=newzvalue(0,entityelement(tindexofclosestglassifany).ry,tdirectionofnormal#)
    set camera clip 5,1,nearestwindowx#,nearestwindowy#,nearestwindowz#,nearestwindowpx#,nearestwindowpy#,nearestwindowpz#
    fastsync
    copy camera to image 5,19877 : rem store for glass refraction
   else
    if tindexofclosestglassifany=-1
     rem too much glass, FULL refraction no clip required
     set camera clip 5,0,0,0,0,0,0,0
     fastsync
     copy camera to image 5,19877 : rem store for glass refraction
    else
     rem no glass no refraction no clip required
    endif
   endif
   `
  endif
  `
  rem Stat4
  gamesyncperfsync(4)=gamesyncperfsync(4)+(perftimer()-gamesyncperftimestamp)
  gamesyncperftimestamp=perftimer()
  `
  rem [5] part B (allows time for refraction images to finish async GPU copyresource
  if gpuload5=0
   `
   rem Just camrea 5
   sync mask camask(5)
   `
   rem Add windows back (while we render rest including windows)
   for e=1 to entityelementlist
    obj=entityelement(e).obj
    if obj>0 and entityelement(e).active=1
     entid=entityelement(e).bankindex
     if object exist(obj)=1
      if entityprofile(entid).usingeffect=grefractionshadereffect
       show object obj
      endif
     endif
    endif
   next e
   `
   rem also allow glass to use refraction now we have some
   if grefractionshadereffect>0
    if effect exist(grefractionshadereffect)=1
     if hudglassrefr=0
      rem X10 - 131007 - if set refraction value to zero, use non refraction technique
      set effect technique grefractionshadereffect,"DrawInstNoRefraction"
     else
      set effect technique grefractionshadereffect,"DrawInst"
     endif
    endif
   endif
   `
   rem X10 - 231007 - Show gun in main camera scene (no zdepth disabled) if capturing
   if gpuload5=0 and snapshotmodeframebyframe>0
    if showgamemenu=0 and currentgunobj>0 then show object currentgunobj
   endif
   `
   rem Render entire scene as final scene
   rem 260807 - note - rendering 'rest' problem is hiding ALL except what we missed
   rem and the fact windows/water must be rendered into the scene (not just after clip)
   rem plus clip rendering costs VS performance hit
   set camera clip 5,0,0,0,0,0,0,0
   fastsync
   `
  endif
  `
  rem Stat5
  gamesyncperfsync(5)=gamesyncperfsync(5)+(perftimer()-gamesyncperftimestamp)
  gamesyncperftimestamp=perftimer()
  `
  rem Render shadows using depths of main Game Scene (5)
  if gpuload2=0 then sync mask camask(2) : fastsync : rem Shadow Scene
  if gpuload3=0 then sync mask camask(3) : fastsync : rem Soft Shadow
  `
  rem [5] part C (draw nozdepth objects)
  if gpuload5=0 and snapshotmodeframebyframe=0
   rem X10 250907 - do not draw gun manually if in game menu (flickers)
   if showgamemenu=0
    rem Can render gun now shadows taken care of (gun wipes zdepth above!)
    if currentgunobj>0
     sync mask camask(5)
     show object currentgunobj
     draw object currentgunobj,5
    endif
   endif
  endif
  `
  rem Stat6
  gamesyncperfsync(6)=gamesyncperfsync(6)+(perftimer()-gamesyncperftimestamp)
  gamesyncperftimestamp=perftimer()
  `
  rem Now compose the final bloom blurs
  if gpuload6=0 then sync mask camask(8) : fastsync : rem Bloom DOWNSIZE 1
  if gpuload6=0 then sync mask camask(6) : fastsync : rem Bloom DOWNSIZE 2
  if gpuload7=0 then sync mask camask(9) : fastsync : rem Bloom BLUR H and V
  if gpuload7=0 then sync mask camask(7) : fastsync : rem Bloom BLUR H and V
  `
  rem Stat7
  gamesyncperfsync(7)=gamesyncperfsync(7)+(perftimer()-gamesyncperftimestamp)
  gamesyncperftimestamp=perftimer()
  `
  rem Post process final render
  sync mask %1
  `
  rem update main/last screen
  sync
  `
  rem X10 - 231007 - frame by frame snpshot feature
  if snapshotmodeframebyframe>0
   if snapshotmodeframebyframe=1
    t1$=get date$() : t2$=get time$()
    snapshotmodeframebyframe$="snapshots_"+left$(t1$,2)+left$(right$(t1$,5),2)+right$(t1$,2)+left$(t2$,2)+left$(right$(t2$,5),2)+right$(t2$,2)
    tolddir$=get dir$()
    set dir myownrootdir$
    make directory snapshotmodeframebyframe$
    set dir tolddir$
   endif
   rem take a snapshot immediately
   save screenshot myownrootdir$+"\"+snapshotmodeframebyframe$+"\shot-"+right$(str$(1000+snapshotmodeframebyframe),3)+".bmp"
   inc snapshotmodeframebyframe
   if spacekey()=1
    rem exit snapshot feature
    snapshotmodeframebyframe=0
   endif
  endif
  `
  rem 302007 - study frame by frame mode (set leeleepause to 1)
  `if leeleepause>0
  ` if leeleepause=1 then sleep 4000
  ` if leeleepause=2 then sleep 3000
  ` if leeleepause=3 then sleep 2000
  ` if leeleepause=4 then sleep 1000
  ` if leeleepause=5 then leeleepause=-1
  ` leeleepause=leeleepause+1
  `endif
  `
 else
  `
  rem Update screen
  sync
  `
 endif
 `
 rem Stat8
 gamesyncperfsync(8)=gamesyncperfsync(8)+(perftimer()-gamesyncperftimestamp)
 gamesyncperftimestamp=perftimer()
 `
 rem Call any video or screenshot capture code now backbuffer is complete
 capturesession()
 `
 rem Stat9
 gamesyncperfsync(9)=gamesyncperfsync(9)+(perftimer()-gamesyncperftimestamp)
 gamesyncperftimestamp=perftimer()
 `
return

_sync_align_pseudoglued_objects:
 `
 rem Go through all entities for POST-VISUAL ALIGNMENTS (guns attached to enemies)
 for e=1 to entityelementlist
  obj=entityelement(e).obj
  entid=entityelement(e).bankindex
  if entityelement(e).active=1 and entityelement(e).dormant=0
   if obj>0
    if object exist(obj)=1 and entityelement(e).plrdist<2000
     if object visible(obj)=1
      gosub _entity_controlattachments 
     endif
    endif
   endif
  endif
 next e
 `
return

function camask(camid)
 mask = %1 << camid
endfunction mask

function makecamera(camid,name$,mode,width,height,shader$,tex0,tex1,tex2,depthsteal,reflectmode,usestencil)
 camname$(camid)=name$
 if camid=0
  rem main backbuffer
  make object plain 1,2,2,1 : set object mask 1,%1
  texture object 1,0,tex0
  if tex1>0 then texture object 1,1,tex1
  if tex2>0 then texture object 1,2,tex2
  tfile$=shader$ : addfiletocollection(commoneffects$+tfile$)
  dirbefore$=get dir$() : set dir commoneffects$
  load effect tfile$,1,0 : set object effect 1,1
  set dir dirbefore$
 else
  rem pipeline cameras
  if camera exist(camid)=0 
   make camera camid : color backdrop camid,rgb(0,0,0)
  endif
  if name$="REDUNDANT"
   rem camera not used for anything any more
   color backdrop camid,0
   set camera view camid,0,0,1,1
  else
   set camera to image camid,camid,width,height,usestencil
   if reflectmode>0
    if reflectmode=1
     rem clip only - refract
     color backdrop camid,rgb(32,32,32)
     set camera clip camid,1,0,-10,0,0,-1,0
    endif
    if reflectmode=2
     rem mirror and clip - reflect
     color backdrop camid,rgb(32,32,32)
     set camera clip camid,2,0,-10,0,0,1,0
    endif
   endif
   if mode=1
    make object plain camid,2,2,2
    cammask=%1 : if camid>0 then cammask=cammask<<camid
    set object mask camid,cammask
    texture object camid,0,tex0
    if tex1>0 then texture object camid,1,tex1
    if tex2>0 then texture object camid,2,tex2
    tfile$=shader$ : addfiletocollection(commoneffects$+tfile$)
    dirbefore$=get dir$() : set dir commoneffects$
    load effect tfile$,camid,0
    set dir dirbefore$
    set object effect camid,camid
   endif
   if depthsteal>0
    color backdrop camid,rgb(0,0,0)
    set camera depth camid,depthsteal
   endif
  endif
 endif
endfunction
